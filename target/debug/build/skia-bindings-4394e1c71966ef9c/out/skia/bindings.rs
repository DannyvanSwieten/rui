/* automatically generated by rust-bindgen 0.60.1 */

#![allow(clippy::all)]
#![allow(unknown_lints)]
#![allow(deref_nullptr)]
#![allow(improper_ctypes)]
pub enum GrContext_Base {}
pub enum GrImageContext {}
pub enum GrImageContextPriv {}
pub enum GrContextThreadSafeProxy {}
pub enum GrContextThreadSafeProxyPriv {}
pub enum GrRecordingContextPriv {}
pub enum GrContextPriv {}
pub enum SkVerticesPriv {}

# [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] pub struct __BindgenBitfieldUnit < Storage > { storage : Storage , } impl < Storage > __BindgenBitfieldUnit < Storage > { # [inline] pub const fn new (storage : Storage) -> Self { Self { storage } } } impl < Storage > __BindgenBitfieldUnit < Storage > where Storage : AsRef < [u8] > + AsMut < [u8] >, { # [inline] pub fn get_bit (& self , index : usize) -> bool { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = self . storage . as_ref () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; byte & mask == mask } # [inline] pub fn set_bit (& mut self , index : usize , val : bool) { debug_assert ! (index / 8 < self . storage . as_ref () . len ()) ; let byte_index = index / 8 ; let byte = & mut self . storage . as_mut () [byte_index] ; let bit_index = if cfg ! (target_endian = "big") { 7 - (index % 8) } else { index % 8 } ; let mask = 1 << bit_index ; if val { * byte |= mask ; } else { * byte &= ! mask ; } } # [inline] pub fn get (& self , bit_offset : usize , bit_width : u8) -> u64 { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; let mut val = 0 ; for i in 0 .. (bit_width as usize) { if self . get_bit (i + bit_offset) { let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; val |= 1 << index ; } } val } # [inline] pub fn set (& mut self , bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width <= 64) ; debug_assert ! (bit_offset / 8 < self . storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width as usize)) / 8 <= self . storage . as_ref () . len ()) ; for i in 0 .. (bit_width as usize) { let mask = 1 << i ; let val_bit_is_set = val & mask == mask ; let index = if cfg ! (target_endian = "big") { bit_width as usize - 1 - i } else { i } ; self . set_bit (index + bit_offset , val_bit_is_set) ; } } } # [repr (C)] pub struct __BindgenUnionField < T > (:: core :: marker :: PhantomData < T >) ; impl < T > __BindgenUnionField < T > { # [inline] pub const fn new () -> Self { __BindgenUnionField (:: core :: marker :: PhantomData) } # [inline] pub unsafe fn as_ref (& self) -> & T { :: core :: mem :: transmute (self) } # [inline] pub unsafe fn as_mut (& mut self) -> & mut T { :: core :: mem :: transmute (self) } } impl < T > :: core :: default :: Default for __BindgenUnionField < T > { # [inline] fn default () -> Self { Self :: new () } } impl < T > :: core :: clone :: Clone for __BindgenUnionField < T > { # [inline] fn clone (& self) -> Self { Self :: new () } } impl < T > :: core :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: core :: fmt :: Debug for __BindgenUnionField < T > { fn fmt (& self , fmt : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { fmt . write_str ("__BindgenUnionField") } } impl < T > :: core :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: core :: hash :: Hasher > (& self , _state : & mut H) { } } impl < T > :: core :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq (& self , _other : & __BindgenUnionField < T >) -> bool { true } } impl < T > :: core :: cmp :: Eq for __BindgenUnionField < T > { } pub type va_list = * mut :: std :: os :: raw :: c_char ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _Mbstatet { pub _Wchar : :: std :: os :: raw :: c_ulong , pub _Byte : :: std :: os :: raw :: c_ushort , pub _State : :: std :: os :: raw :: c_ushort , } # [test] fn bindgen_test_layout__Mbstatet () { assert_eq ! (:: core :: mem :: size_of :: < _Mbstatet > () , 8usize , concat ! ("Size of: " , stringify ! (_Mbstatet))) ; assert_eq ! (:: core :: mem :: align_of :: < _Mbstatet > () , 4usize , concat ! ("Alignment of " , stringify ! (_Mbstatet))) ; fn test_field__Wchar () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < _Mbstatet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . _Wchar) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_Wchar))) ; } test_field__Wchar () ; fn test_field__Byte () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < _Mbstatet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . _Byte) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_Byte))) ; } test_field__Byte () ; fn test_field__State () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < _Mbstatet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . _State) as usize - ptr as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (_Mbstatet) , "::" , stringify ! (_State))) ; } test_field__State () ; } pub type std_integral_constant_value_type < _Ty > = _Ty ; pub type std_integral_constant_type = u8 ; pub type std_bool_constant = u8 ; pub type std_true_type = u8 ; pub type std_enable_if_t = u8 ; pub type std_conditional_type < _Ty1 > = _Ty1 ; pub type std_conditional_t = u8 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_remove_const { pub _address : u8 , } pub type std_remove_const_type < _Ty > = _Ty ; pub type std_remove_const_t = std_remove_const ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_remove_cv { pub _address : u8 , } pub type std_remove_cv_type < _Ty > = _Ty ; pub type std_remove_cv__Apply = u8 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_less { pub _address : u8 , } pub type std_less_first_argument_type < _Ty > = _Ty ; pub type std_less_second_argument_type < _Ty > = _Ty ; pub type std_less_result_type = bool ; pub type std__Select__Apply < _Ty1 > = _Ty1 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_make_signed { pub _address : u8 , } pub type std_make_signed_type = std_remove_cv ; pub type std_make_signed_t = std_make_signed ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_pair < _Ty1 , _Ty2 > { pub first : _Ty1 , pub second : _Ty2 , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Ty1 > > , pub _phantom_1 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Ty2 > > , } pub type std_pair_first_type < _Ty1 > = _Ty1 ; pub type std_pair_second_type < _Ty2 > = _Ty2 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_first_parameter { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Replace_first_parameter { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_element_type { pub _address : u8 , } pub type std__Get_element_type_type = std__Get_first_parameter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_ptr_difference_type { pub _address : u8 , } pub type std__Get_ptr_difference_type_type = :: std :: os :: raw :: c_longlong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_rebind_alias { pub _address : u8 , } pub type std__Get_rebind_alias_type = std__Replace_first_parameter ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_pointer_traits { pub _address : u8 , } pub type std_pointer_traits_pointer < _Ty > = _Ty ; pub type std_pointer_traits_element_type = std__Get_element_type ; pub type std_pointer_traits_difference_type = std__Get_ptr_difference_type ; pub type std_pointer_traits_rebind = std__Get_rebind_alias ; pub type std_pointer_traits__Reftype = * mut std_conditional_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_input_iterator_tag { pub _address : u8 , } # [test] fn bindgen_test_layout_std_input_iterator_tag () { assert_eq ! (:: core :: mem :: size_of :: < std_input_iterator_tag > () , 1usize , concat ! ("Size of: " , stringify ! (std_input_iterator_tag))) ; assert_eq ! (:: core :: mem :: align_of :: < std_input_iterator_tag > () , 1usize , concat ! ("Alignment of " , stringify ! (std_input_iterator_tag))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_forward_iterator_tag { pub _address : u8 , } # [test] fn bindgen_test_layout_std_forward_iterator_tag () { assert_eq ! (:: core :: mem :: size_of :: < std_forward_iterator_tag > () , 1usize , concat ! ("Size of: " , stringify ! (std_forward_iterator_tag))) ; assert_eq ! (:: core :: mem :: align_of :: < std_forward_iterator_tag > () , 1usize , concat ! ("Alignment of " , stringify ! (std_forward_iterator_tag))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_bidirectional_iterator_tag { pub _address : u8 , } # [test] fn bindgen_test_layout_std_bidirectional_iterator_tag () { assert_eq ! (:: core :: mem :: size_of :: < std_bidirectional_iterator_tag > () , 1usize , concat ! ("Size of: " , stringify ! (std_bidirectional_iterator_tag))) ; assert_eq ! (:: core :: mem :: align_of :: < std_bidirectional_iterator_tag > () , 1usize , concat ! ("Alignment of " , stringify ! (std_bidirectional_iterator_tag))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_random_access_iterator_tag { pub _address : u8 , } # [test] fn bindgen_test_layout_std_random_access_iterator_tag () { assert_eq ! (:: core :: mem :: size_of :: < std_random_access_iterator_tag > () , 1usize , concat ! ("Size of: " , stringify ! (std_random_access_iterator_tag))) ; assert_eq ! (:: core :: mem :: align_of :: < std_random_access_iterator_tag > () , 1usize , concat ! ("Alignment of " , stringify ! (std_random_access_iterator_tag))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Iterator_traits_base { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_iterator_traits { pub _address : u8 , } pub type std__Iter_ref_t = std_iterator_traits ; pub type std__Iter_value_t = std_iterator_traits ; pub type std__Iter_diff_t = std_iterator_traits ; pub type std__Iter_cat_t = std_iterator_traits ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_reverse_iterator < _BidIt > { pub current : _BidIt , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _BidIt > > , } pub type std_reverse_iterator_iterator_type < _BidIt > = _BidIt ; pub type std_reverse_iterator_iterator_category = std__Iter_cat_t ; pub type std_reverse_iterator_value_type = std__Iter_value_t ; pub type std_reverse_iterator_difference_type = std__Iter_diff_t ; pub type std_reverse_iterator_pointer = std_iterator_traits ; pub type std_reverse_iterator_reference = std__Iter_ref_t ; pub type std_reverse_iterator__Prevent_inheriting_unwrap < _BidIt > = std_reverse_iterator < _BidIt > ; pub type std__Rebind_pointer_t = std_pointer_traits ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_allocator_traits { pub _address : u8 , } pub type std__Rebind_alloc_t = std_allocator_traits ; # [repr (C)] # [derive (Debug)] pub struct std_allocator { pub _address : u8 , } pub type std_allocator__From_primary = std_allocator ; pub type std_allocator_value_type < _Ty > = _Ty ; pub type std_allocator_pointer < _Ty > = * mut _Ty ; pub type std_allocator_const_pointer < _Ty > = * const _Ty ; pub type std_allocator_reference < _Ty > = * mut _Ty ; pub type std_allocator_const_reference < _Ty > = * const _Ty ; pub type std_allocator_size_type = :: std :: os :: raw :: c_ulonglong ; pub type std_allocator_difference_type = :: std :: os :: raw :: c_longlong ; pub type std_allocator_propagate_on_container_move_assignment = std_true_type ; pub type std_allocator_is_always_equal = std_true_type ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_allocator_rebind { pub _address : u8 , } pub type std_allocator_rebind_other = std_allocator ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Container_base0 { pub _address : u8 , } # [test] fn bindgen_test_layout_std__Container_base0 () { assert_eq ! (:: core :: mem :: size_of :: < std__Container_base0 > () , 1usize , concat ! ("Size of: " , stringify ! (std__Container_base0))) ; assert_eq ! (:: core :: mem :: align_of :: < std__Container_base0 > () , 1usize , concat ! ("Alignment of " , stringify ! (std__Container_base0))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Iterator_base0 { pub _address : u8 , } pub const std__Iterator_base0__Unwrap_when_unverified : bool = true ; # [test] fn bindgen_test_layout_std__Iterator_base0 () { assert_eq ! (:: core :: mem :: size_of :: < std__Iterator_base0 > () , 1usize , concat ! ("Size of: " , stringify ! (std__Iterator_base0))) ; assert_eq ! (:: core :: mem :: align_of :: < std__Iterator_base0 > () , 1usize , concat ! ("Alignment of " , stringify ! (std__Iterator_base0))) ; } pub type std__Container_base = std__Container_base0 ; pub type std__Iterator_base = std__Iterator_base0 ; pub type std__Compressed_pair__Mybase < _Ty1 > = _Ty1 ; # [repr (C)] pub struct std__Vector_const_iterator { pub _Ptr : std__Vector_const_iterator__Tptr , } pub type std__Vector_const_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__Vector_const_iterator_value_type = [u8 ; 0usize] ; pub type std__Vector_const_iterator_difference_type = [u8 ; 0usize] ; pub type std__Vector_const_iterator_pointer = [u8 ; 0usize] ; pub type std__Vector_const_iterator_reference = * const std__Vector_const_iterator_value_type ; pub type std__Vector_const_iterator__Tptr = [u8 ; 0usize] ; pub type std__Vector_const_iterator__Prevent_inheriting_unwrap = std__Vector_const_iterator ; # [repr (C)] pub struct std__Vector_iterator { pub _base : std__Vector_const_iterator , } pub type std__Vector_iterator__Mybase = std__Vector_const_iterator ; pub type std__Vector_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__Vector_iterator_value_type = [u8 ; 0usize] ; pub type std__Vector_iterator_difference_type = [u8 ; 0usize] ; pub type std__Vector_iterator_pointer = [u8 ; 0usize] ; pub type std__Vector_iterator_reference = * mut std__Vector_iterator_value_type ; pub type std__Vector_iterator__Prevent_inheriting_unwrap = std__Vector_iterator ; # [repr (C)] pub struct std__Vector_val { pub _Myfirst : std__Vector_val_pointer , pub _Mylast : std__Vector_val_pointer , pub _Myend : std__Vector_val_pointer , } pub type std__Vector_val_value_type = [u8 ; 0usize] ; pub type std__Vector_val_size_type = [u8 ; 0usize] ; pub type std__Vector_val_difference_type = [u8 ; 0usize] ; pub type std__Vector_val_pointer = [u8 ; 0usize] ; pub type std__Vector_val_const_pointer = [u8 ; 0usize] ; pub type std__Vector_val_reference = * mut std__Vector_val_value_type ; pub type std__Vector_val_const_reference = * const std__Vector_val_value_type ; pub type std__SMF_control_move_assign = std_conditional_t ; pub type std__SMF_control = std__SMF_control_move_assign ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Nontrivial_dummy_type { pub _address : u8 , } # [test] fn bindgen_test_layout_std__Nontrivial_dummy_type () { assert_eq ! (:: core :: mem :: size_of :: < std__Nontrivial_dummy_type > () , 1usize , concat ! ("Size of: " , stringify ! (std__Nontrivial_dummy_type))) ; assert_eq ! (:: core :: mem :: align_of :: < std__Nontrivial_dummy_type > () , 1usize , concat ! ("Alignment of " , stringify ! (std__Nontrivial_dummy_type))) ; } # [repr (C)] pub union std__Optional_destruct_base__bindgen_ty_1 { pub _Dummy : std__Nontrivial_dummy_type , pub _Value : std_remove_const_t , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Optional_construct_base { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_optional { pub _address : u8 , } pub type std_optional__Mybase = std__SMF_control ; pub type std_optional_value_type < _Ty > = _Ty ; pub type std_optional__AllowDirectConversion = std_bool_constant ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_optional__AllowUnwrapping { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_optional__AllowUnwrappingAssignment { pub _address : u8 , } pub type std__Choose_atomic_base2_t = u8 ; pub type std__Choose_atomic_base_t = std__Choose_atomic_base2_t ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_atomic { pub _address : u8 , } pub type std_atomic__Base = std__Choose_atomic_base_t ; pub type std_atomic_value_type < _Ty > = _Ty ; pub type std_streamoff = :: std :: os :: raw :: c_longlong ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_fpos < _Statetype > { pub _Myoff : std_streamoff , pub _Fpos : :: std :: os :: raw :: c_longlong , pub _Mystate : _Statetype , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Statetype > > , } pub type std_streampos = std_fpos < _Mbstatet > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_default_delete { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_deleter_pointer_type { pub _address : u8 , } pub type std__Get_deleter_pointer_type_type < _Ty > = * mut _Ty ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_unique_ptr { pub _address : u8 , } pub type std_unique_ptr_pointer = std__Get_deleter_pointer_type ; pub type std_unique_ptr_element_type < _Ty > = _Ty ; pub type std_unique_ptr_deleter_type < _Dx > = _Dx ; pub type std__Array_const_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__Array_const_iterator_value_type < _Ty > = _Ty ; pub type std__Array_const_iterator_difference_type = :: std :: os :: raw :: c_longlong ; pub type std__Array_const_iterator_pointer < _Ty > = * const _Ty ; pub type std__Array_const_iterator_reference < _Ty > = * const _Ty ; pub const std__Array_const_iterator__EEN_SIZE : std__Array_const_iterator__bindgen_ty_1 = std__Array_const_iterator__bindgen_ty_1 :: _EEN_SIZE ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum std__Array_const_iterator__bindgen_ty_1 { _EEN_SIZE = 0 , } pub type std__Array_const_iterator__Prevent_inheriting_unwrap = u8 ; pub type std__Array_iterator__Mybase = u8 ; pub type std__Array_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__Array_iterator_value_type < _Ty > = _Ty ; pub type std__Array_iterator_difference_type = :: std :: os :: raw :: c_longlong ; pub type std__Array_iterator_pointer < _Ty > = * mut _Ty ; pub type std__Array_iterator_reference < _Ty > = * mut _Ty ; pub const std__Array_iterator__EEN_SIZE : std__Array_iterator__bindgen_ty_1 = std__Array_iterator__bindgen_ty_1 :: _EEN_SIZE ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum std__Array_iterator__bindgen_ty_1 { _EEN_SIZE = 0 , } pub type std__Array_iterator__Prevent_inheriting_unwrap = u8 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Char_traits { pub _address : u8 , } pub type std__Char_traits_char_type < _Elem > = _Elem ; pub type std__Char_traits_int_type < _Int_type > = _Int_type ; pub type std__Char_traits_pos_type = std_streampos ; pub type std__Char_traits_off_type = std_streamoff ; pub type std__Char_traits_state_type = _Mbstatet ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_char_traits { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__String_view_iterator { pub _Myptr : std__String_view_iterator_pointer , } pub type std__String_view_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__String_view_iterator_value_type = [u8 ; 0usize] ; pub type std__String_view_iterator_difference_type = :: std :: os :: raw :: c_longlong ; pub type std__String_view_iterator_pointer = * const std__String_view_iterator_value_type ; pub type std__String_view_iterator_reference = * const std__String_view_iterator_value_type ; pub type std__String_view_iterator__Prevent_inheriting_unwrap = std__String_view_iterator ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_basic_string_view < _Elem > { pub _Mydata : std_basic_string_view_const_pointer < _Elem > , pub _Mysize : std_basic_string_view_size_type , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Elem > > , } pub type std_basic_string_view_traits_type < _Traits > = _Traits ; pub type std_basic_string_view_value_type < _Elem > = _Elem ; pub type std_basic_string_view_pointer < _Elem > = * mut _Elem ; pub type std_basic_string_view_const_pointer < _Elem > = * const _Elem ; pub type std_basic_string_view_reference < _Elem > = * mut _Elem ; pub type std_basic_string_view_const_reference < _Elem > = * const _Elem ; pub type std_basic_string_view_const_iterator = std__String_view_iterator ; pub type std_basic_string_view_iterator = std_basic_string_view_const_iterator ; pub type std_basic_string_view_const_reverse_iterator = std_reverse_iterator < std_basic_string_view_const_iterator > ; pub type std_basic_string_view_reverse_iterator = std_basic_string_view_const_reverse_iterator ; pub type std_basic_string_view_size_type = :: std :: os :: raw :: c_ulonglong ; pub type std_basic_string_view_difference_type = :: std :: os :: raw :: c_longlong ; pub type std_string_view = std_basic_string_view < :: std :: os :: raw :: c_char > ; # [repr (C)] pub struct std__String_const_iterator { pub _Ptr : std__String_const_iterator_pointer , } pub type std__String_const_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__String_const_iterator_value_type = [u8 ; 0usize] ; pub type std__String_const_iterator_difference_type = [u8 ; 0usize] ; pub type std__String_const_iterator_pointer = [u8 ; 0usize] ; pub type std__String_const_iterator_reference = * const std__String_const_iterator_value_type ; pub type std__String_const_iterator__Prevent_inheriting_unwrap = std__String_const_iterator ; # [repr (C)] pub struct std__String_iterator { pub _base : std__String_const_iterator , } pub type std__String_iterator__Mybase = std__String_const_iterator ; pub type std__String_iterator_iterator_category = std_random_access_iterator_tag ; pub type std__String_iterator_value_type = [u8 ; 0usize] ; pub type std__String_iterator_difference_type = [u8 ; 0usize] ; pub type std__String_iterator_pointer = [u8 ; 0usize] ; pub type std__String_iterator_reference = * mut std__String_iterator_value_type ; pub type std__String_iterator__Prevent_inheriting_unwrap = std__String_iterator ; # [repr (C)] pub struct std__String_val { pub _Bx : std__String_val__Bxty , pub _Mysize : std__String_val_size_type , pub _Myres : std__String_val_size_type , } pub type std__String_val_value_type = [u8 ; 0usize] ; pub type std__String_val_size_type = [u8 ; 0usize] ; pub type std__String_val_difference_type = [u8 ; 0usize] ; pub type std__String_val_pointer = [u8 ; 0usize] ; pub type std__String_val_const_pointer = [u8 ; 0usize] ; pub type std__String_val_reference = * mut std__String_val_value_type ; pub type std__String_val_const_reference = * const std__String_val_value_type ; # [repr (C)] pub struct std__String_val__Bxty { pub _Buf : __BindgenUnionField < * mut std__String_val_value_type > , pub _Ptr : __BindgenUnionField < std__String_val_pointer > , pub _Alias : __BindgenUnionField < * mut :: std :: os :: raw :: c_char > , pub bindgen_union_field : u64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_basic_string { pub _address : u8 , } pub type std_basic_string__Alty = std__Rebind_alloc_t ; pub type std_basic_string__Alty_traits = std_allocator_traits ; pub type std_basic_string__Scary_val = std__String_val ; pub type std_basic_string_traits_type < _Traits > = _Traits ; pub type std_basic_string_allocator_type < _Alloc > = _Alloc ; pub type std_basic_string_value_type = u8 ; pub type std_basic_string_size_type = std_basic_string__Alty_traits ; pub type std_basic_string_difference_type = std_basic_string__Alty_traits ; pub type std_basic_string_pointer = std_basic_string__Alty_traits ; pub type std_basic_string_const_pointer = std_basic_string__Alty_traits ; pub type std_basic_string_reference = * mut std_basic_string_value_type ; pub type std_basic_string_const_reference = * const std_basic_string_value_type ; pub type std_basic_string_iterator = std__String_iterator ; pub type std_basic_string_const_iterator = std__String_const_iterator ; pub type std_basic_string_reverse_iterator = std_reverse_iterator < std_basic_string_iterator > ; pub type std_basic_string_const_reverse_iterator = std_reverse_iterator < std_basic_string_const_iterator > ; pub type std_basic_string__Is_elem_cptr = std_bool_constant ; pub type std_basic_string__Is_string_view_ish = std_enable_if_t ; impl std_basic_string__Construct_strategy { pub const _From_ptr : std_basic_string__Construct_strategy = std_basic_string__Construct_strategy :: _From_char ; } impl std_basic_string__Construct_strategy { pub const _From_string : std_basic_string__Construct_strategy = std_basic_string__Construct_strategy :: _From_char ; } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum std_basic_string__Construct_strategy { _From_char = 0 , } pub type std_string = [u64 ; 4usize] ; pub type std_u16string = [u64 ; 4usize] ; pub type std_bitset__Ty = std_conditional_t ; # [repr (C)] # [derive (Debug)] pub struct std_bitset_reference { pub _Pbitset : * mut u8 , pub _Mypos : :: std :: os :: raw :: c_ulonglong , } extern "C" { # [link_name = "\u{1}_Need_mask"] pub static std_bitset__Need_mask : bool ; } extern "C" { # [link_name = "\u{1}_Mask"] pub static std_bitset__Mask : :: std :: os :: raw :: c_ulonglong ; } extern "C" { # [link_name = "\u{1}_Bitsperword"] pub static std_bitset__Bitsperword : :: std :: os :: raw :: c_longlong ; } extern "C" { # [link_name = "\u{1}_Words"] pub static std_bitset__Words : :: std :: os :: raw :: c_longlong ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Insert_return_type < _Iterator , _NodeType > { pub position : _Iterator , pub inserted : bool , pub node : _NodeType , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Iterator > > , pub _phantom_1 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _NodeType > > , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std__Get_function_impl { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_function { pub _address : u8 , } pub type std_function__Mybase = std__Get_function_impl ; extern "C" { # [link_name = "\u{1}num"] pub static std_ratio_num : :: std :: os :: raw :: c_longlong ; } extern "C" { # [link_name = "\u{1}den"] pub static std_ratio_den : :: std :: os :: raw :: c_longlong ; } pub type std_milli = u8 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct std_chrono_duration < _Rep > { pub _MyRep : _Rep , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < _Rep > > , } pub type std_chrono_duration_rep < _Rep > = _Rep ; pub type std_chrono_duration_period = [u8 ; 0usize] ; pub type std_chrono_milliseconds = std_chrono_duration < :: std :: os :: raw :: c_longlong > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _iobuf { pub _Placeholder : * mut :: core :: ffi :: c_void , } # [test] fn bindgen_test_layout__iobuf () { assert_eq ! (:: core :: mem :: size_of :: < _iobuf > () , 8usize , concat ! ("Size of: " , stringify ! (_iobuf))) ; assert_eq ! (:: core :: mem :: align_of :: < _iobuf > () , 8usize , concat ! ("Alignment of " , stringify ! (_iobuf))) ; fn test_field__Placeholder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < _iobuf > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . _Placeholder) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_iobuf) , "::" , stringify ! (_Placeholder))) ; } test_field__Placeholder () ; } pub type FILE = _iobuf ; pub type U8CPU = :: std :: os :: raw :: c_uint ; pub type SkFourByteTag = u32 ; pub type SkUnichar = i32 ; pub type SkGlyphID = u16 ; # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkBudgeted { kNo = 0 , kYes = 1 , } # [repr (C)] pub struct SkRefCntBase__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] # [derive (Debug)] pub struct SkRefCntBase { pub vtable_ : * const SkRefCntBase__bindgen_vtable , pub fRefCnt : u32 , } # [test] fn bindgen_test_layout_SkRefCntBase () { assert_eq ! (:: core :: mem :: size_of :: < SkRefCntBase > () , 16usize , concat ! ("Size of: " , stringify ! (SkRefCntBase))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRefCntBase > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRefCntBase))) ; fn test_field_fRefCnt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRefCntBase > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRefCnt) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRefCntBase) , "::" , stringify ! (fRefCnt))) ; } test_field_fRefCnt () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkRefCnt { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_SkRefCnt () { assert_eq ! (:: core :: mem :: size_of :: < SkRefCnt > () , 16usize , concat ! ("Size of: " , stringify ! (SkRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRefCnt > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRefCnt))) ; } # [repr (C)] # [derive (Debug)] pub struct SkNVRefCnt { pub fRefCnt : u32 , } # [repr (C)] # [derive (Debug)] pub struct sk_sp < T > { pub fPtr : * mut T , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } pub type sk_sp_element_type < T > = T ; pub type SkScalar = f32 ; # [repr (C)] # [derive (Debug)] pub struct SkAutoTArray { pub fArray : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkAutoTMalloc { pub _address : u8 , } # [repr (C)] pub struct SkAutoSTMalloc__bindgen_ty_1 < T > { pub fStorage32 : __BindgenUnionField < * mut u32 > , pub fTStorage : __BindgenUnionField < [T ; 1usize] > , pub bindgen_union_field : u64 , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } impl SkTArray_ReallocType { pub const kGrowing : SkTArray_ReallocType = SkTArray_ReallocType :: kExactFit ; } impl SkTArray_ReallocType { pub const kShrinking : SkTArray_ReallocType = SkTArray_ReallocType :: kExactFit ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTArray_ReallocType { kExactFit = 0 , } pub type SkTArray_value_type < T > = T ; # [repr (C)] # [derive (Debug)] pub struct SkString { pub fRec : sk_sp < SkString_Rec > , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkString_Rec { pub fLength : u32 , pub fRefCnt : u32 , pub fBeginningOfData : [:: std :: os :: raw :: c_char ; 1usize] , } # [test] fn bindgen_test_layout_SkString_Rec () { assert_eq ! (:: core :: mem :: size_of :: < SkString_Rec > () , 12usize , concat ! ("Size of: " , stringify ! (SkString_Rec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkString_Rec > () , 4usize , concat ! ("Alignment of " , stringify ! (SkString_Rec))) ; fn test_field_fLength () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkString_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLength) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkString_Rec) , "::" , stringify ! (fLength))) ; } test_field_fLength () ; fn test_field_fRefCnt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkString_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRefCnt) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkString_Rec) , "::" , stringify ! (fRefCnt))) ; } test_field_fRefCnt () ; fn test_field_fBeginningOfData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkString_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBeginningOfData) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkString_Rec) , "::" , stringify ! (fBeginningOfData))) ; } test_field_fBeginningOfData () ; } extern "C" { # [link_name = "\u{1}?Make@Rec@SkString@@SA?AV?$sk_sp@URec@SkString@@@@QEBD_K@Z"] pub fn SkString_Rec_Make (text : * const :: std :: os :: raw :: c_char , len : usize) -> sk_sp < SkString_Rec > ; } extern "C" { # [link_name = "\u{1}?ref@Rec@SkString@@QEBAXXZ"] pub fn SkString_Rec_ref (this : * const SkString_Rec) ; } extern "C" { # [link_name = "\u{1}?unref@Rec@SkString@@QEBAXXZ"] pub fn SkString_Rec_unref (this : * const SkString_Rec) ; } extern "C" { # [link_name = "\u{1}?unique@Rec@SkString@@QEBA_NXZ"] pub fn SkString_Rec_unique (this : * const SkString_Rec) -> bool ; } impl SkString_Rec { # [inline] pub unsafe fn Make (text : * const :: std :: os :: raw :: c_char , len : usize) -> sk_sp < SkString_Rec > { SkString_Rec_Make (text , len) } # [inline] pub unsafe fn ref_ (& self) { SkString_Rec_ref (self) } # [inline] pub unsafe fn unref (& self) { SkString_Rec_unref (self) } # [inline] pub unsafe fn unique (& self) -> bool { SkString_Rec_unique (self) } } extern "C" { # [link_name = "\u{1}?gEmptyRec@SkString@@0URec@1@B"] pub static SkString_gEmptyRec : SkString_Rec ; } # [test] fn bindgen_test_layout_SkString () { assert_eq ! (:: core :: mem :: size_of :: < SkString > () , 8usize , concat ! ("Size of: " , stringify ! (SkString))) ; assert_eq ! (:: core :: mem :: align_of :: < SkString > () , 8usize , concat ! ("Alignment of " , stringify ! (SkString))) ; fn test_field_fRec () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkString > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRec) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkString) , "::" , stringify ! (fRec))) ; } test_field_fRec () ; } extern "C" { # [link_name = "\u{1}?equals@SkString@@QEBA_NAEBV1@@Z"] pub fn SkString_equals (this : * const SkString , arg1 : * const SkString) -> bool ; } extern "C" { # [link_name = "\u{1}?equals@SkString@@QEBA_NQEBD@Z"] pub fn SkString_equals1 (this : * const SkString , text : * const :: std :: os :: raw :: c_char) -> bool ; } extern "C" { # [link_name = "\u{1}?equals@SkString@@QEBA_NQEBD_K@Z"] pub fn SkString_equals2 (this : * const SkString , text : * const :: std :: os :: raw :: c_char , len : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?writable_str@SkString@@QEAAPEADXZ"] pub fn SkString_writable_str (this : * mut SkString) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [link_name = "\u{1}?reset@SkString@@QEAAXXZ"] pub fn SkString_reset (this : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?resize@SkString@@QEAAX_K@Z"] pub fn SkString_resize (this : * mut SkString , len : usize) ; } extern "C" { # [link_name = "\u{1}?set@SkString@@QEAAXQEBD@Z"] pub fn SkString_set (this : * mut SkString , text : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?set@SkString@@QEAAXQEBD_K@Z"] pub fn SkString_set1 (this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize) ; } extern "C" { # [link_name = "\u{1}?insert@SkString@@QEAAX_KQEBD@Z"] pub fn SkString_insert (this : * mut SkString , offset : usize , text : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?insert@SkString@@QEAAX_KQEBD0@Z"] pub fn SkString_insert1 (this : * mut SkString , offset : usize , text : * const :: std :: os :: raw :: c_char , len : usize) ; } extern "C" { # [link_name = "\u{1}?insertUnichar@SkString@@QEAAX_KH@Z"] pub fn SkString_insertUnichar (this : * mut SkString , offset : usize , arg1 : SkUnichar) ; } extern "C" { # [link_name = "\u{1}?insertS32@SkString@@QEAAX_KH@Z"] pub fn SkString_insertS32 (this : * mut SkString , offset : usize , value : i32) ; } extern "C" { # [link_name = "\u{1}?insertS64@SkString@@QEAAX_K_JH@Z"] pub fn SkString_insertS64 (this : * mut SkString , offset : usize , value : i64 , minDigits : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?insertU32@SkString@@QEAAX_KI@Z"] pub fn SkString_insertU32 (this : * mut SkString , offset : usize , value : u32) ; } extern "C" { # [link_name = "\u{1}?insertU64@SkString@@QEAAX_K0H@Z"] pub fn SkString_insertU64 (this : * mut SkString , offset : usize , value : u64 , minDigits : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?insertHex@SkString@@QEAAX_KIH@Z"] pub fn SkString_insertHex (this : * mut SkString , offset : usize , value : u32 , minDigits : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?insertScalar@SkString@@QEAAX_KM@Z"] pub fn SkString_insertScalar (this : * mut SkString , offset : usize , arg1 : SkScalar) ; } extern "C" { # [link_name = "\u{1}?printf@SkString@@QEAAXQEBDZZ"] pub fn SkString_printf (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { # [link_name = "\u{1}?printVAList@SkString@@QEAAXQEBDPEAD@Z"] pub fn SkString_printVAList (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) ; } extern "C" { # [link_name = "\u{1}?appendf@SkString@@QEAAXQEBDZZ"] pub fn SkString_appendf (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { # [link_name = "\u{1}?appendVAList@SkString@@QEAAXQEBDPEAD@Z"] pub fn SkString_appendVAList (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) ; } extern "C" { # [link_name = "\u{1}?prependf@SkString@@QEAAXQEBDZZ"] pub fn SkString_prependf (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , ...) ; } extern "C" { # [link_name = "\u{1}?prependVAList@SkString@@QEAAXQEBDPEAD@Z"] pub fn SkString_prependVAList (this : * mut SkString , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) ; } extern "C" { # [link_name = "\u{1}?remove@SkString@@QEAAX_K0@Z"] pub fn SkString_remove (this : * mut SkString , offset : usize , length : usize) ; } extern "C" { # [link_name = "\u{1}?swap@SkString@@QEAAXAEAV1@@Z"] pub fn SkString_swap (this : * mut SkString , other : * mut SkString) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@XZ"] pub fn SkString_SkString (this : * mut SkString) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@_K@Z"] pub fn SkString_SkString1 (this : * mut SkString , len : usize) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@QEBD@Z"] pub fn SkString_SkString2 (this : * mut SkString , text : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@QEBD_K@Z"] pub fn SkString_SkString3 (this : * mut SkString , text : * const :: std :: os :: raw :: c_char , len : usize) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@AEBV0@@Z"] pub fn SkString_SkString4 (this : * mut SkString , arg1 : * const SkString) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@$$QEAV0@@Z"] pub fn SkString_SkString5 (this : * mut SkString , arg1 : * mut SkString) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z"] pub fn SkString_SkString6 (this : * mut SkString , arg1 : * const std_string) ; } extern "C" { # [link_name = "\u{1}??0SkString@@QEAA@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z"] pub fn SkString_SkString7 (this : * mut SkString , arg1 : std_string_view) ; } impl SkString { # [inline] pub unsafe fn equals (& self , arg1 : * const SkString) -> bool { SkString_equals (self , arg1) } # [inline] pub unsafe fn equals1 (& self , text : * const :: std :: os :: raw :: c_char) -> bool { SkString_equals1 (self , text) } # [inline] pub unsafe fn equals2 (& self , text : * const :: std :: os :: raw :: c_char , len : usize) -> bool { SkString_equals2 (self , text , len) } # [inline] pub unsafe fn writable_str (& mut self) -> * mut :: std :: os :: raw :: c_char { SkString_writable_str (self) } # [inline] pub unsafe fn reset (& mut self) { SkString_reset (self) } # [inline] pub unsafe fn resize (& mut self , len : usize) { SkString_resize (self , len) } # [inline] pub unsafe fn set (& mut self , text : * const :: std :: os :: raw :: c_char) { SkString_set (self , text) } # [inline] pub unsafe fn set1 (& mut self , text : * const :: std :: os :: raw :: c_char , len : usize) { SkString_set1 (self , text , len) } # [inline] pub unsafe fn insert (& mut self , offset : usize , text : * const :: std :: os :: raw :: c_char) { SkString_insert (self , offset , text) } # [inline] pub unsafe fn insert1 (& mut self , offset : usize , text : * const :: std :: os :: raw :: c_char , len : usize) { SkString_insert1 (self , offset , text , len) } # [inline] pub unsafe fn insertUnichar (& mut self , offset : usize , arg1 : SkUnichar) { SkString_insertUnichar (self , offset , arg1) } # [inline] pub unsafe fn insertS32 (& mut self , offset : usize , value : i32) { SkString_insertS32 (self , offset , value) } # [inline] pub unsafe fn insertS64 (& mut self , offset : usize , value : i64 , minDigits : :: std :: os :: raw :: c_int) { SkString_insertS64 (self , offset , value , minDigits) } # [inline] pub unsafe fn insertU32 (& mut self , offset : usize , value : u32) { SkString_insertU32 (self , offset , value) } # [inline] pub unsafe fn insertU64 (& mut self , offset : usize , value : u64 , minDigits : :: std :: os :: raw :: c_int) { SkString_insertU64 (self , offset , value , minDigits) } # [inline] pub unsafe fn insertHex (& mut self , offset : usize , value : u32 , minDigits : :: std :: os :: raw :: c_int) { SkString_insertHex (self , offset , value , minDigits) } # [inline] pub unsafe fn insertScalar (& mut self , offset : usize , arg1 : SkScalar) { SkString_insertScalar (self , offset , arg1) } # [inline] pub unsafe fn printVAList (& mut self , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) { SkString_printVAList (self , format , arg1) } # [inline] pub unsafe fn appendVAList (& mut self , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) { SkString_appendVAList (self , format , arg1) } # [inline] pub unsafe fn prependVAList (& mut self , format : * const :: std :: os :: raw :: c_char , arg1 : va_list) { SkString_prependVAList (self , format , arg1) } # [inline] pub unsafe fn remove (& mut self , offset : usize , length : usize) { SkString_remove (self , offset , length) } # [inline] pub unsafe fn swap (& mut self , other : * mut SkString) { SkString_swap (self , other) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (len : usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString1 (__bindgen_tmp . as_mut_ptr () , len) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (text : * const :: std :: os :: raw :: c_char) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString2 (__bindgen_tmp . as_mut_ptr () , text) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (text : * const :: std :: os :: raw :: c_char , len : usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString3 (__bindgen_tmp . as_mut_ptr () , text , len) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new4 (arg1 : * const SkString) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString4 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new5 (arg1 : * mut SkString) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString5 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new6 (arg1 : * const std_string) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString6 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new7 (arg1 : std_string_view) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkString_SkString7 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct TraitObject { pub data : * mut :: core :: ffi :: c_void , pub vtable : * mut :: core :: ffi :: c_void , } # [test] fn bindgen_test_layout_TraitObject () { assert_eq ! (:: core :: mem :: size_of :: < TraitObject > () , 16usize , concat ! ("Size of: " , stringify ! (TraitObject))) ; assert_eq ! (:: core :: mem :: align_of :: < TraitObject > () , 8usize , concat ! ("Alignment of " , stringify ! (TraitObject))) ; fn test_field_data () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < TraitObject > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . data) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (TraitObject) , "::" , stringify ! (data))) ; } test_field_data () ; fn test_field_vtable () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < TraitObject > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . vtable) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (TraitObject) , "::" , stringify ! (vtable))) ; } test_field_vtable () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VecSink < T > { pub fn_trait : TraitObject , pub set_fn : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut T , arg2 : usize , arg3 : TraitObject) > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (C)] pub struct SkStrings { pub strings : [u64 ; 3usize] , } # [test] fn bindgen_test_layout_SkStrings () { assert_eq ! (:: core :: mem :: size_of :: < SkStrings > () , 24usize , concat ! ("Size of: " , stringify ! (SkStrings))) ; assert_eq ! (:: core :: mem :: align_of :: < SkStrings > () , 8usize , concat ! ("Alignment of " , stringify ! (SkStrings))) ; fn test_field_strings () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkStrings > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . strings) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkStrings) , "::" , stringify ! (strings))) ; } test_field_strings () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkIPoint { pub fX : i32 , pub fY : i32 , } # [test] fn bindgen_test_layout_SkIPoint () { assert_eq ! (:: core :: mem :: size_of :: < SkIPoint > () , 8usize , concat ! ("Size of: " , stringify ! (SkIPoint))) ; assert_eq ! (:: core :: mem :: align_of :: < SkIPoint > () , 4usize , concat ! ("Alignment of " , stringify ! (SkIPoint))) ; fn test_field_fX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIPoint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fX) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkIPoint) , "::" , stringify ! (fX))) ; } test_field_fX () ; fn test_field_fY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIPoint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fY) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkIPoint) , "::" , stringify ! (fY))) ; } test_field_fY () ; } pub type SkVector = SkPoint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPoint { pub fX : SkScalar , pub fY : SkScalar , } # [test] fn bindgen_test_layout_SkPoint () { assert_eq ! (:: core :: mem :: size_of :: < SkPoint > () , 8usize , concat ! ("Size of: " , stringify ! (SkPoint))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPoint > () , 4usize , concat ! ("Alignment of " , stringify ! (SkPoint))) ; fn test_field_fX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPoint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fX) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPoint) , "::" , stringify ! (fX))) ; } test_field_fX () ; fn test_field_fY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPoint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fY) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkPoint) , "::" , stringify ! (fY))) ; } test_field_fY () ; } extern "C" { # [link_name = "\u{1}?normalize@SkPoint@@QEAA_NXZ"] pub fn SkPoint_normalize (this : * mut SkPoint) -> bool ; } extern "C" { # [link_name = "\u{1}?setNormalize@SkPoint@@QEAA_NMM@Z"] pub fn SkPoint_setNormalize (this : * mut SkPoint , x : SkScalar , y : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?setLength@SkPoint@@QEAA_NM@Z"] pub fn SkPoint_setLength (this : * mut SkPoint , length : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?setLength@SkPoint@@QEAA_NMMM@Z"] pub fn SkPoint_setLength1 (this : * mut SkPoint , x : SkScalar , y : SkScalar , length : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?scale@SkPoint@@QEBAXMPEAU1@@Z"] pub fn SkPoint_scale (this : * const SkPoint , scale : SkScalar , dst : * mut SkPoint) ; } extern "C" { # [link_name = "\u{1}?Length@SkPoint@@SAMMM@Z"] pub fn SkPoint_Length (x : SkScalar , y : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?Normalize@SkPoint@@SAMPEAU1@@Z"] pub fn SkPoint_Normalize (vec : * mut SkVector) -> SkScalar ; } impl SkPoint { # [inline] pub unsafe fn normalize (& mut self) -> bool { SkPoint_normalize (self) } # [inline] pub unsafe fn setNormalize (& mut self , x : SkScalar , y : SkScalar) -> bool { SkPoint_setNormalize (self , x , y) } # [inline] pub unsafe fn setLength (& mut self , length : SkScalar) -> bool { SkPoint_setLength (self , length) } # [inline] pub unsafe fn setLength1 (& mut self , x : SkScalar , y : SkScalar , length : SkScalar) -> bool { SkPoint_setLength1 (self , x , y , length) } # [inline] pub unsafe fn scale (& self , scale : SkScalar , dst : * mut SkPoint) { SkPoint_scale (self , scale , dst) } # [inline] pub unsafe fn Length (x : SkScalar , y : SkScalar) -> SkScalar { SkPoint_Length (x , y) } # [inline] pub unsafe fn Normalize (vec : * mut SkVector) -> SkScalar { SkPoint_Normalize (vec) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkISize { pub fWidth : i32 , pub fHeight : i32 , } # [test] fn bindgen_test_layout_SkISize () { assert_eq ! (:: core :: mem :: size_of :: < SkISize > () , 8usize , concat ! ("Size of: " , stringify ! (SkISize))) ; assert_eq ! (:: core :: mem :: align_of :: < SkISize > () , 4usize , concat ! ("Alignment of " , stringify ! (SkISize))) ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkISize > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkISize) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkISize > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkISize) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSize { pub fWidth : SkScalar , pub fHeight : SkScalar , } # [test] fn bindgen_test_layout_SkSize () { assert_eq ! (:: core :: mem :: size_of :: < SkSize > () , 8usize , concat ! ("Size of: " , stringify ! (SkSize))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSize > () , 4usize , concat ! ("Alignment of " , stringify ! (SkSize))) ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSize > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkSize) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSize > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkSize) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkIRect { pub fLeft : i32 , pub fTop : i32 , pub fRight : i32 , pub fBottom : i32 , } # [test] fn bindgen_test_layout_SkIRect () { assert_eq ! (:: core :: mem :: size_of :: < SkIRect > () , 16usize , concat ! ("Size of: " , stringify ! (SkIRect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkIRect > () , 4usize , concat ! ("Alignment of " , stringify ! (SkIRect))) ; fn test_field_fLeft () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeft) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkIRect) , "::" , stringify ! (fLeft))) ; } test_field_fLeft () ; fn test_field_fTop () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTop) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkIRect) , "::" , stringify ! (fTop))) ; } test_field_fTop () ; fn test_field_fRight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRight) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkIRect) , "::" , stringify ! (fRight))) ; } test_field_fRight () ; fn test_field_fBottom () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBottom) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkIRect) , "::" , stringify ! (fBottom))) ; } test_field_fBottom () ; } extern "C" { # [link_name = "\u{1}?intersect@SkIRect@@QEAA_NAEBU1@0@Z"] pub fn SkIRect_intersect (this : * mut SkIRect , a : * const SkIRect , b : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?join@SkIRect@@QEAAXAEBU1@@Z"] pub fn SkIRect_join (this : * mut SkIRect , r : * const SkIRect) ; } impl SkIRect { # [inline] pub unsafe fn intersect (& mut self , a : * const SkIRect , b : * const SkIRect) -> bool { SkIRect_intersect (self , a , b) } # [inline] pub unsafe fn join (& mut self , r : * const SkIRect) { SkIRect_join (self , r) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRect { pub fLeft : SkScalar , pub fTop : SkScalar , pub fRight : SkScalar , pub fBottom : SkScalar , } # [test] fn bindgen_test_layout_SkRect () { assert_eq ! (:: core :: mem :: size_of :: < SkRect > () , 16usize , concat ! ("Size of: " , stringify ! (SkRect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRect > () , 4usize , concat ! ("Alignment of " , stringify ! (SkRect))) ; fn test_field_fLeft () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeft) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRect) , "::" , stringify ! (fLeft))) ; } test_field_fLeft () ; fn test_field_fTop () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTop) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkRect) , "::" , stringify ! (fTop))) ; } test_field_fTop () ; fn test_field_fRight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRight) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRect) , "::" , stringify ! (fRight))) ; } test_field_fRight () ; fn test_field_fBottom () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBottom) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkRect) , "::" , stringify ! (fBottom))) ; } test_field_fBottom () ; } extern "C" { # [link_name = "\u{1}?toQuad@SkRect@@QEBAXQEAUSkPoint@@@Z"] pub fn SkRect_toQuad (this : * const SkRect , quad : * mut SkPoint) ; } extern "C" { # [link_name = "\u{1}?setBoundsCheck@SkRect@@QEAA_NQEBUSkPoint@@H@Z"] pub fn SkRect_setBoundsCheck (this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?setBoundsNoCheck@SkRect@@QEAAXQEBUSkPoint@@H@Z"] pub fn SkRect_setBoundsNoCheck (this : * mut SkRect , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?intersect@SkRect@@QEAA_NAEBU1@@Z"] pub fn SkRect_intersect (this : * mut SkRect , r : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?intersect@SkRect@@QEAA_NAEBU1@0@Z"] pub fn SkRect_intersect1 (this : * mut SkRect , a : * const SkRect , b : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?join@SkRect@@QEAAXAEBU1@@Z"] pub fn SkRect_join (this : * mut SkRect , r : * const SkRect) ; } extern "C" { # [link_name = "\u{1}?dump@SkRect@@QEBAX_N@Z"] pub fn SkRect_dump (this : * const SkRect , asHex : bool) ; } impl SkRect { # [inline] pub unsafe fn toQuad (& self , quad : * mut SkPoint) { SkRect_toQuad (self , quad) } # [inline] pub unsafe fn setBoundsCheck (& mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) -> bool { SkRect_setBoundsCheck (self , pts , count) } # [inline] pub unsafe fn setBoundsNoCheck (& mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) { SkRect_setBoundsNoCheck (self , pts , count) } # [inline] pub unsafe fn intersect (& mut self , r : * const SkRect) -> bool { SkRect_intersect (self , r) } # [inline] pub unsafe fn intersect1 (& mut self , a : * const SkRect , b : * const SkRect) -> bool { SkRect_intersect1 (self , a , b) } # [inline] pub unsafe fn join (& mut self , r : * const SkRect) { SkRect_join (self , r) } # [inline] pub unsafe fn dump (& self , asHex : bool) { SkRect_dump (self , asHex) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkApplyPerspectiveClip { No = 0 , Yes = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkMatrix { pub fMat : [SkScalar ; 9usize] , pub fTypeMask : i32 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkMatrix_ScaleToFit { Fill = 0 , Start = 1 , Center = 2 , End = 3 , } pub const SkMatrix_TypeMask_kIdentity_Mask : SkMatrix_TypeMask = 0 ; pub const SkMatrix_TypeMask_kTranslate_Mask : SkMatrix_TypeMask = 1 ; pub const SkMatrix_TypeMask_kScale_Mask : SkMatrix_TypeMask = 2 ; pub const SkMatrix_TypeMask_kAffine_Mask : SkMatrix_TypeMask = 4 ; pub const SkMatrix_TypeMask_kPerspective_Mask : SkMatrix_TypeMask = 8 ; pub type SkMatrix_TypeMask = :: std :: os :: raw :: c_int ; pub type SkMatrix_MapXYProc = :: core :: option :: Option < unsafe extern "C" fn (mat : * const SkMatrix , x : SkScalar , y : SkScalar , result : * mut SkPoint) > ; pub type SkMatrix_MapPtsProc = :: core :: option :: Option < unsafe extern "C" fn (mat : * const SkMatrix , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int) > ; pub const SkMatrix_kMScaleX : :: std :: os :: raw :: c_int = 0 ; pub const SkMatrix_kMSkewX : :: std :: os :: raw :: c_int = 1 ; pub const SkMatrix_kMTransX : :: std :: os :: raw :: c_int = 2 ; pub const SkMatrix_kMSkewY : :: std :: os :: raw :: c_int = 3 ; pub const SkMatrix_kMScaleY : :: std :: os :: raw :: c_int = 4 ; pub const SkMatrix_kMTransY : :: std :: os :: raw :: c_int = 5 ; pub const SkMatrix_kMPersp0 : :: std :: os :: raw :: c_int = 6 ; pub const SkMatrix_kMPersp1 : :: std :: os :: raw :: c_int = 7 ; pub const SkMatrix_kMPersp2 : :: std :: os :: raw :: c_int = 8 ; pub const SkMatrix_kAScaleX : :: std :: os :: raw :: c_int = 0 ; pub const SkMatrix_kASkewY : :: std :: os :: raw :: c_int = 1 ; pub const SkMatrix_kASkewX : :: std :: os :: raw :: c_int = 2 ; pub const SkMatrix_kAScaleY : :: std :: os :: raw :: c_int = 3 ; pub const SkMatrix_kATransX : :: std :: os :: raw :: c_int = 4 ; pub const SkMatrix_kATransY : :: std :: os :: raw :: c_int = 5 ; pub const SkMatrix_kRectStaysRect_Mask : :: std :: os :: raw :: c_int = 16 ; pub const SkMatrix_kOnlyPerspectiveValid_Mask : :: std :: os :: raw :: c_int = 64 ; pub const SkMatrix_kUnknown_Mask : :: std :: os :: raw :: c_int = 128 ; pub const SkMatrix_kORableMasks : :: std :: os :: raw :: c_int = 15 ; pub const SkMatrix_kAllMasks : :: std :: os :: raw :: c_int = 31 ; extern "C" { # [link_name = "\u{1}?gMapXYProcs@SkMatrix@@0QBQ6AXAEBV1@MMPEAUSkPoint@@@ZB"] pub static mut SkMatrix_gMapXYProcs : [SkMatrix_MapXYProc ; 0usize] ; } extern "C" { # [link_name = "\u{1}?gMapPtsProcs@SkMatrix@@0QBQ6AXAEBV1@QEAUSkPoint@@QEBU2@H@ZB"] pub static mut SkMatrix_gMapPtsProcs : [SkMatrix_MapPtsProc ; 0usize] ; } # [test] fn bindgen_test_layout_SkMatrix () { assert_eq ! (:: core :: mem :: size_of :: < SkMatrix > () , 40usize , concat ! ("Size of: " , stringify ! (SkMatrix))) ; assert_eq ! (:: core :: mem :: align_of :: < SkMatrix > () , 4usize , concat ! ("Alignment of " , stringify ! (SkMatrix))) ; fn test_field_fMat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkMatrix > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMat) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkMatrix) , "::" , stringify ! (fMat))) ; } test_field_fMat () ; fn test_field_fTypeMask () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkMatrix > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTypeMask) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (SkMatrix) , "::" , stringify ! (fTypeMask))) ; } test_field_fTypeMask () ; } extern "C" { # [link_name = "\u{1}?isSimilarity@SkMatrix@@QEBA_NM@Z"] pub fn SkMatrix_isSimilarity (this : * const SkMatrix , tol : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?preservesRightAngles@SkMatrix@@QEBA_NM@Z"] pub fn SkMatrix_preservesRightAngles (this : * const SkMatrix , tol : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?set9@SkMatrix@@QEAAAEAV1@QEBM@Z"] pub fn SkMatrix_set9 (this : * mut SkMatrix , buffer : * const SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?reset@SkMatrix@@QEAAAEAV1@XZ"] pub fn SkMatrix_reset (this : * mut SkMatrix) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setTranslate@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_setTranslate (this : * mut SkMatrix , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setScale@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_setScale (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setScale@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_setScale1 (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setRotate@SkMatrix@@QEAAAEAV1@MMM@Z"] pub fn SkMatrix_setRotate (this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setRotate@SkMatrix@@QEAAAEAV1@M@Z"] pub fn SkMatrix_setRotate1 (this : * mut SkMatrix , degrees : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setSinCos@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_setSinCos (this : * mut SkMatrix , sinValue : SkScalar , cosValue : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setSinCos@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_setSinCos1 (this : * mut SkMatrix , sinValue : SkScalar , cosValue : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setRSXform@SkMatrix@@QEAAAEAV1@AEBUSkRSXform@@@Z"] pub fn SkMatrix_setRSXform (this : * mut SkMatrix , rsxForm : * const SkRSXform) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setSkew@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_setSkew (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setSkew@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_setSkew1 (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setConcat@SkMatrix@@QEAAAEAV1@AEBV1@0@Z"] pub fn SkMatrix_setConcat (this : * mut SkMatrix , a : * const SkMatrix , b : * const SkMatrix) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preTranslate@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_preTranslate (this : * mut SkMatrix , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preScale@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_preScale (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preScale@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_preScale1 (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preRotate@SkMatrix@@QEAAAEAV1@MMM@Z"] pub fn SkMatrix_preRotate (this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preRotate@SkMatrix@@QEAAAEAV1@M@Z"] pub fn SkMatrix_preRotate1 (this : * mut SkMatrix , degrees : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preSkew@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_preSkew (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preSkew@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_preSkew1 (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?preConcat@SkMatrix@@QEAAAEAV1@AEBV1@@Z"] pub fn SkMatrix_preConcat (this : * mut SkMatrix , other : * const SkMatrix) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postTranslate@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_postTranslate (this : * mut SkMatrix , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postScale@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_postScale (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postScale@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_postScale1 (this : * mut SkMatrix , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postRotate@SkMatrix@@QEAAAEAV1@MMM@Z"] pub fn SkMatrix_postRotate (this : * mut SkMatrix , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postRotate@SkMatrix@@QEAAAEAV1@M@Z"] pub fn SkMatrix_postRotate1 (this : * mut SkMatrix , degrees : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postSkew@SkMatrix@@QEAAAEAV1@MMMM@Z"] pub fn SkMatrix_postSkew (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postSkew@SkMatrix@@QEAAAEAV1@MM@Z"] pub fn SkMatrix_postSkew1 (this : * mut SkMatrix , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?postConcat@SkMatrix@@QEAAAEAV1@AEBV1@@Z"] pub fn SkMatrix_postConcat (this : * mut SkMatrix , other : * const SkMatrix) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?setRectToRect@SkMatrix@@QEAA_NAEBUSkRect@@0W4ScaleToFit@1@@Z"] pub fn SkMatrix_setRectToRect (this : * mut SkMatrix , src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit) -> bool ; } extern "C" { # [link_name = "\u{1}?setPolyToPoly@SkMatrix@@QEAA_NQEBUSkPoint@@0H@Z"] pub fn SkMatrix_setPolyToPoly (this : * mut SkMatrix , src : * const SkPoint , dst : * const SkPoint , count : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?SetAffineIdentity@SkMatrix@@SAXQEAM@Z"] pub fn SkMatrix_SetAffineIdentity (affine : * mut SkScalar) ; } extern "C" { # [link_name = "\u{1}?asAffine@SkMatrix@@QEBA_NQEAM@Z"] pub fn SkMatrix_asAffine (this : * const SkMatrix , affine : * mut SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?setAffine@SkMatrix@@QEAAAEAV1@QEBM@Z"] pub fn SkMatrix_setAffine (this : * mut SkMatrix , affine : * const SkScalar) -> * mut SkMatrix ; } extern "C" { # [link_name = "\u{1}?mapPoints@SkMatrix@@QEBAXQEAUSkPoint@@QEBU2@H@Z"] pub fn SkMatrix_mapPoints (this : * const SkMatrix , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?mapHomogeneousPoints@SkMatrix@@QEBAXQEAUSkPoint3@@QEBU2@H@Z"] pub fn SkMatrix_mapHomogeneousPoints (this : * const SkMatrix , dst : * mut SkPoint3 , src : * const SkPoint3 , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?mapHomogeneousPoints@SkMatrix@@QEBAXQEAUSkPoint3@@QEBUSkPoint@@H@Z"] pub fn SkMatrix_mapHomogeneousPoints1 (this : * const SkMatrix , dst : * mut SkPoint3 , src : * const SkPoint , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?mapXY@SkMatrix@@QEBAXMMPEAUSkPoint@@@Z"] pub fn SkMatrix_mapXY (this : * const SkMatrix , x : SkScalar , y : SkScalar , result : * mut SkPoint) ; } extern "C" { # [link_name = "\u{1}?mapVectors@SkMatrix@@QEBAXQEAUSkPoint@@QEBU2@H@Z"] pub fn SkMatrix_mapVectors (this : * const SkMatrix , dst : * mut SkVector , src : * const SkVector , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?mapRect@SkMatrix@@QEBA_NPEAUSkRect@@AEBU2@W4SkApplyPerspectiveClip@@@Z"] pub fn SkMatrix_mapRect (this : * const SkMatrix , dst : * mut SkRect , src : * const SkRect , pc : SkApplyPerspectiveClip) -> bool ; } extern "C" { # [link_name = "\u{1}?mapRectScaleTranslate@SkMatrix@@QEBAXPEAUSkRect@@AEBU2@@Z"] pub fn SkMatrix_mapRectScaleTranslate (this : * const SkMatrix , dst : * mut SkRect , src : * const SkRect) ; } extern "C" { # [link_name = "\u{1}?mapRadius@SkMatrix@@QEBAMM@Z"] pub fn SkMatrix_mapRadius (this : * const SkMatrix , radius : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?dump@SkMatrix@@QEBAXXZ"] pub fn SkMatrix_dump (this : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?getMinScale@SkMatrix@@QEBAMXZ"] pub fn SkMatrix_getMinScale (this : * const SkMatrix) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?getMaxScale@SkMatrix@@QEBAMXZ"] pub fn SkMatrix_getMaxScale (this : * const SkMatrix) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?getMinMaxScales@SkMatrix@@QEBA_NQEAM@Z"] pub fn SkMatrix_getMinMaxScales (this : * const SkMatrix , scaleFactors : * mut SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?decomposeScale@SkMatrix@@QEBA_NPEAUSkSize@@PEAV1@@Z"] pub fn SkMatrix_decomposeScale (this : * const SkMatrix , scale : * mut SkSize , remaining : * mut SkMatrix) -> bool ; } extern "C" { # [link_name = "\u{1}?I@SkMatrix@@SAAEBV1@XZ"] pub fn SkMatrix_I () -> * const SkMatrix ; } extern "C" { # [link_name = "\u{1}?InvalidMatrix@SkMatrix@@SAAEBV1@XZ"] pub fn SkMatrix_InvalidMatrix () -> * const SkMatrix ; } impl SkMatrix { # [inline] pub unsafe fn isSimilarity (& self , tol : SkScalar) -> bool { SkMatrix_isSimilarity (self , tol) } # [inline] pub unsafe fn preservesRightAngles (& self , tol : SkScalar) -> bool { SkMatrix_preservesRightAngles (self , tol) } # [inline] pub unsafe fn set9 (& mut self , buffer : * const SkScalar) -> * mut SkMatrix { SkMatrix_set9 (self , buffer) } # [inline] pub unsafe fn reset (& mut self) -> * mut SkMatrix { SkMatrix_reset (self) } # [inline] pub unsafe fn setTranslate (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix { SkMatrix_setTranslate (self , dx , dy) } # [inline] pub unsafe fn setScale (& mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_setScale (self , sx , sy , px , py) } # [inline] pub unsafe fn setScale1 (& mut self , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix { SkMatrix_setScale1 (self , sx , sy) } # [inline] pub unsafe fn setRotate (& mut self , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_setRotate (self , degrees , px , py) } # [inline] pub unsafe fn setRotate1 (& mut self , degrees : SkScalar) -> * mut SkMatrix { SkMatrix_setRotate1 (self , degrees) } # [inline] pub unsafe fn setSinCos (& mut self , sinValue : SkScalar , cosValue : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_setSinCos (self , sinValue , cosValue , px , py) } # [inline] pub unsafe fn setSinCos1 (& mut self , sinValue : SkScalar , cosValue : SkScalar) -> * mut SkMatrix { SkMatrix_setSinCos1 (self , sinValue , cosValue) } # [inline] pub unsafe fn setRSXform (& mut self , rsxForm : * const SkRSXform) -> * mut SkMatrix { SkMatrix_setRSXform (self , rsxForm) } # [inline] pub unsafe fn setSkew (& mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_setSkew (self , kx , ky , px , py) } # [inline] pub unsafe fn setSkew1 (& mut self , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix { SkMatrix_setSkew1 (self , kx , ky) } # [inline] pub unsafe fn setConcat (& mut self , a : * const SkMatrix , b : * const SkMatrix) -> * mut SkMatrix { SkMatrix_setConcat (self , a , b) } # [inline] pub unsafe fn preTranslate (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix { SkMatrix_preTranslate (self , dx , dy) } # [inline] pub unsafe fn preScale (& mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_preScale (self , sx , sy , px , py) } # [inline] pub unsafe fn preScale1 (& mut self , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix { SkMatrix_preScale1 (self , sx , sy) } # [inline] pub unsafe fn preRotate (& mut self , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_preRotate (self , degrees , px , py) } # [inline] pub unsafe fn preRotate1 (& mut self , degrees : SkScalar) -> * mut SkMatrix { SkMatrix_preRotate1 (self , degrees) } # [inline] pub unsafe fn preSkew (& mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_preSkew (self , kx , ky , px , py) } # [inline] pub unsafe fn preSkew1 (& mut self , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix { SkMatrix_preSkew1 (self , kx , ky) } # [inline] pub unsafe fn preConcat (& mut self , other : * const SkMatrix) -> * mut SkMatrix { SkMatrix_preConcat (self , other) } # [inline] pub unsafe fn postTranslate (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkMatrix { SkMatrix_postTranslate (self , dx , dy) } # [inline] pub unsafe fn postScale (& mut self , sx : SkScalar , sy : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_postScale (self , sx , sy , px , py) } # [inline] pub unsafe fn postScale1 (& mut self , sx : SkScalar , sy : SkScalar) -> * mut SkMatrix { SkMatrix_postScale1 (self , sx , sy) } # [inline] pub unsafe fn postRotate (& mut self , degrees : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_postRotate (self , degrees , px , py) } # [inline] pub unsafe fn postRotate1 (& mut self , degrees : SkScalar) -> * mut SkMatrix { SkMatrix_postRotate1 (self , degrees) } # [inline] pub unsafe fn postSkew (& mut self , kx : SkScalar , ky : SkScalar , px : SkScalar , py : SkScalar) -> * mut SkMatrix { SkMatrix_postSkew (self , kx , ky , px , py) } # [inline] pub unsafe fn postSkew1 (& mut self , kx : SkScalar , ky : SkScalar) -> * mut SkMatrix { SkMatrix_postSkew1 (self , kx , ky) } # [inline] pub unsafe fn postConcat (& mut self , other : * const SkMatrix) -> * mut SkMatrix { SkMatrix_postConcat (self , other) } # [inline] pub unsafe fn setRectToRect (& mut self , src : * const SkRect , dst : * const SkRect , stf : SkMatrix_ScaleToFit) -> bool { SkMatrix_setRectToRect (self , src , dst , stf) } # [inline] pub unsafe fn setPolyToPoly (& mut self , src : * const SkPoint , dst : * const SkPoint , count : :: std :: os :: raw :: c_int) -> bool { SkMatrix_setPolyToPoly (self , src , dst , count) } # [inline] pub unsafe fn SetAffineIdentity (affine : * mut SkScalar) { SkMatrix_SetAffineIdentity (affine) } # [inline] pub unsafe fn asAffine (& self , affine : * mut SkScalar) -> bool { SkMatrix_asAffine (self , affine) } # [inline] pub unsafe fn setAffine (& mut self , affine : * const SkScalar) -> * mut SkMatrix { SkMatrix_setAffine (self , affine) } # [inline] pub unsafe fn mapPoints (& self , dst : * mut SkPoint , src : * const SkPoint , count : :: std :: os :: raw :: c_int) { SkMatrix_mapPoints (self , dst , src , count) } # [inline] pub unsafe fn mapHomogeneousPoints (& self , dst : * mut SkPoint3 , src : * const SkPoint3 , count : :: std :: os :: raw :: c_int) { SkMatrix_mapHomogeneousPoints (self , dst , src , count) } # [inline] pub unsafe fn mapHomogeneousPoints1 (& self , dst : * mut SkPoint3 , src : * const SkPoint , count : :: std :: os :: raw :: c_int) { SkMatrix_mapHomogeneousPoints1 (self , dst , src , count) } # [inline] pub unsafe fn mapXY (& self , x : SkScalar , y : SkScalar , result : * mut SkPoint) { SkMatrix_mapXY (self , x , y , result) } # [inline] pub unsafe fn mapVectors (& self , dst : * mut SkVector , src : * const SkVector , count : :: std :: os :: raw :: c_int) { SkMatrix_mapVectors (self , dst , src , count) } # [inline] pub unsafe fn mapRect (& self , dst : * mut SkRect , src : * const SkRect , pc : SkApplyPerspectiveClip) -> bool { SkMatrix_mapRect (self , dst , src , pc) } # [inline] pub unsafe fn mapRectScaleTranslate (& self , dst : * mut SkRect , src : * const SkRect) { SkMatrix_mapRectScaleTranslate (self , dst , src) } # [inline] pub unsafe fn mapRadius (& self , radius : SkScalar) -> SkScalar { SkMatrix_mapRadius (self , radius) } # [inline] pub unsafe fn dump (& self) { SkMatrix_dump (self) } # [inline] pub unsafe fn getMinScale (& self) -> SkScalar { SkMatrix_getMinScale (self) } # [inline] pub unsafe fn getMaxScale (& self) -> SkScalar { SkMatrix_getMaxScale (self) } # [inline] pub unsafe fn getMinMaxScales (& self , scaleFactors : * mut SkScalar) -> bool { SkMatrix_getMinMaxScales (self , scaleFactors) } # [inline] pub unsafe fn decomposeScale (& self , scale : * mut SkSize , remaining : * mut SkMatrix) -> bool { SkMatrix_decomposeScale (self , scale , remaining) } # [inline] pub unsafe fn I () -> * const SkMatrix { SkMatrix_I () } # [inline] pub unsafe fn InvalidMatrix () -> * const SkMatrix { SkMatrix_InvalidMatrix () } } impl SkEncodedOrigin { pub const Default : SkEncodedOrigin = SkEncodedOrigin :: TopLeft ; } impl SkEncodedOrigin { pub const Last : SkEncodedOrigin = SkEncodedOrigin :: LeftBottom ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkEncodedOrigin { TopLeft = 1 , TopRight = 2 , BottomRight = 3 , BottomLeft = 4 , LeftTop = 5 , RightTop = 6 , RightBottom = 7 , LeftBottom = 8 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodecAnimation_DisposalMethod { kKeep = 1 , kRestoreBGColor = 2 , kRestorePrevious = 3 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodecAnimation_Blend { kSrcOver = 0 , kSrc = 1 , } impl SkAlphaType { pub const LastEnum : SkAlphaType = SkAlphaType :: Unpremul ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkAlphaType { Unknown = 0 , Opaque = 1 , Premul = 2 , Unpremul = 3 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkEncodedImageFormat { BMP = 0 , GIF = 1 , ICO = 2 , JPEG = 3 , PNG = 4 , WBMP = 5 , WEBP = 6 , PKM = 7 , KTX = 8 , ASTC = 9 , DNG = 10 , HEIF = 11 , AVIF = 12 , JPEGXL = 13 , } impl SkColorType { pub const kLastEnum_SkColorType : SkColorType = SkColorType :: kR8_unorm_SkColorType ; } impl SkColorType { pub const kN32_SkColorType : SkColorType = SkColorType :: kBGRA_8888_SkColorType ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkColorType { kUnknown_SkColorType = 0 , kAlpha_8_SkColorType = 1 , kRGB_565_SkColorType = 2 , kARGB_4444_SkColorType = 3 , kRGBA_8888_SkColorType = 4 , kRGB_888x_SkColorType = 5 , kBGRA_8888_SkColorType = 6 , kRGBA_1010102_SkColorType = 7 , kBGRA_1010102_SkColorType = 8 , kRGB_101010x_SkColorType = 9 , kBGR_101010x_SkColorType = 10 , kGray_8_SkColorType = 11 , kRGBA_F16Norm_SkColorType = 12 , kRGBA_F16_SkColorType = 13 , kRGBA_F32_SkColorType = 14 , kR8G8_unorm_SkColorType = 15 , kA16_float_SkColorType = 16 , kR16G16_float_SkColorType = 17 , kA16_unorm_SkColorType = 18 , kR16G16_unorm_SkColorType = 19 , kR16G16B16A16_unorm_SkColorType = 20 , kSRGBA_8888_SkColorType = 21 , kR8_unorm_SkColorType = 22 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkReadBuffer { _unused : [u8 ; 0] , } extern "C" { # [link_name = "\u{1}?SkColorTypeBytesPerPixel@@YAHW4SkColorType@@@Z"] pub fn SkColorTypeBytesPerPixel (ct : SkColorType) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?SkColorTypeIsAlwaysOpaque@@YA_NW4SkColorType@@@Z"] pub fn SkColorTypeIsAlwaysOpaque (ct : SkColorType) -> bool ; } extern "C" { # [link_name = "\u{1}?SkColorTypeValidateAlphaType@@YA_NW4SkColorType@@W4SkAlphaType@@PEAW42@@Z"] pub fn SkColorTypeValidateAlphaType (colorType : SkColorType , alphaType : SkAlphaType , canonical : * mut SkAlphaType) -> bool ; } impl SkYUVColorSpace { pub const LastEnum : SkYUVColorSpace = SkYUVColorSpace :: Identity ; } impl SkYUVColorSpace { pub const JPEG : SkYUVColorSpace = SkYUVColorSpace :: JPEG_Full ; } impl SkYUVColorSpace { pub const Rec601 : SkYUVColorSpace = SkYUVColorSpace :: Rec601_Limited ; } impl SkYUVColorSpace { pub const Rec709 : SkYUVColorSpace = SkYUVColorSpace :: Rec709_Limited ; } impl SkYUVColorSpace { pub const BT2020 : SkYUVColorSpace = SkYUVColorSpace :: BT2020_8bit_Limited ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVColorSpace { JPEG_Full = 0 , Rec601_Limited = 1 , Rec709_Full = 2 , Rec709_Limited = 3 , BT2020_8bit_Full = 4 , BT2020_8bit_Limited = 5 , BT2020_10bit_Full = 6 , BT2020_10bit_Limited = 7 , BT2020_12bit_Full = 8 , BT2020_12bit_Limited = 9 , Identity = 10 , } # [repr (C)] # [derive (Debug)] pub struct SkColorInfo { pub fColorSpace : sk_sp < SkColorSpace > , pub fColorType : SkColorType , pub fAlphaType : SkAlphaType , } # [test] fn bindgen_test_layout_SkColorInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkColorInfo > () , 16usize , concat ! ("Size of: " , stringify ! (SkColorInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkColorInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkColorInfo))) ; fn test_field_fColorSpace () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorSpace) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkColorInfo) , "::" , stringify ! (fColorSpace))) ; } test_field_fColorSpace () ; fn test_field_fColorType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorType) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkColorInfo) , "::" , stringify ! (fColorType))) ; } test_field_fColorType () ; fn test_field_fAlphaType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlphaType) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkColorInfo) , "::" , stringify ! (fAlphaType))) ; } test_field_fAlphaType () ; } extern "C" { # [link_name = "\u{1}?colorSpace@SkColorInfo@@QEBAPEAVSkColorSpace@@XZ"] pub fn SkColorInfo_colorSpace (this : * const SkColorInfo) -> * mut SkColorSpace ; } extern "C" { # [link_name = "\u{1}?refColorSpace@SkColorInfo@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorInfo_refColorSpace (this : * const SkColorInfo) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?gammaCloseToSRGB@SkColorInfo@@QEBA_NXZ"] pub fn SkColorInfo_gammaCloseToSRGB (this : * const SkColorInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?makeAlphaType@SkColorInfo@@QEBA?AV1@W4SkAlphaType@@@Z"] pub fn SkColorInfo_makeAlphaType (this : * const SkColorInfo , newAlphaType : SkAlphaType) -> SkColorInfo ; } extern "C" { # [link_name = "\u{1}?makeColorType@SkColorInfo@@QEBA?AV1@W4SkColorType@@@Z"] pub fn SkColorInfo_makeColorType (this : * const SkColorInfo , newColorType : SkColorType) -> SkColorInfo ; } extern "C" { # [link_name = "\u{1}?makeColorSpace@SkColorInfo@@QEBA?AV1@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkColorInfo_makeColorSpace (this : * const SkColorInfo , cs : sk_sp < SkColorSpace >) -> SkColorInfo ; } extern "C" { # [link_name = "\u{1}?bytesPerPixel@SkColorInfo@@QEBAHXZ"] pub fn SkColorInfo_bytesPerPixel (this : * const SkColorInfo) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?shiftPerPixel@SkColorInfo@@QEBAHXZ"] pub fn SkColorInfo_shiftPerPixel (this : * const SkColorInfo) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}??0SkColorInfo@@QEAA@XZ"] pub fn SkColorInfo_SkColorInfo (this : * mut SkColorInfo) ; } extern "C" { # [link_name = "\u{1}??0SkColorInfo@@QEAA@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkColorInfo_SkColorInfo1 (this : * mut SkColorInfo , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) ; } extern "C" { # [link_name = "\u{1}??0SkColorInfo@@QEAA@AEBV0@@Z"] pub fn SkColorInfo_SkColorInfo2 (this : * mut SkColorInfo , arg1 : * const SkColorInfo) ; } extern "C" { # [link_name = "\u{1}??0SkColorInfo@@QEAA@$$QEAV0@@Z"] pub fn SkColorInfo_SkColorInfo3 (this : * mut SkColorInfo , arg1 : * mut SkColorInfo) ; } impl SkColorInfo { # [inline] pub unsafe fn colorSpace (& self) -> * mut SkColorSpace { SkColorInfo_colorSpace (self) } # [inline] pub unsafe fn refColorSpace (& self) -> sk_sp < SkColorSpace > { SkColorInfo_refColorSpace (self) } # [inline] pub unsafe fn gammaCloseToSRGB (& self) -> bool { SkColorInfo_gammaCloseToSRGB (self) } # [inline] pub unsafe fn makeAlphaType (& self , newAlphaType : SkAlphaType) -> SkColorInfo { SkColorInfo_makeAlphaType (self , newAlphaType) } # [inline] pub unsafe fn makeColorType (& self , newColorType : SkColorType) -> SkColorInfo { SkColorInfo_makeColorType (self , newColorType) } # [inline] pub unsafe fn makeColorSpace (& self , cs : sk_sp < SkColorSpace >) -> SkColorInfo { SkColorInfo_makeColorSpace (self , cs) } # [inline] pub unsafe fn bytesPerPixel (& self) -> :: std :: os :: raw :: c_int { SkColorInfo_bytesPerPixel (self) } # [inline] pub unsafe fn shiftPerPixel (& self) -> :: std :: os :: raw :: c_int { SkColorInfo_shiftPerPixel (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkColorInfo_SkColorInfo (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkColorInfo_SkColorInfo1 (__bindgen_tmp . as_mut_ptr () , ct , at , cs) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (arg1 : * const SkColorInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkColorInfo_SkColorInfo2 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (arg1 : * mut SkColorInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkColorInfo_SkColorInfo3 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkImageInfo { pub fColorInfo : SkColorInfo , pub fDimensions : SkISize , } # [test] fn bindgen_test_layout_SkImageInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkImageInfo > () , 24usize , concat ! ("Size of: " , stringify ! (SkImageInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImageInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkImageInfo))) ; fn test_field_fColorInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkImageInfo) , "::" , stringify ! (fColorInfo))) ; } test_field_fColorInfo () ; fn test_field_fDimensions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDimensions) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkImageInfo) , "::" , stringify ! (fDimensions))) ; } test_field_fDimensions () ; } extern "C" { # [link_name = "\u{1}?Make@SkImageInfo@@SA?AU1@HHW4SkColorType@@W4SkAlphaType@@@Z"] pub fn SkImageInfo_Make (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?Make@SkImageInfo@@SA?AU1@HHW4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_Make1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?Make@SkImageInfo@@SA?AU1@USkISize@@W4SkColorType@@W4SkAlphaType@@@Z"] pub fn SkImageInfo_Make2 (dimensions : SkISize , ct : SkColorType , at : SkAlphaType) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?Make@SkImageInfo@@SA?AU1@USkISize@@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_Make3 (dimensions : SkISize , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@@Z"] pub fn SkImageInfo_MakeN32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_MakeN321 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeS32@SkImageInfo@@SA?AU1@HHW4SkAlphaType@@@Z"] pub fn SkImageInfo_MakeS32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32Premul@SkImageInfo@@SA?AU1@HH@Z"] pub fn SkImageInfo_MakeN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32Premul@SkImageInfo@@SA?AU1@HHV?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_MakeN32Premul1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32Premul@SkImageInfo@@SA?AU1@USkISize@@@Z"] pub fn SkImageInfo_MakeN32Premul2 (dimensions : SkISize) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeN32Premul@SkImageInfo@@SA?AU1@USkISize@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_MakeN32Premul3 (dimensions : SkISize , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeA8@SkImageInfo@@SA?AU1@HH@Z"] pub fn SkImageInfo_MakeA8 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeA8@SkImageInfo@@SA?AU1@USkISize@@@Z"] pub fn SkImageInfo_MakeA81 (dimensions : SkISize) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?MakeUnknown@SkImageInfo@@SA?AU1@HH@Z"] pub fn SkImageInfo_MakeUnknown (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?colorSpace@SkImageInfo@@QEBAPEAVSkColorSpace@@XZ"] pub fn SkImageInfo_colorSpace (this : * const SkImageInfo) -> * mut SkColorSpace ; } extern "C" { # [link_name = "\u{1}?refColorSpace@SkImageInfo@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkImageInfo_refColorSpace (this : * const SkImageInfo) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?makeColorSpace@SkImageInfo@@QEBA?AU1@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImageInfo_makeColorSpace (this : * const SkImageInfo , cs : sk_sp < SkColorSpace >) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?computeOffset@SkImageInfo@@QEBA_KHH_K@Z"] pub fn SkImageInfo_computeOffset (this : * const SkImageInfo , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , rowBytes : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?computeByteSize@SkImageInfo@@QEBA_K_K@Z"] pub fn SkImageInfo_computeByteSize (this : * const SkImageInfo , rowBytes : usize) -> usize ; } impl SkImageInfo { # [inline] pub unsafe fn Make (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType) -> SkImageInfo { SkImageInfo_Make (width , height , ct , at) } # [inline] pub unsafe fn Make1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_Make1 (width , height , ct , at , cs) } # [inline] pub unsafe fn Make2 (dimensions : SkISize , ct : SkColorType , at : SkAlphaType) -> SkImageInfo { SkImageInfo_Make2 (dimensions , ct , at) } # [inline] pub unsafe fn Make3 (dimensions : SkISize , ct : SkColorType , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_Make3 (dimensions , ct , at , cs) } # [inline] pub unsafe fn MakeN32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType) -> SkImageInfo { SkImageInfo_MakeN32 (width , height , at) } # [inline] pub unsafe fn MakeN321 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_MakeN321 (width , height , at , cs) } # [inline] pub unsafe fn MakeS32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType) -> SkImageInfo { SkImageInfo_MakeS32 (width , height , at) } # [inline] pub unsafe fn MakeN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo { SkImageInfo_MakeN32Premul (width , height) } # [inline] pub unsafe fn MakeN32Premul1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_MakeN32Premul1 (width , height , cs) } # [inline] pub unsafe fn MakeN32Premul2 (dimensions : SkISize) -> SkImageInfo { SkImageInfo_MakeN32Premul2 (dimensions) } # [inline] pub unsafe fn MakeN32Premul3 (dimensions : SkISize , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_MakeN32Premul3 (dimensions , cs) } # [inline] pub unsafe fn MakeA8 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo { SkImageInfo_MakeA8 (width , height) } # [inline] pub unsafe fn MakeA81 (dimensions : SkISize) -> SkImageInfo { SkImageInfo_MakeA81 (dimensions) } # [inline] pub unsafe fn MakeUnknown (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkImageInfo { SkImageInfo_MakeUnknown (width , height) } # [inline] pub unsafe fn colorSpace (& self) -> * mut SkColorSpace { SkImageInfo_colorSpace (self) } # [inline] pub unsafe fn refColorSpace (& self) -> sk_sp < SkColorSpace > { SkImageInfo_refColorSpace (self) } # [inline] pub unsafe fn makeColorSpace (& self , cs : sk_sp < SkColorSpace >) -> SkImageInfo { SkImageInfo_makeColorSpace (self , cs) } # [inline] pub unsafe fn computeOffset (& self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , rowBytes : usize) -> usize { SkImageInfo_computeOffset (self , x , y , rowBytes) } # [inline] pub unsafe fn computeByteSize (& self , rowBytes : usize) -> usize { SkImageInfo_computeByteSize (self , rowBytes) } } pub type SkColor = u32 ; pub const SK_ColorTRANSPARENT : SkColor = 0 ; pub const SK_ColorBLACK : SkColor = 4278190080 ; pub const SK_ColorDKGRAY : SkColor = 4282664004 ; pub const SK_ColorGRAY : SkColor = 4287137928 ; pub const SK_ColorLTGRAY : SkColor = 4291611852 ; pub const SK_ColorWHITE : SkColor = 4294967295 ; pub const SK_ColorRED : SkColor = 4294901760 ; pub const SK_ColorGREEN : SkColor = 4278255360 ; pub const SK_ColorBLUE : SkColor = 4278190335 ; pub const SK_ColorYELLOW : SkColor = 4294967040 ; pub const SK_ColorCYAN : SkColor = 4278255615 ; pub const SK_ColorMAGENTA : SkColor = 4294902015 ; extern "C" { # [link_name = "\u{1}?SkRGBToHSV@@YAXIIIQEAM@Z"] pub fn SkRGBToHSV (red : U8CPU , green : U8CPU , blue : U8CPU , hsv : * mut SkScalar) ; } extern "C" { # [link_name = "\u{1}?SkHSVToColor@@YAIIQEBM@Z"] pub fn SkHSVToColor (alpha : U8CPU , hsv : * const SkScalar) -> SkColor ; } pub type SkPMColor = u32 ; extern "C" { # [link_name = "\u{1}?SkPreMultiplyARGB@@YAIIIII@Z"] pub fn SkPreMultiplyARGB (a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU) -> SkPMColor ; } extern "C" { # [link_name = "\u{1}?SkPreMultiplyColor@@YAII@Z"] pub fn SkPreMultiplyColor (c : SkColor) -> SkPMColor ; } impl SkColorChannel { pub const LastEnum : SkColorChannel = SkColorChannel :: A ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkColorChannel { R = 0 , G = 1 , B = 2 , A = 3 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkColorChannelFlag { kRed_SkColorChannelFlag = 1 , kGreen_SkColorChannelFlag = 2 , kBlue_SkColorChannelFlag = 4 , kAlpha_SkColorChannelFlag = 8 , kGray_SkColorChannelFlag = 16 , kGrayAlpha_SkColorChannelFlags = 24 , kRG_SkColorChannelFlags = 3 , kRGB_SkColorChannelFlags = 7 , kRGBA_SkColorChannelFlags = 15 , } extern "C" { # [link_name = "\u{1}FromColor"] pub fn SkRGBA4f_FromColor (color : SkColor) -> u8 ; } extern "C" { # [link_name = "\u{1}toSkColor"] pub fn SkRGBA4f_toSkColor (this : * const u8) -> SkColor ; } extern "C" { # [link_name = "\u{1}FromPMColor"] pub fn SkRGBA4f_FromPMColor (arg1 : SkPMColor) -> u8 ; } extern "C" { # [link_name = "\u{1}toBytes_RGBA"] pub fn SkRGBA4f_toBytes_RGBA (this : * const u8) -> u32 ; } extern "C" { # [link_name = "\u{1}FromBytes_RGBA"] pub fn SkRGBA4f_FromBytes_RGBA (color : u32) -> u8 ; } pub type SkColor4f = [u32 ; 4usize] ; impl SkFilterMode { pub const Last : SkFilterMode = SkFilterMode :: Linear ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFilterMode { Nearest = 0 , Linear = 1 , } impl SkMipmapMode { pub const Last : SkMipmapMode = SkMipmapMode :: Linear ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkMipmapMode { None = 0 , Nearest = 1 , Linear = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCubicResampler { pub B : f32 , pub C : f32 , } # [test] fn bindgen_test_layout_SkCubicResampler () { assert_eq ! (:: core :: mem :: size_of :: < SkCubicResampler > () , 8usize , concat ! ("Size of: " , stringify ! (SkCubicResampler))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCubicResampler > () , 4usize , concat ! ("Alignment of " , stringify ! (SkCubicResampler))) ; fn test_field_B () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCubicResampler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . B) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCubicResampler) , "::" , stringify ! (B))) ; } test_field_B () ; fn test_field_C () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCubicResampler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . C) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkCubicResampler) , "::" , stringify ! (C))) ; } test_field_C () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSamplingOptions { pub maxAniso : :: std :: os :: raw :: c_int , pub useCubic : bool , pub cubic : SkCubicResampler , pub filter : SkFilterMode , pub mipmap : SkMipmapMode , } # [test] fn bindgen_test_layout_SkSamplingOptions () { assert_eq ! (:: core :: mem :: size_of :: < SkSamplingOptions > () , 24usize , concat ! ("Size of: " , stringify ! (SkSamplingOptions))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSamplingOptions > () , 4usize , concat ! ("Alignment of " , stringify ! (SkSamplingOptions))) ; fn test_field_maxAniso () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSamplingOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . maxAniso) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkSamplingOptions) , "::" , stringify ! (maxAniso))) ; } test_field_maxAniso () ; fn test_field_useCubic () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSamplingOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . useCubic) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkSamplingOptions) , "::" , stringify ! (useCubic))) ; } test_field_useCubic () ; fn test_field_cubic () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSamplingOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . cubic) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkSamplingOptions) , "::" , stringify ! (cubic))) ; } test_field_cubic () ; fn test_field_filter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSamplingOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . filter) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkSamplingOptions) , "::" , stringify ! (filter))) ; } test_field_filter () ; fn test_field_mipmap () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSamplingOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . mipmap) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkSamplingOptions) , "::" , stringify ! (mipmap))) ; } test_field_mipmap () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkMask { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct SkPixmap { pub fPixels : * const :: core :: ffi :: c_void , pub fRowBytes : usize , pub fInfo : SkImageInfo , } # [test] fn bindgen_test_layout_SkPixmap () { assert_eq ! (:: core :: mem :: size_of :: < SkPixmap > () , 40usize , concat ! ("Size of: " , stringify ! (SkPixmap))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPixmap > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPixmap))) ; fn test_field_fPixels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPixmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPixels) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPixmap) , "::" , stringify ! (fPixels))) ; } test_field_fPixels () ; fn test_field_fRowBytes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPixmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRowBytes) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPixmap) , "::" , stringify ! (fRowBytes))) ; } test_field_fRowBytes () ; fn test_field_fInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPixmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInfo) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPixmap) , "::" , stringify ! (fInfo))) ; } test_field_fInfo () ; } extern "C" { # [link_name = "\u{1}?reset@SkPixmap@@QEAAXXZ"] pub fn SkPixmap_reset (this : * mut SkPixmap) ; } extern "C" { # [link_name = "\u{1}?reset@SkPixmap@@QEAAXAEBUSkImageInfo@@PEBX_K@Z"] pub fn SkPixmap_reset1 (this : * mut SkPixmap , info : * const SkImageInfo , addr : * const :: core :: ffi :: c_void , rowBytes : usize) ; } extern "C" { # [link_name = "\u{1}?setColorSpace@SkPixmap@@QEAAXV?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkPixmap_setColorSpace (this : * mut SkPixmap , colorSpace : sk_sp < SkColorSpace >) ; } extern "C" { # [link_name = "\u{1}?reset@SkPixmap@@QEAA_NAEBUSkMask@@@Z"] pub fn SkPixmap_reset2 (this : * mut SkPixmap , mask : * const SkMask) -> bool ; } extern "C" { # [link_name = "\u{1}?extractSubset@SkPixmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"] pub fn SkPixmap_extractSubset (this : * const SkPixmap , subset : * mut SkPixmap , area : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?colorSpace@SkPixmap@@QEBAPEAVSkColorSpace@@XZ"] pub fn SkPixmap_colorSpace (this : * const SkPixmap) -> * mut SkColorSpace ; } extern "C" { # [link_name = "\u{1}?refColorSpace@SkPixmap@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkPixmap_refColorSpace (this : * const SkPixmap) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?computeIsOpaque@SkPixmap@@QEBA_NXZ"] pub fn SkPixmap_computeIsOpaque (this : * const SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?getColor@SkPixmap@@QEBAIHH@Z"] pub fn SkPixmap_getColor (this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> SkColor ; } extern "C" { # [link_name = "\u{1}?getColor4f@SkPixmap@@QEBA?AU?$SkRGBA4f@$02@@HH@Z"] pub fn SkPixmap_getColor4f (this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> SkColor4f ; } extern "C" { # [link_name = "\u{1}?getAlphaf@SkPixmap@@QEBAMHH@Z"] pub fn SkPixmap_getAlphaf (this : * const SkPixmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> f32 ; } extern "C" { # [link_name = "\u{1}?readPixels@SkPixmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"] pub fn SkPixmap_readPixels (this : * const SkPixmap , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?scalePixels@SkPixmap@@QEBA_NAEBV1@AEBUSkSamplingOptions@@@Z"] pub fn SkPixmap_scalePixels (this : * const SkPixmap , dst : * const SkPixmap , arg1 : * const SkSamplingOptions) -> bool ; } extern "C" { # [link_name = "\u{1}?erase@SkPixmap@@QEBA_NIAEBUSkIRect@@@Z"] pub fn SkPixmap_erase (this : * const SkPixmap , color : SkColor , subset : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?erase@SkPixmap@@QEBA_NAEBU?$SkRGBA4f@$02@@PEAVSkColorSpace@@PEBUSkIRect@@@Z"] pub fn SkPixmap_erase1 (this : * const SkPixmap , color : * const SkColor4f , cs : * mut SkColorSpace , subset : * const SkIRect) -> bool ; } impl SkPixmap { # [inline] pub unsafe fn reset (& mut self) { SkPixmap_reset (self) } # [inline] pub unsafe fn reset1 (& mut self , info : * const SkImageInfo , addr : * const :: core :: ffi :: c_void , rowBytes : usize) { SkPixmap_reset1 (self , info , addr , rowBytes) } # [inline] pub unsafe fn setColorSpace (& mut self , colorSpace : sk_sp < SkColorSpace >) { SkPixmap_setColorSpace (self , colorSpace) } # [inline] pub unsafe fn reset2 (& mut self , mask : * const SkMask) -> bool { SkPixmap_reset2 (self , mask) } # [inline] pub unsafe fn extractSubset (& self , subset : * mut SkPixmap , area : * const SkIRect) -> bool { SkPixmap_extractSubset (self , subset , area) } # [inline] pub unsafe fn colorSpace (& self) -> * mut SkColorSpace { SkPixmap_colorSpace (self) } # [inline] pub unsafe fn refColorSpace (& self) -> sk_sp < SkColorSpace > { SkPixmap_refColorSpace (self) } # [inline] pub unsafe fn computeIsOpaque (& self) -> bool { SkPixmap_computeIsOpaque (self) } # [inline] pub unsafe fn getColor (& self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> SkColor { SkPixmap_getColor (self , x , y) } # [inline] pub unsafe fn getColor4f (& self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> SkColor4f { SkPixmap_getColor4f (self , x , y) } # [inline] pub unsafe fn getAlphaf (& self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> f32 { SkPixmap_getAlphaf (self , x , y) } # [inline] pub unsafe fn readPixels (& self , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkPixmap_readPixels (self , dstInfo , dstPixels , dstRowBytes , srcX , srcY) } # [inline] pub unsafe fn scalePixels (& self , dst : * const SkPixmap , arg1 : * const SkSamplingOptions) -> bool { SkPixmap_scalePixels (self , dst , arg1) } # [inline] pub unsafe fn erase (& self , color : SkColor , subset : * const SkIRect) -> bool { SkPixmap_erase (self , color , subset) } # [inline] pub unsafe fn erase1 (& self , color : * const SkColor4f , cs : * mut SkColorSpace , subset : * const SkIRect) -> bool { SkPixmap_erase1 (self , color , cs , subset) } } # [repr (C)] # [derive (Debug)] pub struct SkData { pub _base : SkNVRefCnt , pub fReleaseProc : SkData_ReleaseProc , pub fReleaseProcContext : * mut :: core :: ffi :: c_void , pub fPtr : * const :: core :: ffi :: c_void , pub fSize : usize , } pub type SkData_ReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (ptr : * const :: core :: ffi :: c_void , context : * mut :: core :: ffi :: c_void) > ; pub type SkData_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkData () { assert_eq ! (:: core :: mem :: size_of :: < SkData > () , 40usize , concat ! ("Size of: " , stringify ! (SkData))) ; assert_eq ! (:: core :: mem :: align_of :: < SkData > () , 8usize , concat ! ("Alignment of " , stringify ! (SkData))) ; fn test_field_fReleaseProc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReleaseProc) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkData) , "::" , stringify ! (fReleaseProc))) ; } test_field_fReleaseProc () ; fn test_field_fReleaseProcContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReleaseProcContext) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkData) , "::" , stringify ! (fReleaseProcContext))) ; } test_field_fReleaseProcContext () ; fn test_field_fPtr () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPtr) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkData) , "::" , stringify ! (fPtr))) ; } test_field_fPtr () ; fn test_field_fSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSize) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkData) , "::" , stringify ! (fSize))) ; } test_field_fSize () ; } extern "C" { # [link_name = "\u{1}?copyRange@SkData@@QEBA_K_K0PEAX@Z"] pub fn SkData_copyRange (this : * const SkData , offset : usize , length : usize , buffer : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?equals@SkData@@QEBA_NPEBV1@@Z"] pub fn SkData_equals (this : * const SkData , other : * const SkData) -> bool ; } extern "C" { # [link_name = "\u{1}?MakeWithCopy@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"] pub fn SkData_MakeWithCopy (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeUninitialized@SkData@@SA?AV?$sk_sp@VSkData@@@@_K@Z"] pub fn SkData_MakeUninitialized (length : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeZeroInitialized@SkData@@SA?AV?$sk_sp@VSkData@@@@_K@Z"] pub fn SkData_MakeZeroInitialized (length : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeWithCString@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"] pub fn SkData_MakeWithCString (cstr : * const :: std :: os :: raw :: c_char) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeWithProc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_KP6AX0PEAX@Z2@Z"] pub fn SkData_MakeWithProc (ptr : * const :: core :: ffi :: c_void , length : usize , proc_ : SkData_ReleaseProc , ctx : * mut :: core :: ffi :: c_void) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeFromMalloc@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBX_K@Z"] pub fn SkData_MakeFromMalloc (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeFromFileName@SkData@@SA?AV?$sk_sp@VSkData@@@@QEBD@Z"] pub fn SkData_MakeFromFileName (path : * const :: std :: os :: raw :: c_char) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeFromFILE@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAU_iobuf@@@Z"] pub fn SkData_MakeFromFILE (f : * mut FILE) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeFromFD@SkData@@SA?AV?$sk_sp@VSkData@@@@H@Z"] pub fn SkData_MakeFromFD (fd : :: std :: os :: raw :: c_int) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeFromStream@SkData@@SA?AV?$sk_sp@VSkData@@@@PEAVSkStream@@_K@Z"] pub fn SkData_MakeFromStream (arg1 : * mut SkStream , size : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeSubset@SkData@@SA?AV?$sk_sp@VSkData@@@@PEBV1@_K1@Z"] pub fn SkData_MakeSubset (src : * const SkData , offset : usize , length : usize) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeEmpty@SkData@@SA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkData_MakeEmpty () -> sk_sp < SkData > ; } impl SkData { # [inline] pub unsafe fn copyRange (& self , offset : usize , length : usize , buffer : * mut :: core :: ffi :: c_void) -> usize { SkData_copyRange (self , offset , length , buffer) } # [inline] pub unsafe fn equals (& self , other : * const SkData) -> bool { SkData_equals (self , other) } # [inline] pub unsafe fn MakeWithCopy (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkData > { SkData_MakeWithCopy (data , length) } # [inline] pub unsafe fn MakeUninitialized (length : usize) -> sk_sp < SkData > { SkData_MakeUninitialized (length) } # [inline] pub unsafe fn MakeZeroInitialized (length : usize) -> sk_sp < SkData > { SkData_MakeZeroInitialized (length) } # [inline] pub unsafe fn MakeWithCString (cstr : * const :: std :: os :: raw :: c_char) -> sk_sp < SkData > { SkData_MakeWithCString (cstr) } # [inline] pub unsafe fn MakeWithProc (ptr : * const :: core :: ffi :: c_void , length : usize , proc_ : SkData_ReleaseProc , ctx : * mut :: core :: ffi :: c_void) -> sk_sp < SkData > { SkData_MakeWithProc (ptr , length , proc_ , ctx) } # [inline] pub unsafe fn MakeFromMalloc (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkData > { SkData_MakeFromMalloc (data , length) } # [inline] pub unsafe fn MakeFromFileName (path : * const :: std :: os :: raw :: c_char) -> sk_sp < SkData > { SkData_MakeFromFileName (path) } # [inline] pub unsafe fn MakeFromFILE (f : * mut FILE) -> sk_sp < SkData > { SkData_MakeFromFILE (f) } # [inline] pub unsafe fn MakeFromFD (fd : :: std :: os :: raw :: c_int) -> sk_sp < SkData > { SkData_MakeFromFD (fd) } # [inline] pub unsafe fn MakeFromStream (arg1 : * mut SkStream , size : usize) -> sk_sp < SkData > { SkData_MakeFromStream (arg1 , size) } # [inline] pub unsafe fn MakeSubset (src : * const SkData , offset : usize , length : usize) -> sk_sp < SkData > { SkData_MakeSubset (src , offset , length) } # [inline] pub unsafe fn MakeEmpty () -> sk_sp < SkData > { SkData_MakeEmpty () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkYUVAInfo { pub fDimensions : SkISize , pub fPlaneConfig : SkYUVAInfo_PlaneConfig , pub fSubsampling : SkYUVAInfo_Subsampling , pub fYUVColorSpace : SkYUVColorSpace , pub fOrigin : SkEncodedOrigin , pub fSitingX : SkYUVAInfo_Siting , pub fSitingY : SkYUVAInfo_Siting , } impl SkYUVAInfo_YUVAChannels { pub const kLast : SkYUVAInfo_YUVAChannels = SkYUVAInfo_YUVAChannels :: kA ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVAInfo_YUVAChannels { kY = 0 , kU = 1 , kV = 2 , kA = 3 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkYUVAInfo_YUVALocation { _unused : [u8 ; 0] , } pub type SkYUVAInfo_YUVALocations = u8 ; impl SkYUVAInfo_PlaneConfig { pub const Last : SkYUVAInfo_PlaneConfig = SkYUVAInfo_PlaneConfig :: UYVA ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVAInfo_PlaneConfig { Unknown = 0 , Y_U_V = 1 , Y_V_U = 2 , Y_UV = 3 , Y_VU = 4 , YUV = 5 , UYV = 6 , Y_U_V_A = 7 , Y_V_U_A = 8 , Y_UV_A = 9 , Y_VU_A = 10 , YUVA = 11 , UYVA = 12 , } impl SkYUVAInfo_Subsampling { pub const kLast : SkYUVAInfo_Subsampling = SkYUVAInfo_Subsampling :: k410 ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVAInfo_Subsampling { kUnknown = 0 , k444 = 1 , k422 = 2 , k420 = 3 , k440 = 4 , k411 = 5 , k410 = 6 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVAInfo_Siting { Centered = 0 , } pub const SkYUVAInfo_kYUVAChannelCount : :: std :: os :: raw :: c_int = 4 ; pub const SkYUVAInfo_kMaxPlanes : :: std :: os :: raw :: c_int = 4 ; # [test] fn bindgen_test_layout_SkYUVAInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkYUVAInfo > () , 32usize , concat ! ("Size of: " , stringify ! (SkYUVAInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkYUVAInfo > () , 4usize , concat ! ("Alignment of " , stringify ! (SkYUVAInfo))) ; fn test_field_fDimensions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDimensions) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fDimensions))) ; } test_field_fDimensions () ; fn test_field_fPlaneConfig () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPlaneConfig) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fPlaneConfig))) ; } test_field_fPlaneConfig () ; fn test_field_fSubsampling () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubsampling) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fSubsampling))) ; } test_field_fSubsampling () ; fn test_field_fYUVColorSpace () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYUVColorSpace) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fYUVColorSpace))) ; } test_field_fYUVColorSpace () ; fn test_field_fOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOrigin) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fOrigin))) ; } test_field_fOrigin () ; fn test_field_fSitingX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSitingX) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fSitingX))) ; } test_field_fSitingX () ; fn test_field_fSitingY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSitingY) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkYUVAInfo) , "::" , stringify ! (fSitingY))) ; } test_field_fSitingY () ; } extern "C" { # [link_name = "\u{1}?SubsamplingFactors@SkYUVAInfo@@SA?AV?$tuple@HH@std@@W4Subsampling@1@@Z"] pub fn SkYUVAInfo_SubsamplingFactors (arg1 : SkYUVAInfo_Subsampling) -> [u32 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?PlaneSubsamplingFactors@SkYUVAInfo@@SA?AV?$tuple@HH@std@@W4PlaneConfig@1@W4Subsampling@1@H@Z"] pub fn SkYUVAInfo_PlaneSubsamplingFactors (arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , planeIdx : :: std :: os :: raw :: c_int) -> [u32 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?PlaneDimensions@SkYUVAInfo@@SAHUSkISize@@W4PlaneConfig@1@W4Subsampling@1@W4SkEncodedOrigin@@QEAU2@@Z"] pub fn SkYUVAInfo_PlaneDimensions (imageDimensions : SkISize , arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , arg3 : SkEncodedOrigin , planeDimensions : * mut SkISize) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?GetYUVALocations@SkYUVAInfo@@SA?AV?$array@UYUVALocation@SkYUVAInfo@@$03@std@@W4PlaneConfig@1@PEBI@Z"] pub fn SkYUVAInfo_GetYUVALocations (arg1 : SkYUVAInfo_PlaneConfig , planeChannelFlags : * const u32) -> SkYUVAInfo_YUVALocations ; } extern "C" { # [link_name = "\u{1}?HasAlpha@SkYUVAInfo@@SA_NW4PlaneConfig@1@@Z"] pub fn SkYUVAInfo_HasAlpha (arg1 : SkYUVAInfo_PlaneConfig) -> bool ; } extern "C" { # [link_name = "\u{1}?computeTotalBytes@SkYUVAInfo@@QEBA_KQEB_KQEA_K@Z"] pub fn SkYUVAInfo_computeTotalBytes (this : * const SkYUVAInfo , rowBytes : * const usize , planeSizes : * mut usize) -> usize ; } extern "C" { # [link_name = "\u{1}?toYUVALocations@SkYUVAInfo@@QEBA?AV?$array@UYUVALocation@SkYUVAInfo@@$03@std@@PEBI@Z"] pub fn SkYUVAInfo_toYUVALocations (this : * const SkYUVAInfo , channelFlags : * const u32) -> SkYUVAInfo_YUVALocations ; } extern "C" { # [link_name = "\u{1}?makeSubsampling@SkYUVAInfo@@QEBA?AV1@W4Subsampling@1@@Z"] pub fn SkYUVAInfo_makeSubsampling (this : * const SkYUVAInfo , arg1 : SkYUVAInfo_Subsampling) -> SkYUVAInfo ; } extern "C" { # [link_name = "\u{1}?makeDimensions@SkYUVAInfo@@QEBA?AV1@USkISize@@@Z"] pub fn SkYUVAInfo_makeDimensions (this : * const SkYUVAInfo , arg1 : SkISize) -> SkYUVAInfo ; } extern "C" { # [link_name = "\u{1}??0SkYUVAInfo@@QEAA@USkISize@@W4PlaneConfig@0@W4Subsampling@0@W4SkYUVColorSpace@@W4SkEncodedOrigin@@W4Siting@0@5@Z"] pub fn SkYUVAInfo_SkYUVAInfo (this : * mut SkYUVAInfo , dimensions : SkISize , arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , arg3 : SkYUVColorSpace , origin : SkEncodedOrigin , sitingX : SkYUVAInfo_Siting , sitingY : SkYUVAInfo_Siting) ; } impl SkYUVAInfo { # [inline] pub unsafe fn SubsamplingFactors (arg1 : SkYUVAInfo_Subsampling) -> [u32 ; 2usize] { SkYUVAInfo_SubsamplingFactors (arg1) } # [inline] pub unsafe fn PlaneSubsamplingFactors (arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , planeIdx : :: std :: os :: raw :: c_int) -> [u32 ; 2usize] { SkYUVAInfo_PlaneSubsamplingFactors (arg1 , arg2 , planeIdx) } # [inline] pub unsafe fn PlaneDimensions (imageDimensions : SkISize , arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , arg3 : SkEncodedOrigin , planeDimensions : * mut SkISize) -> :: std :: os :: raw :: c_int { SkYUVAInfo_PlaneDimensions (imageDimensions , arg1 , arg2 , arg3 , planeDimensions) } # [inline] pub unsafe fn GetYUVALocations (arg1 : SkYUVAInfo_PlaneConfig , planeChannelFlags : * const u32) -> SkYUVAInfo_YUVALocations { SkYUVAInfo_GetYUVALocations (arg1 , planeChannelFlags) } # [inline] pub unsafe fn HasAlpha (arg1 : SkYUVAInfo_PlaneConfig) -> bool { SkYUVAInfo_HasAlpha (arg1) } # [inline] pub unsafe fn computeTotalBytes (& self , rowBytes : * const usize , planeSizes : * mut usize) -> usize { SkYUVAInfo_computeTotalBytes (self , rowBytes , planeSizes) } # [inline] pub unsafe fn toYUVALocations (& self , channelFlags : * const u32) -> SkYUVAInfo_YUVALocations { SkYUVAInfo_toYUVALocations (self , channelFlags) } # [inline] pub unsafe fn makeSubsampling (& self , arg1 : SkYUVAInfo_Subsampling) -> SkYUVAInfo { SkYUVAInfo_makeSubsampling (self , arg1) } # [inline] pub unsafe fn makeDimensions (& self , arg1 : SkISize) -> SkYUVAInfo { SkYUVAInfo_makeDimensions (self , arg1) } # [inline] pub unsafe fn new (dimensions : SkISize , arg1 : SkYUVAInfo_PlaneConfig , arg2 : SkYUVAInfo_Subsampling , arg3 : SkYUVColorSpace , origin : SkEncodedOrigin , sitingX : SkYUVAInfo_Siting , sitingY : SkYUVAInfo_Siting) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkYUVAInfo_SkYUVAInfo (__bindgen_tmp . as_mut_ptr () , dimensions , arg1 , arg2 , arg3 , origin , sitingX , sitingY) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct SkYUVAPixmapInfo { pub fYUVAInfo : SkYUVAInfo , pub fPlaneInfos : [u64 ; 12usize] , pub fRowBytes : [u64 ; 4usize] , pub fDataType : SkYUVAPixmapInfo_DataType , } pub use self :: SkYUVAInfo_PlaneConfig as SkYUVAPixmapInfo_PlaneConfig ; pub use self :: SkYUVAInfo_Subsampling as SkYUVAPixmapInfo_Subsampling ; impl SkYUVAPixmapInfo_DataType { pub const Last : SkYUVAPixmapInfo_DataType = SkYUVAPixmapInfo_DataType :: Unorm10_Unorm2 ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkYUVAPixmapInfo_DataType { Unorm8 = 0 , Unorm16 = 1 , Float16 = 2 , Unorm10_Unorm2 = 3 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkYUVAPixmapInfo_SupportedDataTypes { pub fDataTypeSupport : u32 , } # [test] fn bindgen_test_layout_SkYUVAPixmapInfo_SupportedDataTypes () { assert_eq ! (:: core :: mem :: size_of :: < SkYUVAPixmapInfo_SupportedDataTypes > () , 4usize , concat ! ("Size of: " , stringify ! (SkYUVAPixmapInfo_SupportedDataTypes))) ; assert_eq ! (:: core :: mem :: align_of :: < SkYUVAPixmapInfo_SupportedDataTypes > () , 4usize , concat ! ("Alignment of " , stringify ! (SkYUVAPixmapInfo_SupportedDataTypes))) ; fn test_field_fDataTypeSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmapInfo_SupportedDataTypes > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDataTypeSupport) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmapInfo_SupportedDataTypes) , "::" , stringify ! (fDataTypeSupport))) ; } test_field_fDataTypeSupport () ; } extern "C" { # [link_name = "\u{1}?enableDataType@SupportedDataTypes@SkYUVAPixmapInfo@@QEAAXW4DataType@2@H@Z"] pub fn SkYUVAPixmapInfo_SupportedDataTypes_enableDataType (this : * mut SkYUVAPixmapInfo_SupportedDataTypes , arg1 : SkYUVAPixmapInfo_DataType , numChannels : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}??0SupportedDataTypes@SkYUVAPixmapInfo@@QEAA@AEBVGrImageContext@@@Z"] pub fn SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes (this : * mut SkYUVAPixmapInfo_SupportedDataTypes , arg1 : * const GrImageContext) ; } impl SkYUVAPixmapInfo_SupportedDataTypes { # [inline] pub unsafe fn enableDataType (& mut self , arg1 : SkYUVAPixmapInfo_DataType , numChannels : :: std :: os :: raw :: c_int) { SkYUVAPixmapInfo_SupportedDataTypes_enableDataType (self , arg1 , numChannels) } # [inline] pub unsafe fn new (arg1 : * const GrImageContext) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkYUVAPixmapInfo_SupportedDataTypes_SupportedDataTypes (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } pub const SkYUVAPixmapInfo_kMaxPlanes : :: std :: os :: raw :: c_int = 4 ; pub const SkYUVAPixmapInfo_kDataTypeCnt : :: std :: os :: raw :: c_int = 4 ; # [test] fn bindgen_test_layout_SkYUVAPixmapInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkYUVAPixmapInfo > () , 168usize , concat ! ("Size of: " , stringify ! (SkYUVAPixmapInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkYUVAPixmapInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkYUVAPixmapInfo))) ; fn test_field_fYUVAInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmapInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYUVAInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmapInfo) , "::" , stringify ! (fYUVAInfo))) ; } test_field_fYUVAInfo () ; fn test_field_fPlaneInfos () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmapInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPlaneInfos) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmapInfo) , "::" , stringify ! (fPlaneInfos))) ; } test_field_fPlaneInfos () ; fn test_field_fRowBytes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmapInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRowBytes) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmapInfo) , "::" , stringify ! (fRowBytes))) ; } test_field_fRowBytes () ; fn test_field_fDataType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmapInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDataType) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmapInfo) , "::" , stringify ! (fDataType))) ; } test_field_fDataType () ; } extern "C" { # [link_name = "\u{1}?NumChannelsAndDataType@SkYUVAPixmapInfo@@SA?AV?$tuple@HW4DataType@SkYUVAPixmapInfo@@@std@@W4SkColorType@@@Z"] pub fn SkYUVAPixmapInfo_NumChannelsAndDataType (arg1 : SkColorType) -> [u32 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?computeTotalBytes@SkYUVAPixmapInfo@@QEBA_KQEA_K@Z"] pub fn SkYUVAPixmapInfo_computeTotalBytes (this : * const SkYUVAPixmapInfo , planeSizes : * mut usize) -> usize ; } extern "C" { # [link_name = "\u{1}?initPixmapsFromSingleAllocation@SkYUVAPixmapInfo@@QEBA_NPEAXQEAVSkPixmap@@@Z"] pub fn SkYUVAPixmapInfo_initPixmapsFromSingleAllocation (this : * const SkYUVAPixmapInfo , memory : * mut :: core :: ffi :: c_void , pixmaps : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?isSupported@SkYUVAPixmapInfo@@QEBA_NAEBVSupportedDataTypes@1@@Z"] pub fn SkYUVAPixmapInfo_isSupported (this : * const SkYUVAPixmapInfo , arg1 : * const SkYUVAPixmapInfo_SupportedDataTypes) -> bool ; } extern "C" { # [link_name = "\u{1}??0SkYUVAPixmapInfo@@QEAA@AEBVSkYUVAInfo@@QEBW4SkColorType@@QEB_K@Z"] pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo (this : * mut SkYUVAPixmapInfo , arg1 : * const SkYUVAInfo , arg2 : * const SkColorType , rowBytes : * const usize) ; } extern "C" { # [link_name = "\u{1}??0SkYUVAPixmapInfo@@QEAA@AEBVSkYUVAInfo@@W4DataType@0@QEB_K@Z"] pub fn SkYUVAPixmapInfo_SkYUVAPixmapInfo1 (this : * mut SkYUVAPixmapInfo , arg1 : * const SkYUVAInfo , arg2 : SkYUVAPixmapInfo_DataType , rowBytes : * const usize) ; } impl SkYUVAPixmapInfo { # [inline] pub unsafe fn NumChannelsAndDataType (arg1 : SkColorType) -> [u32 ; 2usize] { SkYUVAPixmapInfo_NumChannelsAndDataType (arg1) } # [inline] pub unsafe fn computeTotalBytes (& self , planeSizes : * mut usize) -> usize { SkYUVAPixmapInfo_computeTotalBytes (self , planeSizes) } # [inline] pub unsafe fn initPixmapsFromSingleAllocation (& self , memory : * mut :: core :: ffi :: c_void , pixmaps : * mut SkPixmap) -> bool { SkYUVAPixmapInfo_initPixmapsFromSingleAllocation (self , memory , pixmaps) } # [inline] pub unsafe fn isSupported (& self , arg1 : * const SkYUVAPixmapInfo_SupportedDataTypes) -> bool { SkYUVAPixmapInfo_isSupported (self , arg1) } # [inline] pub unsafe fn new (arg1 : * const SkYUVAInfo , arg2 : * const SkColorType , rowBytes : * const usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkYUVAPixmapInfo_SkYUVAPixmapInfo (__bindgen_tmp . as_mut_ptr () , arg1 , arg2 , rowBytes) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (arg1 : * const SkYUVAInfo , arg2 : SkYUVAPixmapInfo_DataType , rowBytes : * const usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkYUVAPixmapInfo_SkYUVAPixmapInfo1 (__bindgen_tmp . as_mut_ptr () , arg1 , arg2 , rowBytes) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct SkYUVAPixmaps { pub fPlanes : [u64 ; 20usize] , pub fData : sk_sp < SkData > , pub fYUVAInfo : SkYUVAInfo , pub fDataType : SkYUVAPixmaps_DataType , } pub use self :: SkYUVAPixmapInfo_DataType as SkYUVAPixmaps_DataType ; pub const SkYUVAPixmaps_kMaxPlanes : :: std :: os :: raw :: c_int = 4 ; # [test] fn bindgen_test_layout_SkYUVAPixmaps () { assert_eq ! (:: core :: mem :: size_of :: < SkYUVAPixmaps > () , 208usize , concat ! ("Size of: " , stringify ! (SkYUVAPixmaps))) ; assert_eq ! (:: core :: mem :: align_of :: < SkYUVAPixmaps > () , 8usize , concat ! ("Alignment of " , stringify ! (SkYUVAPixmaps))) ; fn test_field_fPlanes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmaps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPlanes) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmaps) , "::" , stringify ! (fPlanes))) ; } test_field_fPlanes () ; fn test_field_fData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmaps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fData) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmaps) , "::" , stringify ! (fData))) ; } test_field_fData () ; fn test_field_fYUVAInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmaps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYUVAInfo) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmaps) , "::" , stringify ! (fYUVAInfo))) ; } test_field_fYUVAInfo () ; fn test_field_fDataType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkYUVAPixmaps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDataType) as usize - ptr as usize } , 200usize , concat ! ("Offset of field: " , stringify ! (SkYUVAPixmaps) , "::" , stringify ! (fDataType))) ; } test_field_fDataType () ; } extern "C" { # [link_name = "\u{1}?RecommendedRGBAColorType@SkYUVAPixmaps@@SA?AW4SkColorType@@W4DataType@SkYUVAPixmapInfo@@@Z"] pub fn SkYUVAPixmaps_RecommendedRGBAColorType (arg1 : SkYUVAPixmaps_DataType) -> SkColorType ; } extern "C" { # [link_name = "\u{1}?Allocate@SkYUVAPixmaps@@SA?AV1@AEBVSkYUVAPixmapInfo@@@Z"] pub fn SkYUVAPixmaps_Allocate (yuvaPixmapInfo : * const SkYUVAPixmapInfo) -> SkYUVAPixmaps ; } extern "C" { # [link_name = "\u{1}?FromData@SkYUVAPixmaps@@SA?AV1@AEBVSkYUVAPixmapInfo@@V?$sk_sp@VSkData@@@@@Z"] pub fn SkYUVAPixmaps_FromData (arg1 : * const SkYUVAPixmapInfo , arg2 : sk_sp < SkData >) -> SkYUVAPixmaps ; } extern "C" { # [link_name = "\u{1}?MakeCopy@SkYUVAPixmaps@@SA?AV1@AEBV1@@Z"] pub fn SkYUVAPixmaps_MakeCopy (src : * const SkYUVAPixmaps) -> SkYUVAPixmaps ; } extern "C" { # [link_name = "\u{1}?FromExternalMemory@SkYUVAPixmaps@@SA?AV1@AEBVSkYUVAPixmapInfo@@PEAX@Z"] pub fn SkYUVAPixmaps_FromExternalMemory (arg1 : * const SkYUVAPixmapInfo , memory : * mut :: core :: ffi :: c_void) -> SkYUVAPixmaps ; } extern "C" { # [link_name = "\u{1}?FromExternalPixmaps@SkYUVAPixmaps@@SA?AV1@AEBVSkYUVAInfo@@QEBVSkPixmap@@@Z"] pub fn SkYUVAPixmaps_FromExternalPixmaps (arg1 : * const SkYUVAInfo , arg2 : * const SkPixmap) -> SkYUVAPixmaps ; } extern "C" { # [link_name = "\u{1}?pixmapsInfo@SkYUVAPixmaps@@QEBA?AVSkYUVAPixmapInfo@@XZ"] pub fn SkYUVAPixmaps_pixmapsInfo (this : * const SkYUVAPixmaps) -> SkYUVAPixmapInfo ; } extern "C" { # [link_name = "\u{1}?toYUVALocations@SkYUVAPixmaps@@QEBA?AV?$array@UYUVALocation@SkYUVAInfo@@$03@std@@XZ"] pub fn SkYUVAPixmaps_toYUVALocations (this : * const SkYUVAPixmaps) -> SkYUVAInfo_YUVALocations ; } impl SkYUVAPixmaps { # [inline] pub unsafe fn RecommendedRGBAColorType (arg1 : SkYUVAPixmaps_DataType) -> SkColorType { SkYUVAPixmaps_RecommendedRGBAColorType (arg1) } # [inline] pub unsafe fn Allocate (yuvaPixmapInfo : * const SkYUVAPixmapInfo) -> SkYUVAPixmaps { SkYUVAPixmaps_Allocate (yuvaPixmapInfo) } # [inline] pub unsafe fn FromData (arg1 : * const SkYUVAPixmapInfo , arg2 : sk_sp < SkData >) -> SkYUVAPixmaps { SkYUVAPixmaps_FromData (arg1 , arg2) } # [inline] pub unsafe fn MakeCopy (src : * const SkYUVAPixmaps) -> SkYUVAPixmaps { SkYUVAPixmaps_MakeCopy (src) } # [inline] pub unsafe fn FromExternalMemory (arg1 : * const SkYUVAPixmapInfo , memory : * mut :: core :: ffi :: c_void) -> SkYUVAPixmaps { SkYUVAPixmaps_FromExternalMemory (arg1 , memory) } # [inline] pub unsafe fn FromExternalPixmaps (arg1 : * const SkYUVAInfo , arg2 : * const SkPixmap) -> SkYUVAPixmaps { SkYUVAPixmaps_FromExternalPixmaps (arg1 , arg2) } # [inline] pub unsafe fn pixmapsInfo (& self) -> SkYUVAPixmapInfo { SkYUVAPixmaps_pixmapsInfo (self) } # [inline] pub unsafe fn toYUVALocations (& self) -> SkYUVAInfo_YUVALocations { SkYUVAPixmaps_toYUVALocations (self) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkOnce { pub fState : u8 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkOnce_State { NotStarted = 0 , Claimed = 1 , Done = 2 , } # [test] fn bindgen_test_layout_SkOnce () { assert_eq ! (:: core :: mem :: size_of :: < SkOnce > () , 1usize , concat ! ("Size of: " , stringify ! (SkOnce))) ; assert_eq ! (:: core :: mem :: align_of :: < SkOnce > () , 1usize , concat ! ("Alignment of " , stringify ! (SkOnce))) ; fn test_field_fState () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkOnce > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fState) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkOnce) , "::" , stringify ! (fState))) ; } test_field_fState () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skcms_Matrix3x3 { pub vals : [[f32 ; 3usize] ; 3usize] , } # [test] fn bindgen_test_layout_skcms_Matrix3x3 () { assert_eq ! (:: core :: mem :: size_of :: < skcms_Matrix3x3 > () , 36usize , concat ! ("Size of: " , stringify ! (skcms_Matrix3x3))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_Matrix3x3 > () , 4usize , concat ! ("Alignment of " , stringify ! (skcms_Matrix3x3))) ; fn test_field_vals () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Matrix3x3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . vals) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_Matrix3x3) , "::" , stringify ! (vals))) ; } test_field_vals () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skcms_Matrix3x4 { pub vals : [[f32 ; 4usize] ; 3usize] , } # [test] fn bindgen_test_layout_skcms_Matrix3x4 () { assert_eq ! (:: core :: mem :: size_of :: < skcms_Matrix3x4 > () , 48usize , concat ! ("Size of: " , stringify ! (skcms_Matrix3x4))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_Matrix3x4 > () , 4usize , concat ! ("Alignment of " , stringify ! (skcms_Matrix3x4))) ; fn test_field_vals () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Matrix3x4 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . vals) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_Matrix3x4) , "::" , stringify ! (vals))) ; } test_field_vals () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skcms_TransferFunction { pub g : f32 , pub a : f32 , pub b : f32 , pub c : f32 , pub d : f32 , pub e : f32 , pub f : f32 , } # [test] fn bindgen_test_layout_skcms_TransferFunction () { assert_eq ! (:: core :: mem :: size_of :: < skcms_TransferFunction > () , 28usize , concat ! ("Size of: " , stringify ! (skcms_TransferFunction))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_TransferFunction > () , 4usize , concat ! ("Alignment of " , stringify ! (skcms_TransferFunction))) ; fn test_field_g () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . g) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (g))) ; } test_field_g () ; fn test_field_a () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . a) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (a))) ; } test_field_a () ; fn test_field_b () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . b) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (b))) ; } test_field_b () ; fn test_field_c () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . c) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (c))) ; } test_field_c () ; fn test_field_d () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . d) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (d))) ; } test_field_d () ; fn test_field_e () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . e) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (e))) ; } test_field_e () ; fn test_field_f () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_TransferFunction > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . f) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skcms_TransferFunction) , "::" , stringify ! (f))) ; } test_field_f () ; } # [repr (C)] # [derive (Copy , Clone)] pub union skcms_Curve { pub __bindgen_anon_1 : skcms_Curve__bindgen_ty_1 , pub __bindgen_anon_2 : skcms_Curve__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skcms_Curve__bindgen_ty_1 { pub alias_of_table_entries : u32 , pub parametric : skcms_TransferFunction , } # [test] fn bindgen_test_layout_skcms_Curve__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < skcms_Curve__bindgen_ty_1 > () , 32usize , concat ! ("Size of: " , stringify ! (skcms_Curve__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_Curve__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (skcms_Curve__bindgen_ty_1))) ; fn test_field_alias_of_table_entries () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Curve__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . alias_of_table_entries) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_Curve__bindgen_ty_1) , "::" , stringify ! (alias_of_table_entries))) ; } test_field_alias_of_table_entries () ; fn test_field_parametric () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Curve__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . parametric) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skcms_Curve__bindgen_ty_1) , "::" , stringify ! (parametric))) ; } test_field_parametric () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skcms_Curve__bindgen_ty_2 { pub table_entries : u32 , pub table_8 : * const u8 , pub table_16 : * const u8 , } # [test] fn bindgen_test_layout_skcms_Curve__bindgen_ty_2 () { assert_eq ! (:: core :: mem :: size_of :: < skcms_Curve__bindgen_ty_2 > () , 24usize , concat ! ("Size of: " , stringify ! (skcms_Curve__bindgen_ty_2))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_Curve__bindgen_ty_2 > () , 8usize , concat ! ("Alignment of " , stringify ! (skcms_Curve__bindgen_ty_2))) ; fn test_field_table_entries () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Curve__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . table_entries) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_Curve__bindgen_ty_2) , "::" , stringify ! (table_entries))) ; } test_field_table_entries () ; fn test_field_table_8 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Curve__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . table_8) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skcms_Curve__bindgen_ty_2) , "::" , stringify ! (table_8))) ; } test_field_table_8 () ; fn test_field_table_16 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_Curve__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . table_16) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skcms_Curve__bindgen_ty_2) , "::" , stringify ! (table_16))) ; } test_field_table_16 () ; } # [test] fn bindgen_test_layout_skcms_Curve () { assert_eq ! (:: core :: mem :: size_of :: < skcms_Curve > () , 32usize , concat ! ("Size of: " , stringify ! (skcms_Curve))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_Curve > () , 8usize , concat ! ("Alignment of " , stringify ! (skcms_Curve))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct skcms_A2B { pub input_channels : u32 , pub input_curves : [skcms_Curve ; 4usize] , pub grid_points : [u8 ; 4usize] , pub grid_8 : * const u8 , pub grid_16 : * const u8 , pub matrix_channels : u32 , pub matrix_curves : [skcms_Curve ; 3usize] , pub matrix : skcms_Matrix3x4 , pub output_channels : u32 , pub output_curves : [skcms_Curve ; 3usize] , } # [test] fn bindgen_test_layout_skcms_A2B () { assert_eq ! (:: core :: mem :: size_of :: < skcms_A2B > () , 416usize , concat ! ("Size of: " , stringify ! (skcms_A2B))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_A2B > () , 8usize , concat ! ("Alignment of " , stringify ! (skcms_A2B))) ; fn test_field_input_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . input_channels) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (input_channels))) ; } test_field_input_channels () ; fn test_field_input_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . input_curves) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (input_curves))) ; } test_field_input_curves () ; fn test_field_grid_points () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_points) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (grid_points))) ; } test_field_grid_points () ; fn test_field_grid_8 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_8) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (grid_8))) ; } test_field_grid_8 () ; fn test_field_grid_16 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_16) as usize - ptr as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (grid_16))) ; } test_field_grid_16 () ; fn test_field_matrix_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix_channels) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (matrix_channels))) ; } test_field_matrix_channels () ; fn test_field_matrix_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix_curves) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (matrix_curves))) ; } test_field_matrix_curves () ; fn test_field_matrix () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix) as usize - ptr as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (matrix))) ; } test_field_matrix () ; fn test_field_output_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . output_channels) as usize - ptr as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (output_channels))) ; } test_field_output_channels () ; fn test_field_output_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_A2B > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . output_curves) as usize - ptr as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (skcms_A2B) , "::" , stringify ! (output_curves))) ; } test_field_output_curves () ; } # [repr (C)] # [derive (Copy , Clone)] pub struct skcms_B2A { pub input_channels : u32 , pub input_curves : [skcms_Curve ; 3usize] , pub matrix_channels : u32 , pub matrix : skcms_Matrix3x4 , pub matrix_curves : [skcms_Curve ; 3usize] , pub output_channels : u32 , pub grid_points : [u8 ; 4usize] , pub grid_8 : * const u8 , pub grid_16 : * const u8 , pub output_curves : [skcms_Curve ; 4usize] , } # [test] fn bindgen_test_layout_skcms_B2A () { assert_eq ! (:: core :: mem :: size_of :: < skcms_B2A > () , 408usize , concat ! ("Size of: " , stringify ! (skcms_B2A))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_B2A > () , 8usize , concat ! ("Alignment of " , stringify ! (skcms_B2A))) ; fn test_field_input_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . input_channels) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (input_channels))) ; } test_field_input_channels () ; fn test_field_input_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . input_curves) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (input_curves))) ; } test_field_input_curves () ; fn test_field_matrix_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix_channels) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (matrix_channels))) ; } test_field_matrix_channels () ; fn test_field_matrix () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix) as usize - ptr as usize } , 108usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (matrix))) ; } test_field_matrix () ; fn test_field_matrix_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . matrix_curves) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (matrix_curves))) ; } test_field_matrix_curves () ; fn test_field_output_channels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . output_channels) as usize - ptr as usize } , 256usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (output_channels))) ; } test_field_output_channels () ; fn test_field_grid_points () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_points) as usize - ptr as usize } , 260usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (grid_points))) ; } test_field_grid_points () ; fn test_field_grid_8 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_8) as usize - ptr as usize } , 264usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (grid_8))) ; } test_field_grid_8 () ; fn test_field_grid_16 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . grid_16) as usize - ptr as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (grid_16))) ; } test_field_grid_16 () ; fn test_field_output_curves () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_B2A > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . output_curves) as usize - ptr as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (skcms_B2A) , "::" , stringify ! (output_curves))) ; } test_field_output_curves () ; } # [repr (C)] # [derive (Copy , Clone)] pub struct skcms_ICCProfile { pub buffer : * const u8 , pub size : u32 , pub data_color_space : u32 , pub pcs : u32 , pub tag_count : u32 , pub has_trc : bool , pub trc : [skcms_Curve ; 3usize] , pub has_toXYZD50 : bool , pub toXYZD50 : skcms_Matrix3x3 , pub has_A2B : bool , pub A2B : skcms_A2B , pub has_B2A : bool , pub B2A : skcms_B2A , } # [test] fn bindgen_test_layout_skcms_ICCProfile () { assert_eq ! (:: core :: mem :: size_of :: < skcms_ICCProfile > () , 1008usize , concat ! ("Size of: " , stringify ! (skcms_ICCProfile))) ; assert_eq ! (:: core :: mem :: align_of :: < skcms_ICCProfile > () , 8usize , concat ! ("Alignment of " , stringify ! (skcms_ICCProfile))) ; fn test_field_buffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . buffer) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (buffer))) ; } test_field_buffer () ; fn test_field_size () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . size) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (size))) ; } test_field_size () ; fn test_field_data_color_space () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . data_color_space) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (data_color_space))) ; } test_field_data_color_space () ; fn test_field_pcs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . pcs) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (pcs))) ; } test_field_pcs () ; fn test_field_tag_count () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . tag_count) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (tag_count))) ; } test_field_tag_count () ; fn test_field_has_trc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . has_trc) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (has_trc))) ; } test_field_has_trc () ; fn test_field_trc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . trc) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (trc))) ; } test_field_trc () ; fn test_field_has_toXYZD50 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . has_toXYZD50) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (has_toXYZD50))) ; } test_field_has_toXYZD50 () ; fn test_field_toXYZD50 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . toXYZD50) as usize - ptr as usize } , 132usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (toXYZD50))) ; } test_field_toXYZD50 () ; fn test_field_has_A2B () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . has_A2B) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (has_A2B))) ; } test_field_has_A2B () ; fn test_field_A2B () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . A2B) as usize - ptr as usize } , 176usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (A2B))) ; } test_field_A2B () ; fn test_field_has_B2A () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . has_B2A) as usize - ptr as usize } , 592usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (has_B2A))) ; } test_field_has_B2A () ; fn test_field_B2A () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skcms_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . B2A) as usize - ptr as usize } , 600usize , concat ! ("Offset of field: " , stringify ! (skcms_ICCProfile) , "::" , stringify ! (B2A))) ; } test_field_B2A () ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skcms_PixelFormat { skcms_PixelFormat_A_8 = 0 , skcms_PixelFormat_A_8_ = 1 , skcms_PixelFormat_G_8 = 2 , skcms_PixelFormat_G_8_ = 3 , skcms_PixelFormat_RGBA_8888_Palette8 = 4 , skcms_PixelFormat_BGRA_8888_Palette8 = 5 , skcms_PixelFormat_RGB_565 = 6 , skcms_PixelFormat_BGR_565 = 7 , skcms_PixelFormat_ABGR_4444 = 8 , skcms_PixelFormat_ARGB_4444 = 9 , skcms_PixelFormat_RGB_888 = 10 , skcms_PixelFormat_BGR_888 = 11 , skcms_PixelFormat_RGBA_8888 = 12 , skcms_PixelFormat_BGRA_8888 = 13 , skcms_PixelFormat_RGBA_8888_sRGB = 14 , skcms_PixelFormat_BGRA_8888_sRGB = 15 , skcms_PixelFormat_RGBA_1010102 = 16 , skcms_PixelFormat_BGRA_1010102 = 17 , skcms_PixelFormat_RGB_161616LE = 18 , skcms_PixelFormat_BGR_161616LE = 19 , skcms_PixelFormat_RGBA_16161616LE = 20 , skcms_PixelFormat_BGRA_16161616LE = 21 , skcms_PixelFormat_RGB_161616BE = 22 , skcms_PixelFormat_BGR_161616BE = 23 , skcms_PixelFormat_RGBA_16161616BE = 24 , skcms_PixelFormat_BGRA_16161616BE = 25 , skcms_PixelFormat_RGB_hhh_Norm = 26 , skcms_PixelFormat_BGR_hhh_Norm = 27 , skcms_PixelFormat_RGBA_hhhh_Norm = 28 , skcms_PixelFormat_BGRA_hhhh_Norm = 29 , skcms_PixelFormat_RGB_hhh = 30 , skcms_PixelFormat_BGR_hhh = 31 , skcms_PixelFormat_RGBA_hhhh = 32 , skcms_PixelFormat_BGRA_hhhh = 33 , skcms_PixelFormat_RGB_fff = 34 , skcms_PixelFormat_BGR_fff = 35 , skcms_PixelFormat_RGBA_ffff = 36 , skcms_PixelFormat_BGRA_ffff = 37 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skcms_AlphaFormat { skcms_AlphaFormat_Opaque = 0 , skcms_AlphaFormat_Unpremul = 1 , skcms_AlphaFormat_PremulAsEncoded = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkColorSpacePrimaries { pub fRX : f32 , pub fRY : f32 , pub fGX : f32 , pub fGY : f32 , pub fBX : f32 , pub fBY : f32 , pub fWX : f32 , pub fWY : f32 , } # [test] fn bindgen_test_layout_SkColorSpacePrimaries () { assert_eq ! (:: core :: mem :: size_of :: < SkColorSpacePrimaries > () , 32usize , concat ! ("Size of: " , stringify ! (SkColorSpacePrimaries))) ; assert_eq ! (:: core :: mem :: align_of :: < SkColorSpacePrimaries > () , 4usize , concat ! ("Alignment of " , stringify ! (SkColorSpacePrimaries))) ; fn test_field_fRX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRX) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fRX))) ; } test_field_fRX () ; fn test_field_fRY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRY) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fRY))) ; } test_field_fRY () ; fn test_field_fGX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGX) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fGX))) ; } test_field_fGX () ; fn test_field_fGY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGY) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fGY))) ; } test_field_fGY () ; fn test_field_fBX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBX) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fBX))) ; } test_field_fBX () ; fn test_field_fBY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBY) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fBY))) ; } test_field_fBY () ; fn test_field_fWX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWX) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fWX))) ; } test_field_fWX () ; fn test_field_fWY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpacePrimaries > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWY) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkColorSpacePrimaries) , "::" , stringify ! (fWY))) ; } test_field_fWY () ; } extern "C" { # [link_name = "\u{1}?toXYZD50@SkColorSpacePrimaries@@QEBA_NPEAUskcms_Matrix3x3@@@Z"] pub fn SkColorSpacePrimaries_toXYZD50 (this : * const SkColorSpacePrimaries , toXYZD50 : * mut skcms_Matrix3x3) -> bool ; } impl SkColorSpacePrimaries { # [inline] pub unsafe fn toXYZD50 (& self , toXYZD50 : * mut skcms_Matrix3x3) -> bool { SkColorSpacePrimaries_toXYZD50 (self , toXYZD50) } } # [repr (C)] # [derive (Debug)] pub struct SkColorSpace { pub _base : SkNVRefCnt , pub fTransferFnHash : u32 , pub fToXYZD50Hash : u32 , pub fTransferFn : skcms_TransferFunction , pub fToXYZD50 : skcms_Matrix3x3 , pub fInvTransferFn : skcms_TransferFunction , pub fFromXYZD50 : skcms_Matrix3x3 , pub fLazyDstFieldsOnce : SkOnce , } # [test] fn bindgen_test_layout_SkColorSpace () { assert_eq ! (:: core :: mem :: size_of :: < SkColorSpace > () , 144usize , concat ! ("Size of: " , stringify ! (SkColorSpace))) ; assert_eq ! (:: core :: mem :: align_of :: < SkColorSpace > () , 4usize , concat ! ("Alignment of " , stringify ! (SkColorSpace))) ; fn test_field_fTransferFnHash () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTransferFnHash) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fTransferFnHash))) ; } test_field_fTransferFnHash () ; fn test_field_fToXYZD50Hash () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fToXYZD50Hash) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fToXYZD50Hash))) ; } test_field_fToXYZD50Hash () ; fn test_field_fTransferFn () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTransferFn) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fTransferFn))) ; } test_field_fTransferFn () ; fn test_field_fToXYZD50 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fToXYZD50) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fToXYZD50))) ; } test_field_fToXYZD50 () ; fn test_field_fInvTransferFn () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInvTransferFn) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fInvTransferFn))) ; } test_field_fInvTransferFn () ; fn test_field_fFromXYZD50 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFromXYZD50) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fFromXYZD50))) ; } test_field_fFromXYZD50 () ; fn test_field_fLazyDstFieldsOnce () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorSpace > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLazyDstFieldsOnce) as usize - ptr as usize } , 140usize , concat ! ("Offset of field: " , stringify ! (SkColorSpace) , "::" , stringify ! (fLazyDstFieldsOnce))) ; } test_field_fLazyDstFieldsOnce () ; } extern "C" { # [link_name = "\u{1}?MakeSRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorSpace_MakeSRGB () -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?MakeSRGBLinear@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorSpace_MakeSRGBLinear () -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?MakeRGB@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@AEBUskcms_TransferFunction@@AEBUskcms_Matrix3x3@@@Z"] pub fn SkColorSpace_MakeRGB (transferFn : * const skcms_TransferFunction , toXYZ : * const skcms_Matrix3x3) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?Make@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@AEBUskcms_ICCProfile@@@Z"] pub fn SkColorSpace_Make (arg1 : * const skcms_ICCProfile) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?toProfile@SkColorSpace@@QEBAXPEAUskcms_ICCProfile@@@Z"] pub fn SkColorSpace_toProfile (this : * const SkColorSpace , arg1 : * mut skcms_ICCProfile) ; } extern "C" { # [link_name = "\u{1}?gammaCloseToSRGB@SkColorSpace@@QEBA_NXZ"] pub fn SkColorSpace_gammaCloseToSRGB (this : * const SkColorSpace) -> bool ; } extern "C" { # [link_name = "\u{1}?gammaIsLinear@SkColorSpace@@QEBA_NXZ"] pub fn SkColorSpace_gammaIsLinear (this : * const SkColorSpace) -> bool ; } extern "C" { # [link_name = "\u{1}?isNumericalTransferFn@SkColorSpace@@QEBA_NPEAUskcms_TransferFunction@@@Z"] pub fn SkColorSpace_isNumericalTransferFn (this : * const SkColorSpace , fn_ : * mut skcms_TransferFunction) -> bool ; } extern "C" { # [link_name = "\u{1}?toXYZD50@SkColorSpace@@QEBA_NPEAUskcms_Matrix3x3@@@Z"] pub fn SkColorSpace_toXYZD50 (this : * const SkColorSpace , toXYZD50 : * mut skcms_Matrix3x3) -> bool ; } extern "C" { # [link_name = "\u{1}?makeLinearGamma@SkColorSpace@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorSpace_makeLinearGamma (this : * const SkColorSpace) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?makeSRGBGamma@SkColorSpace@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorSpace_makeSRGBGamma (this : * const SkColorSpace) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?makeColorSpin@SkColorSpace@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkColorSpace_makeColorSpin (this : * const SkColorSpace) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?isSRGB@SkColorSpace@@QEBA_NXZ"] pub fn SkColorSpace_isSRGB (this : * const SkColorSpace) -> bool ; } extern "C" { # [link_name = "\u{1}?serialize@SkColorSpace@@QEBA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkColorSpace_serialize (this : * const SkColorSpace) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?writeToMemory@SkColorSpace@@QEBA_KPEAX@Z"] pub fn SkColorSpace_writeToMemory (this : * const SkColorSpace , memory : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkColorSpace@@SA?AV?$sk_sp@VSkColorSpace@@@@PEBX_K@Z"] pub fn SkColorSpace_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?Equals@SkColorSpace@@SA_NPEBV1@0@Z"] pub fn SkColorSpace_Equals (arg1 : * const SkColorSpace , arg2 : * const SkColorSpace) -> bool ; } extern "C" { # [link_name = "\u{1}?transferFn@SkColorSpace@@QEBAXQEAM@Z"] pub fn SkColorSpace_transferFn (this : * const SkColorSpace , gabcdef : * mut f32) ; } extern "C" { # [link_name = "\u{1}?transferFn@SkColorSpace@@QEBAXPEAUskcms_TransferFunction@@@Z"] pub fn SkColorSpace_transferFn1 (this : * const SkColorSpace , fn_ : * mut skcms_TransferFunction) ; } extern "C" { # [link_name = "\u{1}?invTransferFn@SkColorSpace@@QEBAXPEAUskcms_TransferFunction@@@Z"] pub fn SkColorSpace_invTransferFn (this : * const SkColorSpace , fn_ : * mut skcms_TransferFunction) ; } extern "C" { # [link_name = "\u{1}?gamutTransformTo@SkColorSpace@@QEBAXPEBV1@PEAUskcms_Matrix3x3@@@Z"] pub fn SkColorSpace_gamutTransformTo (this : * const SkColorSpace , dst : * const SkColorSpace , src_to_dst : * mut skcms_Matrix3x3) ; } impl SkColorSpace { # [inline] pub unsafe fn MakeSRGB () -> sk_sp < SkColorSpace > { SkColorSpace_MakeSRGB () } # [inline] pub unsafe fn MakeSRGBLinear () -> sk_sp < SkColorSpace > { SkColorSpace_MakeSRGBLinear () } # [inline] pub unsafe fn MakeRGB (transferFn : * const skcms_TransferFunction , toXYZ : * const skcms_Matrix3x3) -> sk_sp < SkColorSpace > { SkColorSpace_MakeRGB (transferFn , toXYZ) } # [inline] pub unsafe fn Make (arg1 : * const skcms_ICCProfile) -> sk_sp < SkColorSpace > { SkColorSpace_Make (arg1) } # [inline] pub unsafe fn toProfile (& self , arg1 : * mut skcms_ICCProfile) { SkColorSpace_toProfile (self , arg1) } # [inline] pub unsafe fn gammaCloseToSRGB (& self) -> bool { SkColorSpace_gammaCloseToSRGB (self) } # [inline] pub unsafe fn gammaIsLinear (& self) -> bool { SkColorSpace_gammaIsLinear (self) } # [inline] pub unsafe fn isNumericalTransferFn (& self , fn_ : * mut skcms_TransferFunction) -> bool { SkColorSpace_isNumericalTransferFn (self , fn_) } # [inline] pub unsafe fn toXYZD50 (& self , toXYZD50 : * mut skcms_Matrix3x3) -> bool { SkColorSpace_toXYZD50 (self , toXYZD50) } # [inline] pub unsafe fn makeLinearGamma (& self) -> sk_sp < SkColorSpace > { SkColorSpace_makeLinearGamma (self) } # [inline] pub unsafe fn makeSRGBGamma (& self) -> sk_sp < SkColorSpace > { SkColorSpace_makeSRGBGamma (self) } # [inline] pub unsafe fn makeColorSpin (& self) -> sk_sp < SkColorSpace > { SkColorSpace_makeColorSpin (self) } # [inline] pub unsafe fn isSRGB (& self) -> bool { SkColorSpace_isSRGB (self) } # [inline] pub unsafe fn serialize (& self) -> sk_sp < SkData > { SkColorSpace_serialize (self) } # [inline] pub unsafe fn writeToMemory (& self , memory : * mut :: core :: ffi :: c_void) -> usize { SkColorSpace_writeToMemory (self , memory) } # [inline] pub unsafe fn Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> sk_sp < SkColorSpace > { SkColorSpace_Deserialize (data , length) } # [inline] pub unsafe fn Equals (arg1 : * const SkColorSpace , arg2 : * const SkColorSpace) -> bool { SkColorSpace_Equals (arg1 , arg2) } # [inline] pub unsafe fn transferFn (& self , gabcdef : * mut f32) { SkColorSpace_transferFn (self , gabcdef) } # [inline] pub unsafe fn transferFn1 (& self , fn_ : * mut skcms_TransferFunction) { SkColorSpace_transferFn1 (self , fn_) } # [inline] pub unsafe fn invTransferFn (& self , fn_ : * mut skcms_TransferFunction) { SkColorSpace_invTransferFn (self , fn_) } # [inline] pub unsafe fn gamutTransformTo (& self , dst : * const SkColorSpace , src_to_dst : * mut skcms_Matrix3x3) { SkColorSpace_gamutTransformTo (self , dst , src_to_dst) } } # [repr (C)] # [derive (Debug)] pub struct SkEncodedInfo { pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fColor : SkEncodedInfo_Color , pub fAlpha : SkEncodedInfo_Alpha , pub fBitsPerComponent : u8 , pub fColorDepth : u8 , pub fProfile : u64 , } # [repr (C)] pub struct SkEncodedInfo_ICCProfile { pub fProfile : skcms_ICCProfile , pub fData : sk_sp < SkData > , } # [test] fn bindgen_test_layout_SkEncodedInfo_ICCProfile () { assert_eq ! (:: core :: mem :: size_of :: < SkEncodedInfo_ICCProfile > () , 1016usize , concat ! ("Size of: " , stringify ! (SkEncodedInfo_ICCProfile))) ; assert_eq ! (:: core :: mem :: align_of :: < SkEncodedInfo_ICCProfile > () , 8usize , concat ! ("Alignment of " , stringify ! (SkEncodedInfo_ICCProfile))) ; fn test_field_fProfile () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProfile) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo_ICCProfile) , "::" , stringify ! (fProfile))) ; } test_field_fProfile () ; fn test_field_fData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo_ICCProfile > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fData) as usize - ptr as usize } , 1008usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo_ICCProfile) , "::" , stringify ! (fData))) ; } test_field_fData () ; } extern "C" { # [link_name = "\u{1}?Make@ICCProfile@SkEncodedInfo@@SA?AV?$unique_ptr@VICCProfile@SkEncodedInfo@@U?$default_delete@VICCProfile@SkEncodedInfo@@@std@@@std@@V?$sk_sp@VSkData@@@@@Z"] pub fn SkEncodedInfo_ICCProfile_Make (arg1 : sk_sp < SkData >) -> u64 ; } extern "C" { # [link_name = "\u{1}?Make@ICCProfile@SkEncodedInfo@@SA?AV?$unique_ptr@VICCProfile@SkEncodedInfo@@U?$default_delete@VICCProfile@SkEncodedInfo@@@std@@@std@@AEBUskcms_ICCProfile@@@Z"] pub fn SkEncodedInfo_ICCProfile_Make1 (arg1 : * const skcms_ICCProfile) -> u64 ; } impl SkEncodedInfo_ICCProfile { # [inline] pub unsafe fn Make (arg1 : sk_sp < SkData >) -> u64 { SkEncodedInfo_ICCProfile_Make (arg1) } # [inline] pub unsafe fn Make1 (arg1 : * const skcms_ICCProfile) -> u64 { SkEncodedInfo_ICCProfile_Make1 (arg1) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkEncodedInfo_Alpha { kOpaque_Alpha = 0 , kUnpremul_Alpha = 1 , kBinary_Alpha = 2 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkEncodedInfo_Color { kGray_Color = 0 , kGrayAlpha_Color = 1 , kXAlpha_Color = 2 , k565_Color = 3 , kPalette_Color = 4 , kRGB_Color = 5 , kRGBA_Color = 6 , kBGR_Color = 7 , kBGRX_Color = 8 , kBGRA_Color = 9 , kYUV_Color = 10 , kYUVA_Color = 11 , kInvertedCMYK_Color = 12 , kYCCK_Color = 13 , } # [test] fn bindgen_test_layout_SkEncodedInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkEncodedInfo > () , 32usize , concat ! ("Size of: " , stringify ! (SkEncodedInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkEncodedInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkEncodedInfo))) ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fColor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fColor))) ; } test_field_fColor () ; fn test_field_fAlpha () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlpha) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fAlpha))) ; } test_field_fAlpha () ; fn test_field_fBitsPerComponent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBitsPerComponent) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fBitsPerComponent))) ; } test_field_fBitsPerComponent () ; fn test_field_fColorDepth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorDepth) as usize - ptr as usize } , 17usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fColorDepth))) ; } test_field_fColorDepth () ; fn test_field_fProfile () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkEncodedInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProfile) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkEncodedInfo) , "::" , stringify ! (fProfile))) ; } test_field_fProfile () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkNoncopyable { pub _address : u8 , } # [test] fn bindgen_test_layout_SkNoncopyable () { assert_eq ! (:: core :: mem :: size_of :: < SkNoncopyable > () , 1usize , concat ! ("Size of: " , stringify ! (SkNoncopyable))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNoncopyable > () , 1usize , concat ! ("Alignment of " , stringify ! (SkNoncopyable))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPngChunkReader { _unused : [u8 ; 0] , } # [repr (C)] pub struct SkCodec__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] pub struct SkCodec { pub vtable_ : * const SkCodec__bindgen_vtable , pub fEncodedInfo : SkEncodedInfo , pub fSrcXformFormat : SkCodec_XformFormat , pub fStream : u64 , pub fNeedsRewind : bool , pub fOrigin : SkEncodedOrigin , pub fDstInfo : SkImageInfo , pub fOptions : SkCodec_Options , pub fXformTime : SkCodec_XformTime , pub fDstXformFormat : SkCodec_XformFormat , pub fDstProfile : skcms_ICCProfile , pub fDstXformAlphaFormat : skcms_AlphaFormat , pub fCurrScanline : :: std :: os :: raw :: c_int , pub fStartedIncrementalDecode : bool , pub fAndroidCodecHandlesFrameIndex : bool , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodec_Result { Success = 0 , IncompleteInput = 1 , ErrorInInput = 2 , InvalidConversion = 3 , InvalidScale = 4 , InvalidParameters = 5 , InvalidInput = 6 , CouldNotRewind = 7 , InternalError = 8 , Unimplemented = 9 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodec_SelectionPolicy { PreferStillImage = 0 , PreferAnimation = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodec_ZeroInitialized { Yes = 0 , No = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCodec_Options { pub fZeroInitialized : SkCodec_ZeroInitialized , pub fSubset : * const SkIRect , pub fFrameIndex : :: std :: os :: raw :: c_int , pub fPriorFrame : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_SkCodec_Options () { assert_eq ! (:: core :: mem :: size_of :: < SkCodec_Options > () , 24usize , concat ! ("Size of: " , stringify ! (SkCodec_Options))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCodec_Options > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCodec_Options))) ; fn test_field_fZeroInitialized () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fZeroInitialized) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCodec_Options) , "::" , stringify ! (fZeroInitialized))) ; } test_field_fZeroInitialized () ; fn test_field_fSubset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubset) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCodec_Options) , "::" , stringify ! (fSubset))) ; } test_field_fSubset () ; fn test_field_fFrameIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFrameIndex) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCodec_Options) , "::" , stringify ! (fFrameIndex))) ; } test_field_fFrameIndex () ; fn test_field_fPriorFrame () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPriorFrame) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkCodec_Options) , "::" , stringify ! (fPriorFrame))) ; } test_field_fPriorFrame () ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodec_SkScanlineOrder { TopDown = 0 , BottomUp = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCodec_FrameInfo { pub fRequiredFrame : :: std :: os :: raw :: c_int , pub fDuration : :: std :: os :: raw :: c_int , pub fFullyReceived : bool , pub fAlphaType : SkAlphaType , pub fHasAlphaWithinBounds : bool , pub fDisposalMethod : SkCodecAnimation_DisposalMethod , pub fBlend : SkCodecAnimation_Blend , pub fFrameRect : SkIRect , } # [test] fn bindgen_test_layout_SkCodec_FrameInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkCodec_FrameInfo > () , 44usize , concat ! ("Size of: " , stringify ! (SkCodec_FrameInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCodec_FrameInfo > () , 4usize , concat ! ("Alignment of " , stringify ! (SkCodec_FrameInfo))) ; fn test_field_fRequiredFrame () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRequiredFrame) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fRequiredFrame))) ; } test_field_fRequiredFrame () ; fn test_field_fDuration () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDuration) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fDuration))) ; } test_field_fDuration () ; fn test_field_fFullyReceived () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFullyReceived) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fFullyReceived))) ; } test_field_fFullyReceived () ; fn test_field_fAlphaType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlphaType) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fAlphaType))) ; } test_field_fAlphaType () ; fn test_field_fHasAlphaWithinBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHasAlphaWithinBounds) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fHasAlphaWithinBounds))) ; } test_field_fHasAlphaWithinBounds () ; fn test_field_fDisposalMethod () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDisposalMethod) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fDisposalMethod))) ; } test_field_fDisposalMethod () ; fn test_field_fBlend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBlend) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fBlend))) ; } test_field_fBlend () ; fn test_field_fFrameRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec_FrameInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFrameRect) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkCodec_FrameInfo) , "::" , stringify ! (fFrameRect))) ; } test_field_fFrameRect () ; } pub use self :: skcms_PixelFormat as SkCodec_XformFormat ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCodec_XformTime { kNo_XformTime = 0 , kPalette_XformTime = 1 , kDecodeRow_XformTime = 2 , } pub const SkCodec_kNoFrame : :: std :: os :: raw :: c_int = - 1 ; pub const SkCodec_kRepetitionCountInfinite : :: std :: os :: raw :: c_int = - 1 ; # [test] fn bindgen_test_layout_SkCodec () { assert_eq ! (:: core :: mem :: size_of :: < SkCodec > () , 1144usize , concat ! ("Size of: " , stringify ! (SkCodec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCodec > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCodec))) ; fn test_field_fEncodedInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEncodedInfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fEncodedInfo))) ; } test_field_fEncodedInfo () ; fn test_field_fSrcXformFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSrcXformFormat) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fSrcXformFormat))) ; } test_field_fSrcXformFormat () ; fn test_field_fStream () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStream) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fStream))) ; } test_field_fStream () ; fn test_field_fNeedsRewind () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNeedsRewind) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fNeedsRewind))) ; } test_field_fNeedsRewind () ; fn test_field_fOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOrigin) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fOrigin))) ; } test_field_fOrigin () ; fn test_field_fDstInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDstInfo) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fDstInfo))) ; } test_field_fDstInfo () ; fn test_field_fOptions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOptions) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fOptions))) ; } test_field_fOptions () ; fn test_field_fXformTime () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXformTime) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fXformTime))) ; } test_field_fXformTime () ; fn test_field_fDstXformFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDstXformFormat) as usize - ptr as usize } , 116usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fDstXformFormat))) ; } test_field_fDstXformFormat () ; fn test_field_fDstProfile () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDstProfile) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fDstProfile))) ; } test_field_fDstProfile () ; fn test_field_fDstXformAlphaFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDstXformAlphaFormat) as usize - ptr as usize } , 1128usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fDstXformAlphaFormat))) ; } test_field_fDstXformAlphaFormat () ; fn test_field_fCurrScanline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCurrScanline) as usize - ptr as usize } , 1132usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fCurrScanline))) ; } test_field_fCurrScanline () ; fn test_field_fStartedIncrementalDecode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStartedIncrementalDecode) as usize - ptr as usize } , 1136usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fStartedIncrementalDecode))) ; } test_field_fStartedIncrementalDecode () ; fn test_field_fAndroidCodecHandlesFrameIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCodec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAndroidCodecHandlesFrameIndex) as usize - ptr as usize } , 1137usize , concat ! ("Offset of field: " , stringify ! (SkCodec) , "::" , stringify ! (fAndroidCodecHandlesFrameIndex))) ; } test_field_fAndroidCodecHandlesFrameIndex () ; } extern "C" { # [link_name = "\u{1}?ResultToString@SkCodec@@SAPEBDW4Result@1@@Z"] pub fn SkCodec_ResultToString (arg1 : SkCodec_Result) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [link_name = "\u{1}?MakeFromStream@SkCodec@@SA?AV?$unique_ptr@VSkCodec@@U?$default_delete@VSkCodec@@@std@@@std@@V?$unique_ptr@VSkStream@@U?$default_delete@VSkStream@@@std@@@3@PEAW4Result@1@PEAVSkPngChunkReader@@W4SelectionPolicy@1@@Z"] pub fn SkCodec_MakeFromStream (arg1 : u64 , arg2 : * mut SkCodec_Result , arg3 : * mut SkPngChunkReader , selectionPolicy : SkCodec_SelectionPolicy) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeFromData@SkCodec@@SA?AV?$unique_ptr@VSkCodec@@U?$default_delete@VSkCodec@@@std@@@std@@V?$sk_sp@VSkData@@@@PEAVSkPngChunkReader@@@Z"] pub fn SkCodec_MakeFromData (arg1 : sk_sp < SkData > , arg2 : * mut SkPngChunkReader) -> u64 ; } extern "C" { # [link_name = "\u{1}?getPixels@SkCodec@@QEAA?AW4Result@1@AEBUSkImageInfo@@PEAX_KPEBUOptions@1@@Z"] pub fn SkCodec_getPixels (this : * mut SkCodec , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , arg1 : * const SkCodec_Options) -> SkCodec_Result ; } extern "C" { # [link_name = "\u{1}?getImage@SkCodec@@QEAA?AV?$tuple@V?$sk_sp@VSkImage@@@@W4Result@SkCodec@@@std@@AEBUSkImageInfo@@PEBUOptions@1@@Z"] pub fn SkCodec_getImage (this : * mut SkCodec , info : * const SkImageInfo , opts : * const SkCodec_Options) -> [u64 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?getImage@SkCodec@@QEAA?AV?$tuple@V?$sk_sp@VSkImage@@@@W4Result@SkCodec@@@std@@XZ"] pub fn SkCodec_getImage1 (this : * mut SkCodec) -> [u64 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?queryYUVAInfo@SkCodec@@QEBA_NAEBVSupportedDataTypes@SkYUVAPixmapInfo@@PEAV3@@Z"] pub fn SkCodec_queryYUVAInfo (this : * const SkCodec , supportedDataTypes : * const SkYUVAPixmapInfo_SupportedDataTypes , yuvaPixmapInfo : * mut SkYUVAPixmapInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?getYUVAPlanes@SkCodec@@QEAA?AW4Result@1@AEBVSkYUVAPixmaps@@@Z"] pub fn SkCodec_getYUVAPlanes (this : * mut SkCodec , yuvaPixmaps : * const SkYUVAPixmaps) -> SkCodec_Result ; } extern "C" { # [link_name = "\u{1}?startIncrementalDecode@SkCodec@@QEAA?AW4Result@1@AEBUSkImageInfo@@PEAX_KPEBUOptions@1@@Z"] pub fn SkCodec_startIncrementalDecode (this : * mut SkCodec , dstInfo : * const SkImageInfo , dst : * mut :: core :: ffi :: c_void , rowBytes : usize , arg1 : * const SkCodec_Options) -> SkCodec_Result ; } extern "C" { # [link_name = "\u{1}?startScanlineDecode@SkCodec@@QEAA?AW4Result@1@AEBUSkImageInfo@@PEBUOptions@1@@Z"] pub fn SkCodec_startScanlineDecode (this : * mut SkCodec , dstInfo : * const SkImageInfo , options : * const SkCodec_Options) -> SkCodec_Result ; } extern "C" { # [link_name = "\u{1}?getScanlines@SkCodec@@QEAAHPEAXH_K@Z"] pub fn SkCodec_getScanlines (this : * mut SkCodec , dst : * mut :: core :: ffi :: c_void , countLines : :: std :: os :: raw :: c_int , rowBytes : usize) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?skipScanlines@SkCodec@@QEAA_NH@Z"] pub fn SkCodec_skipScanlines (this : * mut SkCodec , countLines : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?outputScanline@SkCodec@@QEBAHH@Z"] pub fn SkCodec_outputScanline (this : * const SkCodec , inputScanline : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getFrameInfo@SkCodec@@QEAA?AV?$vector@UFrameInfo@SkCodec@@V?$allocator@UFrameInfo@SkCodec@@@std@@@std@@XZ"] pub fn SkCodec_getFrameInfo (this : * mut SkCodec) -> u8 ; } extern "C" { # [link_name = "\u{1}?Register@SkCodec@@SAXP6A_NPEBX_K@ZP6A?AV?$unique_ptr@VSkCodec@@U?$default_delete@VSkCodec@@@std@@@std@@V?$unique_ptr@VSkStream@@U?$default_delete@VSkStream@@@std@@@3@PEAW4Result@1@@Z@Z"] pub fn SkCodec_Register (peek : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * const :: core :: ffi :: c_void , arg2 : usize) -> bool > , make : :: core :: option :: Option < unsafe extern "C" fn (arg1 : u64 , arg2 : * mut SkCodec_Result) -> u64 >) ; } extern "C" { # [link_name = "\u{1}?setSrcXformFormat@SkCodec@@IEAAXW4skcms_PixelFormat@@@Z"] pub fn SkCodec_setSrcXformFormat (this : * mut SkCodec , pixelFormat : SkCodec_XformFormat) ; } extern "C" { # [link_name = "\u{1}?rewindIfNeeded@SkCodec@@IEAA_NXZ"] pub fn SkCodec_rewindIfNeeded (this : * mut SkCodec) -> bool ; } extern "C" { # [link_name = "\u{1}?applyColorXform@SkCodec@@IEBAXPEAXPEBXH@Z"] pub fn SkCodec_applyColorXform (this : * const SkCodec , dst : * mut :: core :: ffi :: c_void , src : * const :: core :: ffi :: c_void , count : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}??0SkCodec@@IEAA@$$QEAUSkEncodedInfo@@W4skcms_PixelFormat@@V?$unique_ptr@VSkStream@@U?$default_delete@VSkStream@@@std@@@std@@W4SkEncodedOrigin@@@Z"] pub fn SkCodec_SkCodec (this : * mut SkCodec , arg1 : * mut SkEncodedInfo , srcFormat : SkCodec_XformFormat , arg2 : u64 , arg3 : SkEncodedOrigin) ; } impl SkCodec { # [inline] pub unsafe fn ResultToString (arg1 : SkCodec_Result) -> * const :: std :: os :: raw :: c_char { SkCodec_ResultToString (arg1) } # [inline] pub unsafe fn MakeFromStream (arg1 : u64 , arg2 : * mut SkCodec_Result , arg3 : * mut SkPngChunkReader , selectionPolicy : SkCodec_SelectionPolicy) -> u64 { SkCodec_MakeFromStream (arg1 , arg2 , arg3 , selectionPolicy) } # [inline] pub unsafe fn MakeFromData (arg1 : sk_sp < SkData > , arg2 : * mut SkPngChunkReader) -> u64 { SkCodec_MakeFromData (arg1 , arg2) } # [inline] pub unsafe fn getPixels (& mut self , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , arg1 : * const SkCodec_Options) -> SkCodec_Result { SkCodec_getPixels (self , info , pixels , rowBytes , arg1) } # [inline] pub unsafe fn getImage (& mut self , info : * const SkImageInfo , opts : * const SkCodec_Options) -> [u64 ; 2usize] { SkCodec_getImage (self , info , opts) } # [inline] pub unsafe fn getImage1 (& mut self) -> [u64 ; 2usize] { SkCodec_getImage1 (self) } # [inline] pub unsafe fn queryYUVAInfo (& self , supportedDataTypes : * const SkYUVAPixmapInfo_SupportedDataTypes , yuvaPixmapInfo : * mut SkYUVAPixmapInfo) -> bool { SkCodec_queryYUVAInfo (self , supportedDataTypes , yuvaPixmapInfo) } # [inline] pub unsafe fn getYUVAPlanes (& mut self , yuvaPixmaps : * const SkYUVAPixmaps) -> SkCodec_Result { SkCodec_getYUVAPlanes (self , yuvaPixmaps) } # [inline] pub unsafe fn startIncrementalDecode (& mut self , dstInfo : * const SkImageInfo , dst : * mut :: core :: ffi :: c_void , rowBytes : usize , arg1 : * const SkCodec_Options) -> SkCodec_Result { SkCodec_startIncrementalDecode (self , dstInfo , dst , rowBytes , arg1) } # [inline] pub unsafe fn startScanlineDecode (& mut self , dstInfo : * const SkImageInfo , options : * const SkCodec_Options) -> SkCodec_Result { SkCodec_startScanlineDecode (self , dstInfo , options) } # [inline] pub unsafe fn getScanlines (& mut self , dst : * mut :: core :: ffi :: c_void , countLines : :: std :: os :: raw :: c_int , rowBytes : usize) -> :: std :: os :: raw :: c_int { SkCodec_getScanlines (self , dst , countLines , rowBytes) } # [inline] pub unsafe fn skipScanlines (& mut self , countLines : :: std :: os :: raw :: c_int) -> bool { SkCodec_skipScanlines (self , countLines) } # [inline] pub unsafe fn outputScanline (& self , inputScanline : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkCodec_outputScanline (self , inputScanline) } # [inline] pub unsafe fn getFrameInfo (& mut self) -> u8 { SkCodec_getFrameInfo (self) } # [inline] pub unsafe fn Register (peek : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * const :: core :: ffi :: c_void , arg2 : usize) -> bool > , make : :: core :: option :: Option < unsafe extern "C" fn (arg1 : u64 , arg2 : * mut SkCodec_Result) -> u64 >) { SkCodec_Register (peek , make) } # [inline] pub unsafe fn setSrcXformFormat (& mut self , pixelFormat : SkCodec_XformFormat) { SkCodec_setSrcXformFormat (self , pixelFormat) } # [inline] pub unsafe fn rewindIfNeeded (& mut self) -> bool { SkCodec_rewindIfNeeded (self) } # [inline] pub unsafe fn applyColorXform (& self , dst : * mut :: core :: ffi :: c_void , src : * const :: core :: ffi :: c_void , count : :: std :: os :: raw :: c_int) { SkCodec_applyColorXform (self , dst , src , count) } # [inline] pub unsafe fn new (arg1 : * mut SkEncodedInfo , srcFormat : SkCodec_XformFormat , arg2 : u64 , arg3 : SkEncodedOrigin) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCodec_SkCodec (__bindgen_tmp . as_mut_ptr () , arg1 , srcFormat , arg2 , arg3) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?onOutputScanline@SkCodec@@MEBAHH@Z"] pub fn SkCodec_onOutputScanline (this : * mut :: core :: ffi :: c_void , inputScanline : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?conversionSupported@SkCodec@@MEAA_NAEBUSkImageInfo@@_N1@Z"] pub fn SkCodec_conversionSupported (this : * mut :: core :: ffi :: c_void , dst : * const SkImageInfo , srcIsOpaque : bool , needsColorXform : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?SkAnnotateRectWithURL@@YAXPEAVSkCanvas@@AEBUSkRect@@PEAVSkData@@@Z"] pub fn SkAnnotateRectWithURL (arg1 : * mut SkCanvas , arg2 : * const SkRect , arg3 : * mut SkData) ; } extern "C" { # [link_name = "\u{1}?SkAnnotateNamedDestination@@YAXPEAVSkCanvas@@AEBUSkPoint@@PEAVSkData@@@Z"] pub fn SkAnnotateNamedDestination (arg1 : * mut SkCanvas , arg2 : * const SkPoint , arg3 : * mut SkData) ; } extern "C" { # [link_name = "\u{1}?SkAnnotateLinkToDestination@@YAXPEAVSkCanvas@@AEBUSkRect@@PEAVSkData@@@Z"] pub fn SkAnnotateLinkToDestination (arg1 : * mut SkCanvas , arg2 : * const SkRect , arg3 : * mut SkData) ; } impl SkBlendMode { pub const LastCoeffMode : SkBlendMode = SkBlendMode :: Screen ; } impl SkBlendMode { pub const LastSeparableMode : SkBlendMode = SkBlendMode :: Multiply ; } impl SkBlendMode { pub const LastMode : SkBlendMode = SkBlendMode :: Luminosity ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkBlendMode { Clear = 0 , Src = 1 , Dst = 2 , SrcOver = 3 , DstOver = 4 , SrcIn = 5 , DstIn = 6 , SrcOut = 7 , DstOut = 8 , SrcATop = 9 , DstATop = 10 , Xor = 11 , Plus = 12 , Modulate = 13 , Screen = 14 , Overlay = 15 , Darken = 16 , Lighten = 17 , ColorDodge = 18 , ColorBurn = 19 , HardLight = 20 , SoftLight = 21 , Difference = 22 , Exclusion = 23 , Multiply = 24 , Hue = 25 , Saturation = 26 , Color = 27 , Luminosity = 28 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkBlendModeCoeff { Zero = 0 , One = 1 , SC = 2 , ISC = 3 , DC = 4 , IDC = 5 , SA = 6 , ISA = 7 , DA = 8 , IDA = 9 , CoeffCount = 10 , } extern "C" { # [link_name = "\u{1}?SkBlendMode_AsCoeff@@YA_NW4SkBlendMode@@PEAW4SkBlendModeCoeff@@1@Z"] pub fn SkBlendMode_AsCoeff (mode : SkBlendMode , src : * mut SkBlendModeCoeff , dst : * mut SkBlendModeCoeff) -> bool ; } extern "C" { # [link_name = "\u{1}?SkBlendMode_Name@@YAPEBDW4SkBlendMode@@@Z"] pub fn SkBlendMode_Name (blendMode : SkBlendMode) -> * const :: std :: os :: raw :: c_char ; } impl SkClipOp { pub const Max_EnumValue : SkClipOp = SkClipOp :: Intersect ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkClipOp { Difference = 0 , Intersect = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTextEncoding { kUTF8 = 0 , kUTF16 = 1 , kUTF32 = 2 , kGlyphID = 3 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFontHinting { None = 0 , Slight = 1 , Normal = 2 , Full = 3 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkV2 { pub x : f32 , pub y : f32 , } # [test] fn bindgen_test_layout_SkV2 () { assert_eq ! (:: core :: mem :: size_of :: < SkV2 > () , 8usize , concat ! ("Size of: " , stringify ! (SkV2))) ; assert_eq ! (:: core :: mem :: align_of :: < SkV2 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkV2))) ; fn test_field_x () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkV2) , "::" , stringify ! (x))) ; } test_field_x () ; fn test_field_y () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . y) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkV2) , "::" , stringify ! (y))) ; } test_field_y () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkV3 { pub x : f32 , pub y : f32 , pub z : f32 , } # [test] fn bindgen_test_layout_SkV3 () { assert_eq ! (:: core :: mem :: size_of :: < SkV3 > () , 12usize , concat ! ("Size of: " , stringify ! (SkV3))) ; assert_eq ! (:: core :: mem :: align_of :: < SkV3 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkV3))) ; fn test_field_x () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkV3) , "::" , stringify ! (x))) ; } test_field_x () ; fn test_field_y () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . y) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkV3) , "::" , stringify ! (y))) ; } test_field_y () ; fn test_field_z () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . z) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkV3) , "::" , stringify ! (z))) ; } test_field_z () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkV4 { pub x : f32 , pub y : f32 , pub z : f32 , pub w : f32 , } # [test] fn bindgen_test_layout_SkV4 () { assert_eq ! (:: core :: mem :: size_of :: < SkV4 > () , 16usize , concat ! ("Size of: " , stringify ! (SkV4))) ; assert_eq ! (:: core :: mem :: align_of :: < SkV4 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkV4))) ; fn test_field_x () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV4 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkV4) , "::" , stringify ! (x))) ; } test_field_x () ; fn test_field_y () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV4 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . y) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkV4) , "::" , stringify ! (y))) ; } test_field_y () ; fn test_field_z () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV4 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . z) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkV4) , "::" , stringify ! (z))) ; } test_field_z () ; fn test_field_w () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkV4 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . w) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkV4) , "::" , stringify ! (w))) ; } test_field_w () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkM44 { pub fMat : [SkScalar ; 16usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkM44_Uninitialized_Constructor { kUninitialized_Constructor = 0 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkM44_NaN_Constructor { kNaN_Constructor = 0 , } # [test] fn bindgen_test_layout_SkM44 () { assert_eq ! (:: core :: mem :: size_of :: < SkM44 > () , 64usize , concat ! ("Size of: " , stringify ! (SkM44))) ; assert_eq ! (:: core :: mem :: align_of :: < SkM44 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkM44))) ; fn test_field_fMat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkM44 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMat) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkM44) , "::" , stringify ! (fMat))) ; } test_field_fMat () ; } extern "C" { # [link_name = "\u{1}?RectToRect@SkM44@@SA?AV1@AEBUSkRect@@0@Z"] pub fn SkM44_RectToRect (src : * const SkRect , dst : * const SkRect) -> SkM44 ; } extern "C" { # [link_name = "\u{1}?LookAt@SkM44@@SA?AV1@AEBUSkV3@@00@Z"] pub fn SkM44_LookAt (eye : * const SkV3 , center : * const SkV3 , up : * const SkV3) -> SkM44 ; } extern "C" { # [link_name = "\u{1}?Perspective@SkM44@@SA?AV1@MMM@Z"] pub fn SkM44_Perspective (near : f32 , far : f32 , angle : f32) -> SkM44 ; } extern "C" { # [link_name = "\u{1}?getRowMajor@SkM44@@QEBAXQEAM@Z"] pub fn SkM44_getRowMajor (this : * const SkM44 , v : * mut SkScalar) ; } extern "C" { # [link_name = "\u{1}?setRotateUnitSinCos@SkM44@@QEAAAEAV1@USkV3@@MM@Z"] pub fn SkM44_setRotateUnitSinCos (this : * mut SkM44 , axis : SkV3 , sinAngle : SkScalar , cosAngle : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?setRotate@SkM44@@QEAAAEAV1@USkV3@@M@Z"] pub fn SkM44_setRotate (this : * mut SkM44 , axis : SkV3 , radians : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?setConcat@SkM44@@QEAAAEAV1@AEBV1@0@Z"] pub fn SkM44_setConcat (this : * mut SkM44 , a : * const SkM44 , b : * const SkM44) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?normalizePerspective@SkM44@@QEAAXXZ"] pub fn SkM44_normalizePerspective (this : * mut SkM44) ; } extern "C" { # [link_name = "\u{1}?invert@SkM44@@QEBA_NPEAV1@@Z"] pub fn SkM44_invert (this : * const SkM44 , inverse : * mut SkM44) -> bool ; } extern "C" { # [link_name = "\u{1}?transpose@SkM44@@QEBA?AV1@XZ"] pub fn SkM44_transpose (this : * const SkM44) -> SkM44 ; } extern "C" { # [link_name = "\u{1}?dump@SkM44@@QEBAXXZ"] pub fn SkM44_dump (this : * const SkM44) ; } extern "C" { # [link_name = "\u{1}?map@SkM44@@QEBA?AUSkV4@@MMMM@Z"] pub fn SkM44_map (this : * const SkM44 , x : f32 , y : f32 , z : f32 , w : f32) -> SkV4 ; } extern "C" { # [link_name = "\u{1}?preTranslate@SkM44@@QEAAAEAV1@MMM@Z"] pub fn SkM44_preTranslate (this : * mut SkM44 , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?postTranslate@SkM44@@QEAAAEAV1@MMM@Z"] pub fn SkM44_postTranslate (this : * mut SkM44 , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?preScale@SkM44@@QEAAAEAV1@MM@Z"] pub fn SkM44_preScale (this : * mut SkM44 , x : SkScalar , y : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?preScale@SkM44@@QEAAAEAV1@MMM@Z"] pub fn SkM44_preScale1 (this : * mut SkM44 , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 ; } extern "C" { # [link_name = "\u{1}?preConcat@SkM44@@QEAAAEAV1@AEBVSkMatrix@@@Z"] pub fn SkM44_preConcat (this : * mut SkM44 , arg1 : * const SkMatrix) -> * mut SkM44 ; } impl SkM44 { # [inline] pub unsafe fn RectToRect (src : * const SkRect , dst : * const SkRect) -> SkM44 { SkM44_RectToRect (src , dst) } # [inline] pub unsafe fn LookAt (eye : * const SkV3 , center : * const SkV3 , up : * const SkV3) -> SkM44 { SkM44_LookAt (eye , center , up) } # [inline] pub unsafe fn Perspective (near : f32 , far : f32 , angle : f32) -> SkM44 { SkM44_Perspective (near , far , angle) } # [inline] pub unsafe fn getRowMajor (& self , v : * mut SkScalar) { SkM44_getRowMajor (self , v) } # [inline] pub unsafe fn setRotateUnitSinCos (& mut self , axis : SkV3 , sinAngle : SkScalar , cosAngle : SkScalar) -> * mut SkM44 { SkM44_setRotateUnitSinCos (self , axis , sinAngle , cosAngle) } # [inline] pub unsafe fn setRotate (& mut self , axis : SkV3 , radians : SkScalar) -> * mut SkM44 { SkM44_setRotate (self , axis , radians) } # [inline] pub unsafe fn setConcat (& mut self , a : * const SkM44 , b : * const SkM44) -> * mut SkM44 { SkM44_setConcat (self , a , b) } # [inline] pub unsafe fn normalizePerspective (& mut self) { SkM44_normalizePerspective (self) } # [inline] pub unsafe fn invert (& self , inverse : * mut SkM44) -> bool { SkM44_invert (self , inverse) } # [inline] pub unsafe fn transpose (& self) -> SkM44 { SkM44_transpose (self) } # [inline] pub unsafe fn dump (& self) { SkM44_dump (self) } # [inline] pub unsafe fn map (& self , x : f32 , y : f32 , z : f32 , w : f32) -> SkV4 { SkM44_map (self , x , y , z , w) } # [inline] pub unsafe fn preTranslate (& mut self , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 { SkM44_preTranslate (self , x , y , z) } # [inline] pub unsafe fn postTranslate (& mut self , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 { SkM44_postTranslate (self , x , y , z) } # [inline] pub unsafe fn preScale (& mut self , x : SkScalar , y : SkScalar) -> * mut SkM44 { SkM44_preScale (self , x , y) } # [inline] pub unsafe fn preScale1 (& mut self , x : SkScalar , y : SkScalar , z : SkScalar) -> * mut SkM44 { SkM44_preScale1 (self , x , y , z) } # [inline] pub unsafe fn preConcat (& mut self , arg1 : * const SkMatrix) -> * mut SkM44 { SkM44_preConcat (self , arg1) } } # [repr (C)] pub struct SkPaint { pub fPathEffect : sk_sp < SkPathEffect > , pub fShader : sk_sp < SkShader > , pub fMaskFilter : sk_sp < SkMaskFilter > , pub fColorFilter : sk_sp < SkColorFilter > , pub fImageFilter : sk_sp < SkImageFilter > , pub fBlender : sk_sp < SkBlender > , pub fColor4f : SkColor4f , pub fWidth : SkScalar , pub fMiterLimit : SkScalar , pub __bindgen_anon_1 : SkPaint__bindgen_ty_1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPaint_Style { Fill = 0 , Stroke = 1 , StrokeAndFill = 2 , } impl SkPaint_Cap { pub const Last : SkPaint_Cap = SkPaint_Cap :: Square ; } impl SkPaint_Cap { pub const Default : SkPaint_Cap = SkPaint_Cap :: Butt ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPaint_Cap { Butt = 0 , Round = 1 , Square = 2 , } impl SkPaint_Join { pub const Last : SkPaint_Join = SkPaint_Join :: Bevel ; } impl SkPaint_Join { pub const Default : SkPaint_Join = SkPaint_Join :: Miter ; } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPaint_Join { Miter = 0 , Round = 1 , Bevel = 2 , } # [repr (C)] # [derive (Copy , Clone)] pub union SkPaint__bindgen_ty_1 { pub fBitfields : SkPaint__bindgen_ty_1__bindgen_ty_1 , pub fBitfieldsUInt : u32 , } # [repr (C)] # [repr (align (4))] # [derive (Debug , Copy , Clone)] pub struct SkPaint__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_align_1 : [u32 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 4usize] > , } # [test] fn bindgen_test_layout_SkPaint__bindgen_ty_1__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < SkPaint__bindgen_ty_1__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (SkPaint__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPaint__bindgen_ty_1__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkPaint__bindgen_ty_1__bindgen_ty_1))) ; } impl SkPaint__bindgen_ty_1__bindgen_ty_1 { # [inline] pub fn fAntiAlias (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u32) } } # [inline] pub fn set_fAntiAlias (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub fn fDither (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u32) } } # [inline] pub fn set_fDither (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub fn fCapType (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 2u8) as u32) } } # [inline] pub fn set_fCapType (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 2u8 , val as u64) } } # [inline] pub fn fJoinType (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (4usize , 2u8) as u32) } } # [inline] pub fn set_fJoinType (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (4usize , 2u8 , val as u64) } } # [inline] pub fn fStyle (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (6usize , 2u8) as u32) } } # [inline] pub fn set_fStyle (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (6usize , 2u8 , val as u64) } } # [inline] pub fn fPadding (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (8usize , 24u8) as u32) } } # [inline] pub fn set_fPadding (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (8usize , 24u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (fAntiAlias : :: std :: os :: raw :: c_uint , fDither : :: std :: os :: raw :: c_uint , fCapType : :: std :: os :: raw :: c_uint , fJoinType : :: std :: os :: raw :: c_uint , fStyle : :: std :: os :: raw :: c_uint , fPadding : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 4usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 4usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let fAntiAlias : u32 = unsafe { :: core :: mem :: transmute (fAntiAlias) } ; fAntiAlias as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let fDither : u32 = unsafe { :: core :: mem :: transmute (fDither) } ; fDither as u64 }) ; __bindgen_bitfield_unit . set (2usize , 2u8 , { let fCapType : u32 = unsafe { :: core :: mem :: transmute (fCapType) } ; fCapType as u64 }) ; __bindgen_bitfield_unit . set (4usize , 2u8 , { let fJoinType : u32 = unsafe { :: core :: mem :: transmute (fJoinType) } ; fJoinType as u64 }) ; __bindgen_bitfield_unit . set (6usize , 2u8 , { let fStyle : u32 = unsafe { :: core :: mem :: transmute (fStyle) } ; fStyle as u64 }) ; __bindgen_bitfield_unit . set (8usize , 24u8 , { let fPadding : u32 = unsafe { :: core :: mem :: transmute (fPadding) } ; fPadding as u64 }) ; __bindgen_bitfield_unit } } # [test] fn bindgen_test_layout_SkPaint__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < SkPaint__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (SkPaint__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPaint__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkPaint__bindgen_ty_1))) ; fn test_field_fBitfields () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBitfields) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPaint__bindgen_ty_1) , "::" , stringify ! (fBitfields))) ; } test_field_fBitfields () ; fn test_field_fBitfieldsUInt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBitfieldsUInt) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPaint__bindgen_ty_1) , "::" , stringify ! (fBitfieldsUInt))) ; } test_field_fBitfieldsUInt () ; } pub const SkPaint_kStyleCount : :: std :: os :: raw :: c_int = 3 ; pub const SkPaint_kCapCount : :: std :: os :: raw :: c_int = 3 ; pub const SkPaint_kJoinCount : :: std :: os :: raw :: c_int = 3 ; # [test] fn bindgen_test_layout_SkPaint () { assert_eq ! (:: core :: mem :: size_of :: < SkPaint > () , 80usize , concat ! ("Size of: " , stringify ! (SkPaint))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPaint > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPaint))) ; fn test_field_fPathEffect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPathEffect) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fPathEffect))) ; } test_field_fPathEffect () ; fn test_field_fShader () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fShader) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fShader))) ; } test_field_fShader () ; fn test_field_fMaskFilter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaskFilter) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fMaskFilter))) ; } test_field_fMaskFilter () ; fn test_field_fColorFilter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorFilter) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fColorFilter))) ; } test_field_fColorFilter () ; fn test_field_fImageFilter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageFilter) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fImageFilter))) ; } test_field_fImageFilter () ; fn test_field_fBlender () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBlender) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fBlender))) ; } test_field_fBlender () ; fn test_field_fColor4f () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColor4f) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fColor4f))) ; } test_field_fColor4f () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fMiterLimit () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPaint > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMiterLimit) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (SkPaint) , "::" , stringify ! (fMiterLimit))) ; } test_field_fMiterLimit () ; } extern "C" { # [link_name = "\u{1}?reset@SkPaint@@QEAAXXZ"] pub fn SkPaint_reset (this : * mut SkPaint) ; } extern "C" { # [link_name = "\u{1}?setStyle@SkPaint@@QEAAXW4Style@1@@Z"] pub fn SkPaint_setStyle (this : * mut SkPaint , style : SkPaint_Style) ; } extern "C" { # [link_name = "\u{1}?setStroke@SkPaint@@QEAAX_N@Z"] pub fn SkPaint_setStroke (this : * mut SkPaint , arg1 : bool) ; } extern "C" { # [link_name = "\u{1}?setColor@SkPaint@@QEAAXI@Z"] pub fn SkPaint_setColor (this : * mut SkPaint , color : SkColor) ; } extern "C" { # [link_name = "\u{1}?setColor@SkPaint@@QEAAXAEBU?$SkRGBA4f@$02@@PEAVSkColorSpace@@@Z"] pub fn SkPaint_setColor1 (this : * mut SkPaint , color : * const SkColor4f , colorSpace : * mut SkColorSpace) ; } extern "C" { # [link_name = "\u{1}?setAlphaf@SkPaint@@QEAAXM@Z"] pub fn SkPaint_setAlphaf (this : * mut SkPaint , a : f32) ; } extern "C" { # [link_name = "\u{1}?setARGB@SkPaint@@QEAAXIIII@Z"] pub fn SkPaint_setARGB (this : * mut SkPaint , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU) ; } extern "C" { # [link_name = "\u{1}?setStrokeWidth@SkPaint@@QEAAXM@Z"] pub fn SkPaint_setStrokeWidth (this : * mut SkPaint , width : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setStrokeMiter@SkPaint@@QEAAXM@Z"] pub fn SkPaint_setStrokeMiter (this : * mut SkPaint , miter : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setStrokeCap@SkPaint@@QEAAXW4Cap@1@@Z"] pub fn SkPaint_setStrokeCap (this : * mut SkPaint , cap : SkPaint_Cap) ; } extern "C" { # [link_name = "\u{1}?setStrokeJoin@SkPaint@@QEAAXW4Join@1@@Z"] pub fn SkPaint_setStrokeJoin (this : * mut SkPaint , join : SkPaint_Join) ; } extern "C" { # [link_name = "\u{1}?getFillPath@SkPaint@@QEBA_NAEBVSkPath@@PEAV2@PEBUSkRect@@M@Z"] pub fn SkPaint_getFillPath (this : * const SkPaint , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , resScale : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?getFillPath@SkPaint@@QEBA_NAEBVSkPath@@PEAV2@PEBUSkRect@@AEBVSkMatrix@@@Z"] pub fn SkPaint_getFillPath1 (this : * const SkPaint , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , ctm : * const SkMatrix) -> bool ; } extern "C" { # [link_name = "\u{1}?refShader@SkPaint@@QEBA?AV?$sk_sp@VSkShader@@@@XZ"] pub fn SkPaint_refShader (this : * const SkPaint) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?setShader@SkPaint@@QEAAXV?$sk_sp@VSkShader@@@@@Z"] pub fn SkPaint_setShader (this : * mut SkPaint , shader : sk_sp < SkShader >) ; } extern "C" { # [link_name = "\u{1}?refColorFilter@SkPaint@@QEBA?AV?$sk_sp@VSkColorFilter@@@@XZ"] pub fn SkPaint_refColorFilter (this : * const SkPaint) -> sk_sp < SkColorFilter > ; } extern "C" { # [link_name = "\u{1}?setColorFilter@SkPaint@@QEAAXV?$sk_sp@VSkColorFilter@@@@@Z"] pub fn SkPaint_setColorFilter (this : * mut SkPaint , colorFilter : sk_sp < SkColorFilter >) ; } extern "C" { # [link_name = "\u{1}?asBlendMode@SkPaint@@QEBA?AV?$optional@W4SkBlendMode@@@std@@XZ"] pub fn SkPaint_asBlendMode (this : * const SkPaint) -> [u32 ; 2usize] ; } extern "C" { # [link_name = "\u{1}?getBlendMode_or@SkPaint@@QEBA?AW4SkBlendMode@@W42@@Z"] pub fn SkPaint_getBlendMode_or (this : * const SkPaint , defaultMode : SkBlendMode) -> SkBlendMode ; } extern "C" { # [link_name = "\u{1}?isSrcOver@SkPaint@@QEBA_NXZ"] pub fn SkPaint_isSrcOver (this : * const SkPaint) -> bool ; } extern "C" { # [link_name = "\u{1}?setBlendMode@SkPaint@@QEAAXW4SkBlendMode@@@Z"] pub fn SkPaint_setBlendMode (this : * mut SkPaint , mode : SkBlendMode) ; } extern "C" { # [link_name = "\u{1}?refBlender@SkPaint@@QEBA?AV?$sk_sp@VSkBlender@@@@XZ"] pub fn SkPaint_refBlender (this : * const SkPaint) -> sk_sp < SkBlender > ; } extern "C" { # [link_name = "\u{1}?setBlender@SkPaint@@QEAAXV?$sk_sp@VSkBlender@@@@@Z"] pub fn SkPaint_setBlender (this : * mut SkPaint , blender : sk_sp < SkBlender >) ; } extern "C" { # [link_name = "\u{1}?refPathEffect@SkPaint@@QEBA?AV?$sk_sp@VSkPathEffect@@@@XZ"] pub fn SkPaint_refPathEffect (this : * const SkPaint) -> sk_sp < SkPathEffect > ; } extern "C" { # [link_name = "\u{1}?setPathEffect@SkPaint@@QEAAXV?$sk_sp@VSkPathEffect@@@@@Z"] pub fn SkPaint_setPathEffect (this : * mut SkPaint , pathEffect : sk_sp < SkPathEffect >) ; } extern "C" { # [link_name = "\u{1}?refMaskFilter@SkPaint@@QEBA?AV?$sk_sp@VSkMaskFilter@@@@XZ"] pub fn SkPaint_refMaskFilter (this : * const SkPaint) -> sk_sp < SkMaskFilter > ; } extern "C" { # [link_name = "\u{1}?setMaskFilter@SkPaint@@QEAAXV?$sk_sp@VSkMaskFilter@@@@@Z"] pub fn SkPaint_setMaskFilter (this : * mut SkPaint , maskFilter : sk_sp < SkMaskFilter >) ; } extern "C" { # [link_name = "\u{1}?refImageFilter@SkPaint@@QEBA?AV?$sk_sp@VSkImageFilter@@@@XZ"] pub fn SkPaint_refImageFilter (this : * const SkPaint) -> sk_sp < SkImageFilter > ; } extern "C" { # [link_name = "\u{1}?setImageFilter@SkPaint@@QEAAXV?$sk_sp@VSkImageFilter@@@@@Z"] pub fn SkPaint_setImageFilter (this : * mut SkPaint , imageFilter : sk_sp < SkImageFilter >) ; } extern "C" { # [link_name = "\u{1}?nothingToDraw@SkPaint@@QEBA_NXZ"] pub fn SkPaint_nothingToDraw (this : * const SkPaint) -> bool ; } extern "C" { # [link_name = "\u{1}?canComputeFastBounds@SkPaint@@QEBA_NXZ"] pub fn SkPaint_canComputeFastBounds (this : * const SkPaint) -> bool ; } extern "C" { # [link_name = "\u{1}?computeFastBounds@SkPaint@@QEBAAEBUSkRect@@AEBU2@PEAU2@@Z"] pub fn SkPaint_computeFastBounds (this : * const SkPaint , orig : * const SkRect , storage : * mut SkRect) -> * const SkRect ; } extern "C" { # [link_name = "\u{1}?doComputeFastBounds@SkPaint@@QEBAAEBUSkRect@@AEBU2@PEAU2@W4Style@1@@Z"] pub fn SkPaint_doComputeFastBounds (this : * const SkPaint , orig : * const SkRect , storage : * mut SkRect , style : SkPaint_Style) -> * const SkRect ; } extern "C" { # [link_name = "\u{1}??0SkPaint@@QEAA@XZ"] pub fn SkPaint_SkPaint (this : * mut SkPaint) ; } extern "C" { # [link_name = "\u{1}??0SkPaint@@QEAA@AEBU?$SkRGBA4f@$02@@PEAVSkColorSpace@@@Z"] pub fn SkPaint_SkPaint1 (this : * mut SkPaint , color : * const SkColor4f , colorSpace : * mut SkColorSpace) ; } extern "C" { # [link_name = "\u{1}??0SkPaint@@QEAA@AEBV0@@Z"] pub fn SkPaint_SkPaint2 (this : * mut SkPaint , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}??0SkPaint@@QEAA@$$QEAV0@@Z"] pub fn SkPaint_SkPaint3 (this : * mut SkPaint , paint : * mut SkPaint) ; } impl SkPaint { # [inline] pub unsafe fn reset (& mut self) { SkPaint_reset (self) } # [inline] pub unsafe fn setStyle (& mut self , style : SkPaint_Style) { SkPaint_setStyle (self , style) } # [inline] pub unsafe fn setStroke (& mut self , arg1 : bool) { SkPaint_setStroke (self , arg1) } # [inline] pub unsafe fn setColor (& mut self , color : SkColor) { SkPaint_setColor (self , color) } # [inline] pub unsafe fn setColor1 (& mut self , color : * const SkColor4f , colorSpace : * mut SkColorSpace) { SkPaint_setColor1 (self , color , colorSpace) } # [inline] pub unsafe fn setAlphaf (& mut self , a : f32) { SkPaint_setAlphaf (self , a) } # [inline] pub unsafe fn setARGB (& mut self , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU) { SkPaint_setARGB (self , a , r , g , b) } # [inline] pub unsafe fn setStrokeWidth (& mut self , width : SkScalar) { SkPaint_setStrokeWidth (self , width) } # [inline] pub unsafe fn setStrokeMiter (& mut self , miter : SkScalar) { SkPaint_setStrokeMiter (self , miter) } # [inline] pub unsafe fn setStrokeCap (& mut self , cap : SkPaint_Cap) { SkPaint_setStrokeCap (self , cap) } # [inline] pub unsafe fn setStrokeJoin (& mut self , join : SkPaint_Join) { SkPaint_setStrokeJoin (self , join) } # [inline] pub unsafe fn getFillPath (& self , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , resScale : SkScalar) -> bool { SkPaint_getFillPath (self , src , dst , cullRect , resScale) } # [inline] pub unsafe fn getFillPath1 (& self , src : * const SkPath , dst : * mut SkPath , cullRect : * const SkRect , ctm : * const SkMatrix) -> bool { SkPaint_getFillPath1 (self , src , dst , cullRect , ctm) } # [inline] pub unsafe fn refShader (& self) -> sk_sp < SkShader > { SkPaint_refShader (self) } # [inline] pub unsafe fn setShader (& mut self , shader : sk_sp < SkShader >) { SkPaint_setShader (self , shader) } # [inline] pub unsafe fn refColorFilter (& self) -> sk_sp < SkColorFilter > { SkPaint_refColorFilter (self) } # [inline] pub unsafe fn setColorFilter (& mut self , colorFilter : sk_sp < SkColorFilter >) { SkPaint_setColorFilter (self , colorFilter) } # [inline] pub unsafe fn asBlendMode (& self) -> [u32 ; 2usize] { SkPaint_asBlendMode (self) } # [inline] pub unsafe fn getBlendMode_or (& self , defaultMode : SkBlendMode) -> SkBlendMode { SkPaint_getBlendMode_or (self , defaultMode) } # [inline] pub unsafe fn isSrcOver (& self) -> bool { SkPaint_isSrcOver (self) } # [inline] pub unsafe fn setBlendMode (& mut self , mode : SkBlendMode) { SkPaint_setBlendMode (self , mode) } # [inline] pub unsafe fn refBlender (& self) -> sk_sp < SkBlender > { SkPaint_refBlender (self) } # [inline] pub unsafe fn setBlender (& mut self , blender : sk_sp < SkBlender >) { SkPaint_setBlender (self , blender) } # [inline] pub unsafe fn refPathEffect (& self) -> sk_sp < SkPathEffect > { SkPaint_refPathEffect (self) } # [inline] pub unsafe fn setPathEffect (& mut self , pathEffect : sk_sp < SkPathEffect >) { SkPaint_setPathEffect (self , pathEffect) } # [inline] pub unsafe fn refMaskFilter (& self) -> sk_sp < SkMaskFilter > { SkPaint_refMaskFilter (self) } # [inline] pub unsafe fn setMaskFilter (& mut self , maskFilter : sk_sp < SkMaskFilter >) { SkPaint_setMaskFilter (self , maskFilter) } # [inline] pub unsafe fn refImageFilter (& self) -> sk_sp < SkImageFilter > { SkPaint_refImageFilter (self) } # [inline] pub unsafe fn setImageFilter (& mut self , imageFilter : sk_sp < SkImageFilter >) { SkPaint_setImageFilter (self , imageFilter) } # [inline] pub unsafe fn nothingToDraw (& self) -> bool { SkPaint_nothingToDraw (self) } # [inline] pub unsafe fn canComputeFastBounds (& self) -> bool { SkPaint_canComputeFastBounds (self) } # [inline] pub unsafe fn computeFastBounds (& self , orig : * const SkRect , storage : * mut SkRect) -> * const SkRect { SkPaint_computeFastBounds (self , orig , storage) } # [inline] pub unsafe fn doComputeFastBounds (& self , orig : * const SkRect , storage : * mut SkRect , style : SkPaint_Style) -> * const SkRect { SkPaint_doComputeFastBounds (self , orig , storage , style) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPaint_SkPaint (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (color : * const SkColor4f , colorSpace : * mut SkColorSpace) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPaint_SkPaint1 (__bindgen_tmp . as_mut_ptr () , color , colorSpace) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (paint : * const SkPaint) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPaint_SkPaint2 (__bindgen_tmp . as_mut_ptr () , paint) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (paint : * mut SkPaint) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPaint_SkPaint3 (__bindgen_tmp . as_mut_ptr () , paint) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkRasterHandleAllocator { pub _bindgen_opaque_blob : u64 , } pub type SkRasterHandleAllocator_Handle = * mut :: core :: ffi :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRasterHandleAllocator_Rec { pub fReleaseProc : :: core :: option :: Option < unsafe extern "C" fn (pixels : * mut :: core :: ffi :: c_void , ctx : * mut :: core :: ffi :: c_void) > , pub fReleaseCtx : * mut :: core :: ffi :: c_void , pub fPixels : * mut :: core :: ffi :: c_void , pub fRowBytes : usize , pub fHandle : SkRasterHandleAllocator_Handle , } # [test] fn bindgen_test_layout_SkRasterHandleAllocator_Rec () { assert_eq ! (:: core :: mem :: size_of :: < SkRasterHandleAllocator_Rec > () , 40usize , concat ! ("Size of: " , stringify ! (SkRasterHandleAllocator_Rec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRasterHandleAllocator_Rec > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRasterHandleAllocator_Rec))) ; fn test_field_fReleaseProc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRasterHandleAllocator_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReleaseProc) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRasterHandleAllocator_Rec) , "::" , stringify ! (fReleaseProc))) ; } test_field_fReleaseProc () ; fn test_field_fReleaseCtx () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRasterHandleAllocator_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReleaseCtx) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRasterHandleAllocator_Rec) , "::" , stringify ! (fReleaseCtx))) ; } test_field_fReleaseCtx () ; fn test_field_fPixels () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRasterHandleAllocator_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPixels) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRasterHandleAllocator_Rec) , "::" , stringify ! (fPixels))) ; } test_field_fPixels () ; fn test_field_fRowBytes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRasterHandleAllocator_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRowBytes) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkRasterHandleAllocator_Rec) , "::" , stringify ! (fRowBytes))) ; } test_field_fRowBytes () ; fn test_field_fHandle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRasterHandleAllocator_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHandle) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkRasterHandleAllocator_Rec) , "::" , stringify ! (fHandle))) ; } test_field_fHandle () ; } # [test] fn bindgen_test_layout_SkRasterHandleAllocator () { assert_eq ! (:: core :: mem :: size_of :: < SkRasterHandleAllocator > () , 8usize , concat ! ("Size of: " , stringify ! (SkRasterHandleAllocator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRasterHandleAllocator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRasterHandleAllocator))) ; } extern "C" { # [link_name = "\u{1}?MakeCanvas@SkRasterHandleAllocator@@SA?AV?$unique_ptr@VSkCanvas@@U?$default_delete@VSkCanvas@@@std@@@std@@V?$unique_ptr@VSkRasterHandleAllocator@@U?$default_delete@VSkRasterHandleAllocator@@@std@@@3@AEBUSkImageInfo@@PEBURec@1@PEBVSkSurfaceProps@@@Z"] pub fn SkRasterHandleAllocator_MakeCanvas (arg1 : u64 , arg2 : * const SkImageInfo , rec : * const SkRasterHandleAllocator_Rec , props : * const SkSurfaceProps) -> u64 ; } impl SkRasterHandleAllocator { # [inline] pub unsafe fn MakeCanvas (arg1 : u64 , arg2 : * const SkImageInfo , rec : * const SkRasterHandleAllocator_Rec , props : * const SkSurfaceProps) -> u64 { SkRasterHandleAllocator_MakeCanvas (arg1 , arg2 , rec , props) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPixelGeometry { kUnknown_SkPixelGeometry = 0 , kRGB_H_SkPixelGeometry = 1 , kBGR_H_SkPixelGeometry = 2 , kRGB_V_SkPixelGeometry = 3 , kBGR_V_SkPixelGeometry = 4 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSurfaceProps { pub fFlags : u32 , pub fPixelGeometry : SkPixelGeometry , } pub const SkSurfaceProps_Flags_kUseDeviceIndependentFonts_Flag : SkSurfaceProps_Flags = 1 ; pub const SkSurfaceProps_Flags_kDynamicMSAA_Flag : SkSurfaceProps_Flags = 2 ; pub type SkSurfaceProps_Flags = :: std :: os :: raw :: c_int ; extern "C" { # [link_name = "\u{1}?kUseDistanceFieldFonts_Flag@SkSurfaceProps@@2W4Flags@1@B"] pub static SkSurfaceProps_kUseDistanceFieldFonts_Flag : SkSurfaceProps_Flags ; } # [test] fn bindgen_test_layout_SkSurfaceProps () { assert_eq ! (:: core :: mem :: size_of :: < SkSurfaceProps > () , 8usize , concat ! ("Size of: " , stringify ! (SkSurfaceProps))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSurfaceProps > () , 4usize , concat ! ("Alignment of " , stringify ! (SkSurfaceProps))) ; fn test_field_fFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceProps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFlags) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceProps) , "::" , stringify ! (fFlags))) ; } test_field_fFlags () ; fn test_field_fPixelGeometry () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceProps > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPixelGeometry) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceProps) , "::" , stringify ! (fPixelGeometry))) ; } test_field_fPixelGeometry () ; } extern "C" { # [link_name = "\u{1}??0SkSurfaceProps@@QEAA@XZ"] pub fn SkSurfaceProps_SkSurfaceProps (this : * mut SkSurfaceProps) ; } extern "C" { # [link_name = "\u{1}??0SkSurfaceProps@@QEAA@IW4SkPixelGeometry@@@Z"] pub fn SkSurfaceProps_SkSurfaceProps1 (this : * mut SkSurfaceProps , flags : u32 , arg1 : SkPixelGeometry) ; } extern "C" { # [link_name = "\u{1}??0SkSurfaceProps@@QEAA@AEBV0@@Z"] pub fn SkSurfaceProps_SkSurfaceProps2 (this : * mut SkSurfaceProps , arg1 : * const SkSurfaceProps) ; } impl SkSurfaceProps { # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkSurfaceProps_SkSurfaceProps (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (flags : u32 , arg1 : SkPixelGeometry) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkSurfaceProps_SkSurfaceProps1 (__bindgen_tmp . as_mut_ptr () , flags , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (arg1 : * const SkSurfaceProps) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkSurfaceProps_SkSurfaceProps2 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDeque { pub _bindgen_opaque_blob : [u64 ; 7usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDeque_Block { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDeque_Iter { pub _bindgen_opaque_blob : [u64 ; 3usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkDeque_Iter_IterStart { kFront_IterStart = 0 , kBack_IterStart = 1 , } # [test] fn bindgen_test_layout_SkDeque_Iter () { assert_eq ! (:: core :: mem :: size_of :: < SkDeque_Iter > () , 24usize , concat ! ("Size of: " , stringify ! (SkDeque_Iter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeque_Iter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeque_Iter))) ; } extern "C" { # [link_name = "\u{1}?next@Iter@SkDeque@@QEAAPEAXXZ"] pub fn SkDeque_Iter_next (this : * mut SkDeque_Iter) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?prev@Iter@SkDeque@@QEAAPEAXXZ"] pub fn SkDeque_Iter_prev (this : * mut SkDeque_Iter) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?reset@Iter@SkDeque@@QEAAXAEBV2@W4IterStart@12@@Z"] pub fn SkDeque_Iter_reset (this : * mut SkDeque_Iter , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart) ; } extern "C" { # [link_name = "\u{1}??0Iter@SkDeque@@QEAA@XZ"] pub fn SkDeque_Iter_Iter (this : * mut SkDeque_Iter) ; } extern "C" { # [link_name = "\u{1}??0Iter@SkDeque@@QEAA@AEBV1@W4IterStart@01@@Z"] pub fn SkDeque_Iter_Iter1 (this : * mut SkDeque_Iter , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart) ; } impl SkDeque_Iter { # [inline] pub unsafe fn next (& mut self) -> * mut :: core :: ffi :: c_void { SkDeque_Iter_next (self) } # [inline] pub unsafe fn prev (& mut self) -> * mut :: core :: ffi :: c_void { SkDeque_Iter_prev (self) } # [inline] pub unsafe fn reset (& mut self , d : * const SkDeque , startLoc : SkDeque_Iter_IterStart) { SkDeque_Iter_reset (self , d , startLoc) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeque_Iter_Iter (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (d : * const SkDeque , startLoc : SkDeque_Iter_IterStart) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeque_Iter_Iter1 (__bindgen_tmp . as_mut_ptr () , d , startLoc) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDeque_F2BIter { pub _bindgen_opaque_blob : [u64 ; 3usize] , } pub type SkDeque_F2BIter_INHERITED = SkDeque_Iter ; # [test] fn bindgen_test_layout_SkDeque_F2BIter () { assert_eq ! (:: core :: mem :: size_of :: < SkDeque_F2BIter > () , 24usize , concat ! ("Size of: " , stringify ! (SkDeque_F2BIter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeque_F2BIter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeque_F2BIter))) ; } # [test] fn bindgen_test_layout_SkDeque () { assert_eq ! (:: core :: mem :: size_of :: < SkDeque > () , 56usize , concat ! ("Size of: " , stringify ! (SkDeque))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeque > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeque))) ; } extern "C" { # [link_name = "\u{1}?push_front@SkDeque@@QEAAPEAXXZ"] pub fn SkDeque_push_front (this : * mut SkDeque) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?push_back@SkDeque@@QEAAPEAXXZ"] pub fn SkDeque_push_back (this : * mut SkDeque) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?pop_front@SkDeque@@QEAAXXZ"] pub fn SkDeque_pop_front (this : * mut SkDeque) ; } extern "C" { # [link_name = "\u{1}?pop_back@SkDeque@@QEAAXXZ"] pub fn SkDeque_pop_back (this : * mut SkDeque) ; } extern "C" { # [link_name = "\u{1}??0SkDeque@@QEAA@_KH@Z"] pub fn SkDeque_SkDeque (this : * mut SkDeque , elemSize : usize , allocCount : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}??0SkDeque@@QEAA@_KPEAX0H@Z"] pub fn SkDeque_SkDeque1 (this : * mut SkDeque , elemSize : usize , storage : * mut :: core :: ffi :: c_void , storageSize : usize , allocCount : :: std :: os :: raw :: c_int) ; } impl SkDeque { # [inline] pub unsafe fn push_front (& mut self) -> * mut :: core :: ffi :: c_void { SkDeque_push_front (self) } # [inline] pub unsafe fn push_back (& mut self) -> * mut :: core :: ffi :: c_void { SkDeque_push_back (self) } # [inline] pub unsafe fn pop_front (& mut self) { SkDeque_pop_front (self) } # [inline] pub unsafe fn pop_back (& mut self) { SkDeque_pop_back (self) } # [inline] pub unsafe fn new (elemSize : usize , allocCount : :: std :: os :: raw :: c_int) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeque_SkDeque (__bindgen_tmp . as_mut_ptr () , elemSize , allocCount) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (elemSize : usize , storage : * mut :: core :: ffi :: c_void , storageSize : usize , allocCount : :: std :: os :: raw :: c_int) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeque_SkDeque1 (__bindgen_tmp . as_mut_ptr () , elemSize , storage , storageSize , allocCount) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sktext_GlyphRunBuilder { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sktext_GlyphRunList { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sktext_gpu_Slug { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sktext_gpu_TextBlobRedrawCoordinator { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct sktext_gpu_SubRunAllocator { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkBaseDevice { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDrawShadowRec { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkMesh { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSpecialImage { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSurface_Base { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skgpu_graphite_Recorder { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skgpu_SingleOwner { pub _address : u8 , } # [test] fn bindgen_test_layout_skgpu_SingleOwner () { assert_eq ! (:: core :: mem :: size_of :: < skgpu_SingleOwner > () , 1usize , concat ! ("Size of: " , stringify ! (skgpu_SingleOwner))) ; assert_eq ! (:: core :: mem :: align_of :: < skgpu_SingleOwner > () , 1usize , concat ! ("Alignment of " , stringify ! (skgpu_SingleOwner))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skgpu_v1_SmallPathAtlasMgr { _unused : [u8 ; 0] , } # [repr (C)] pub struct SkCanvas__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] # [derive (Debug)] pub struct SkCanvas { pub vtable_ : * const SkCanvas__bindgen_vtable , pub fMCRecStorage : [isize ; 384usize] , pub fMCStack : SkDeque , pub fMCRec : * mut SkCanvas_MCRec , pub fBaseDevice : sk_sp < SkBaseDevice > , pub fProps : SkSurfaceProps , pub fSaveCount : :: std :: os :: raw :: c_int , pub fAllocator : u64 , pub fSurfaceBase : * mut SkSurface_Base , pub fClipRestrictionRect : SkIRect , pub fClipRestrictionSaveCount : :: std :: os :: raw :: c_int , pub fQuickRejectBounds : SkRect , pub fScratchGlyphRunBuilder : u64 , } pub const SkCanvas_SaveLayerFlagsSet_kPreserveLCDText_SaveLayerFlag : SkCanvas_SaveLayerFlagsSet = 2 ; pub const SkCanvas_SaveLayerFlagsSet_kInitWithPrevious_SaveLayerFlag : SkCanvas_SaveLayerFlagsSet = 4 ; pub const SkCanvas_SaveLayerFlagsSet_kF16ColorType : SkCanvas_SaveLayerFlagsSet = 16 ; pub type SkCanvas_SaveLayerFlagsSet = :: std :: os :: raw :: c_int ; pub type SkCanvas_SaveLayerFlags = u32 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCanvas_SaveLayerRec { pub fBounds : * const SkRect , pub fPaint : * const SkPaint , pub fBackdrop : * const SkImageFilter , pub fSaveLayerFlags : SkCanvas_SaveLayerFlags , pub fExperimentalBackdropScale : SkScalar , } # [test] fn bindgen_test_layout_SkCanvas_SaveLayerRec () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_SaveLayerRec > () , 32usize , concat ! ("Size of: " , stringify ! (SkCanvas_SaveLayerRec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_SaveLayerRec > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_SaveLayerRec))) ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_SaveLayerRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_SaveLayerRec) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fPaint () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_SaveLayerRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaint) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_SaveLayerRec) , "::" , stringify ! (fPaint))) ; } test_field_fPaint () ; fn test_field_fBackdrop () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_SaveLayerRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackdrop) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_SaveLayerRec) , "::" , stringify ! (fBackdrop))) ; } test_field_fBackdrop () ; fn test_field_fSaveLayerFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_SaveLayerRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSaveLayerFlags) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_SaveLayerRec) , "::" , stringify ! (fSaveLayerFlags))) ; } test_field_fSaveLayerFlags () ; fn test_field_fExperimentalBackdropScale () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_SaveLayerRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExperimentalBackdropScale) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_SaveLayerRec) , "::" , stringify ! (fExperimentalBackdropScale))) ; } test_field_fExperimentalBackdropScale () ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_PointMode { Points = 0 , Lines = 1 , Polygon = 2 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_SrcRectConstraint { Strict = 0 , Fast = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCanvas_Lattice { pub fXDivs : * const :: std :: os :: raw :: c_int , pub fYDivs : * const :: std :: os :: raw :: c_int , pub fRectTypes : * const SkCanvas_Lattice_RectType , pub fXCount : :: std :: os :: raw :: c_int , pub fYCount : :: std :: os :: raw :: c_int , pub fBounds : * const SkIRect , pub fColors : * const SkColor , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_Lattice_RectType { Default = 0 , Transparent = 1 , FixedColor = 2 , } # [test] fn bindgen_test_layout_SkCanvas_Lattice () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_Lattice > () , 48usize , concat ! ("Size of: " , stringify ! (SkCanvas_Lattice))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_Lattice > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_Lattice))) ; fn test_field_fXDivs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXDivs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fXDivs))) ; } test_field_fXDivs () ; fn test_field_fYDivs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYDivs) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fYDivs))) ; } test_field_fYDivs () ; fn test_field_fRectTypes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRectTypes) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fRectTypes))) ; } test_field_fRectTypes () ; fn test_field_fXCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXCount) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fXCount))) ; } test_field_fXCount () ; fn test_field_fYCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYCount) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fYCount))) ; } test_field_fYCount () ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fColors () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Lattice > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColors) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Lattice) , "::" , stringify ! (fColors))) ; } test_field_fColors () ; } pub const SkCanvas_QuadAAFlags_kLeft_QuadAAFlag : SkCanvas_QuadAAFlags = 1 ; pub const SkCanvas_QuadAAFlags_kTop_QuadAAFlag : SkCanvas_QuadAAFlags = 2 ; pub const SkCanvas_QuadAAFlags_kRight_QuadAAFlag : SkCanvas_QuadAAFlags = 4 ; pub const SkCanvas_QuadAAFlags_kBottom_QuadAAFlag : SkCanvas_QuadAAFlags = 8 ; pub const SkCanvas_QuadAAFlags_kNone_QuadAAFlags : SkCanvas_QuadAAFlags = 0 ; pub const SkCanvas_QuadAAFlags_kAll_QuadAAFlags : SkCanvas_QuadAAFlags = 15 ; pub type SkCanvas_QuadAAFlags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug)] pub struct SkCanvas_ImageSetEntry { pub fImage : sk_sp < SkImage > , pub fSrcRect : SkRect , pub fDstRect : SkRect , pub fMatrixIndex : :: std :: os :: raw :: c_int , pub fAlpha : f32 , pub fAAFlags : :: std :: os :: raw :: c_uint , pub fHasClip : bool , } # [test] fn bindgen_test_layout_SkCanvas_ImageSetEntry () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_ImageSetEntry > () , 56usize , concat ! ("Size of: " , stringify ! (SkCanvas_ImageSetEntry))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_ImageSetEntry > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_ImageSetEntry))) ; fn test_field_fImage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImage) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fImage))) ; } test_field_fImage () ; fn test_field_fSrcRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSrcRect) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fSrcRect))) ; } test_field_fSrcRect () ; fn test_field_fDstRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDstRect) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fDstRect))) ; } test_field_fDstRect () ; fn test_field_fMatrixIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMatrixIndex) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fMatrixIndex))) ; } test_field_fMatrixIndex () ; fn test_field_fAlpha () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlpha) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fAlpha))) ; } test_field_fAlpha () ; fn test_field_fAAFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAAFlags) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fAAFlags))) ; } test_field_fAAFlags () ; fn test_field_fHasClip () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_ImageSetEntry > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHasClip) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_ImageSetEntry) , "::" , stringify ! (fHasClip))) ; } test_field_fHasClip () ; } extern "C" { # [link_name = "\u{1}??0ImageSetEntry@SkCanvas@@QEAA@V?$sk_sp@$$CBVSkImage@@@@AEBUSkRect@@1HMI_N@Z"] pub fn SkCanvas_ImageSetEntry_ImageSetEntry (this : * mut SkCanvas_ImageSetEntry , image : sk_sp < SkImage > , srcRect : * const SkRect , dstRect : * const SkRect , matrixIndex : :: std :: os :: raw :: c_int , alpha : f32 , aaFlags : :: std :: os :: raw :: c_uint , hasClip : bool) ; } extern "C" { # [link_name = "\u{1}??0ImageSetEntry@SkCanvas@@QEAA@V?$sk_sp@$$CBVSkImage@@@@AEBUSkRect@@1MI@Z"] pub fn SkCanvas_ImageSetEntry_ImageSetEntry1 (this : * mut SkCanvas_ImageSetEntry , image : sk_sp < SkImage > , srcRect : * const SkRect , dstRect : * const SkRect , alpha : f32 , aaFlags : :: std :: os :: raw :: c_uint) ; } extern "C" { # [link_name = "\u{1}??0ImageSetEntry@SkCanvas@@QEAA@XZ"] pub fn SkCanvas_ImageSetEntry_ImageSetEntry2 (this : * mut SkCanvas_ImageSetEntry) ; } extern "C" { # [link_name = "\u{1}??0ImageSetEntry@SkCanvas@@QEAA@AEBU01@@Z"] pub fn SkCanvas_ImageSetEntry_ImageSetEntry3 (this : * mut SkCanvas_ImageSetEntry , arg1 : * const SkCanvas_ImageSetEntry) ; } impl SkCanvas_ImageSetEntry { # [inline] pub unsafe fn new (image : sk_sp < SkImage > , srcRect : * const SkRect , dstRect : * const SkRect , matrixIndex : :: std :: os :: raw :: c_int , alpha : f32 , aaFlags : :: std :: os :: raw :: c_uint , hasClip : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_ImageSetEntry_ImageSetEntry (__bindgen_tmp . as_mut_ptr () , image , srcRect , dstRect , matrixIndex , alpha , aaFlags , hasClip) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (image : sk_sp < SkImage > , srcRect : * const SkRect , dstRect : * const SkRect , alpha : f32 , aaFlags : :: std :: os :: raw :: c_uint) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_ImageSetEntry_ImageSetEntry1 (__bindgen_tmp . as_mut_ptr () , image , srcRect , dstRect , alpha , aaFlags) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_ImageSetEntry_ImageSetEntry2 (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (arg1 : * const SkCanvas_ImageSetEntry) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_ImageSetEntry_ImageSetEntry3 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_SaveLayerStrategy { kFullLayer_SaveLayerStrategy = 0 , kNoLayer_SaveLayerStrategy = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_ClipEdgeStyle { kHard_ClipEdgeStyle = 0 , kSoft_ClipEdgeStyle = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_ShaderOverrideOpacity { kNone_ShaderOverrideOpacity = 0 , kOpaque_ShaderOverrideOpacity = 1 , kNotOpaque_ShaderOverrideOpacity = 2 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_CheckForOverwrite { kNo = 0 , kYes = 1 , } # [repr (C)] pub struct SkCanvas_Layer { pub fDevice : sk_sp < SkBaseDevice > , pub fImageFilter : sk_sp < SkImageFilter > , pub fPaint : SkPaint , pub fDiscard : bool , } # [test] fn bindgen_test_layout_SkCanvas_Layer () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_Layer > () , 104usize , concat ! ("Size of: " , stringify ! (SkCanvas_Layer))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_Layer > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_Layer))) ; fn test_field_fDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Layer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDevice) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Layer) , "::" , stringify ! (fDevice))) ; } test_field_fDevice () ; fn test_field_fImageFilter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Layer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageFilter) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Layer) , "::" , stringify ! (fImageFilter))) ; } test_field_fImageFilter () ; fn test_field_fPaint () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Layer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaint) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Layer) , "::" , stringify ! (fPaint))) ; } test_field_fPaint () ; fn test_field_fDiscard () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_Layer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDiscard) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_Layer) , "::" , stringify ! (fDiscard))) ; } test_field_fDiscard () ; } extern "C" { # [link_name = "\u{1}??0Layer@SkCanvas@@QEAA@V?$sk_sp@VSkBaseDevice@@@@V?$sk_sp@VSkImageFilter@@@@AEBVSkPaint@@@Z"] pub fn SkCanvas_Layer_Layer (this : * mut SkCanvas_Layer , device : sk_sp < SkBaseDevice > , imageFilter : sk_sp < SkImageFilter > , paint : * const SkPaint) ; } impl SkCanvas_Layer { # [inline] pub unsafe fn new (device : sk_sp < SkBaseDevice > , imageFilter : sk_sp < SkImageFilter > , paint : * const SkPaint) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_Layer_Layer (__bindgen_tmp . as_mut_ptr () , device , imageFilter , paint) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkCanvas_BackImage { pub fImage : sk_sp < SkSpecialImage > , pub fLoc : SkIPoint , } # [test] fn bindgen_test_layout_SkCanvas_BackImage () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_BackImage > () , 16usize , concat ! ("Size of: " , stringify ! (SkCanvas_BackImage))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_BackImage > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_BackImage))) ; fn test_field_fImage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_BackImage > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImage) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_BackImage) , "::" , stringify ! (fImage))) ; } test_field_fImage () ; fn test_field_fLoc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_BackImage > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLoc) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_BackImage) , "::" , stringify ! (fLoc))) ; } test_field_fLoc () ; } # [repr (C)] # [derive (Debug)] pub struct SkCanvas_MCRec { pub fLayer : u64 , pub fDevice : * mut SkBaseDevice , pub fBackImage : u64 , pub fMatrix : SkM44 , pub fDeferredSaveCount : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_SkCanvas_MCRec () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas_MCRec > () , 96usize , concat ! ("Size of: " , stringify ! (SkCanvas_MCRec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas_MCRec > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas_MCRec))) ; fn test_field_fLayer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_MCRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLayer) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_MCRec) , "::" , stringify ! (fLayer))) ; } test_field_fLayer () ; fn test_field_fDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_MCRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDevice) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_MCRec) , "::" , stringify ! (fDevice))) ; } test_field_fDevice () ; fn test_field_fBackImage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_MCRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackImage) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_MCRec) , "::" , stringify ! (fBackImage))) ; } test_field_fBackImage () ; fn test_field_fMatrix () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_MCRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMatrix) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_MCRec) , "::" , stringify ! (fMatrix))) ; } test_field_fMatrix () ; fn test_field_fDeferredSaveCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas_MCRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDeferredSaveCount) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkCanvas_MCRec) , "::" , stringify ! (fDeferredSaveCount))) ; } test_field_fDeferredSaveCount () ; } extern "C" { # [link_name = "\u{1}?newLayer@MCRec@SkCanvas@@QEAAXV?$sk_sp@VSkBaseDevice@@@@V?$sk_sp@VSkImageFilter@@@@AEBVSkPaint@@@Z"] pub fn SkCanvas_MCRec_newLayer (this : * mut SkCanvas_MCRec , layerDevice : sk_sp < SkBaseDevice > , filter : sk_sp < SkImageFilter > , restorePaint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?reset@MCRec@SkCanvas@@QEAAXPEAVSkBaseDevice@@@Z"] pub fn SkCanvas_MCRec_reset (this : * mut SkCanvas_MCRec , device : * mut SkBaseDevice) ; } extern "C" { # [link_name = "\u{1}??0MCRec@SkCanvas@@QEAA@PEAVSkBaseDevice@@@Z"] pub fn SkCanvas_MCRec_MCRec (this : * mut SkCanvas_MCRec , device : * mut SkBaseDevice) ; } extern "C" { # [link_name = "\u{1}??0MCRec@SkCanvas@@QEAA@PEBV01@@Z"] pub fn SkCanvas_MCRec_MCRec1 (this : * mut SkCanvas_MCRec , prev : * const SkCanvas_MCRec) ; } impl SkCanvas_MCRec { # [inline] pub unsafe fn newLayer (& mut self , layerDevice : sk_sp < SkBaseDevice > , filter : sk_sp < SkImageFilter > , restorePaint : * const SkPaint) { SkCanvas_MCRec_newLayer (self , layerDevice , filter , restorePaint) } # [inline] pub unsafe fn reset (& mut self , device : * mut SkBaseDevice) { SkCanvas_MCRec_reset (self , device) } # [inline] pub unsafe fn new (device : * mut SkBaseDevice) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_MCRec_MCRec (__bindgen_tmp . as_mut_ptr () , device) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (prev : * const SkCanvas_MCRec) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_MCRec_MCRec1 (__bindgen_tmp . as_mut_ptr () , prev) ; __bindgen_tmp . assume_init () } } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCanvas_DeviceCompatibleWithFilter { kUnknown = 0 , kYes = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCanvas_AutoUpdateQRBounds { _unused : [u8 ; 0] , } pub type SkCanvas_INHERITED = SkRefCnt ; pub const SkCanvas_kMCRecSize : :: std :: os :: raw :: c_int = 96 ; pub const SkCanvas_kMCRecCount : :: std :: os :: raw :: c_int = 32 ; # [test] fn bindgen_test_layout_SkCanvas () { assert_eq ! (:: core :: mem :: size_of :: < SkCanvas > () , 3232usize , concat ! ("Size of: " , stringify ! (SkCanvas))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCanvas > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCanvas))) ; fn test_field_fMCRecStorage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMCRecStorage) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fMCRecStorage))) ; } test_field_fMCRecStorage () ; fn test_field_fMCStack () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMCStack) as usize - ptr as usize } , 3080usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fMCStack))) ; } test_field_fMCStack () ; fn test_field_fMCRec () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMCRec) as usize - ptr as usize } , 3136usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fMCRec))) ; } test_field_fMCRec () ; fn test_field_fBaseDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBaseDevice) as usize - ptr as usize } , 3144usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fBaseDevice))) ; } test_field_fBaseDevice () ; fn test_field_fProps () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProps) as usize - ptr as usize } , 3152usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fProps))) ; } test_field_fProps () ; fn test_field_fSaveCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSaveCount) as usize - ptr as usize } , 3160usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fSaveCount))) ; } test_field_fSaveCount () ; fn test_field_fAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAllocator) as usize - ptr as usize } , 3168usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fAllocator))) ; } test_field_fAllocator () ; fn test_field_fSurfaceBase () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSurfaceBase) as usize - ptr as usize } , 3176usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fSurfaceBase))) ; } test_field_fSurfaceBase () ; fn test_field_fClipRestrictionRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fClipRestrictionRect) as usize - ptr as usize } , 3184usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fClipRestrictionRect))) ; } test_field_fClipRestrictionRect () ; fn test_field_fClipRestrictionSaveCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fClipRestrictionSaveCount) as usize - ptr as usize } , 3200usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fClipRestrictionSaveCount))) ; } test_field_fClipRestrictionSaveCount () ; fn test_field_fQuickRejectBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fQuickRejectBounds) as usize - ptr as usize } , 3204usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fQuickRejectBounds))) ; } test_field_fQuickRejectBounds () ; fn test_field_fScratchGlyphRunBuilder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCanvas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fScratchGlyphRunBuilder) as usize - ptr as usize } , 3224usize , concat ! ("Offset of field: " , stringify ! (SkCanvas) , "::" , stringify ! (fScratchGlyphRunBuilder))) ; } test_field_fScratchGlyphRunBuilder () ; } extern "C" { # [link_name = "\u{1}?MakeRasterDirect@SkCanvas@@SA?AV?$unique_ptr@VSkCanvas@@U?$default_delete@VSkCanvas@@@std@@@std@@AEBUSkImageInfo@@PEAX_KPEBVSkSurfaceProps@@@Z"] pub fn SkCanvas_MakeRasterDirect (info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , props : * const SkSurfaceProps) -> u64 ; } extern "C" { # [link_name = "\u{1}?imageInfo@SkCanvas@@QEBA?AUSkImageInfo@@XZ"] pub fn SkCanvas_imageInfo (this : * const SkCanvas) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?getProps@SkCanvas@@QEBA_NPEAVSkSurfaceProps@@@Z"] pub fn SkCanvas_getProps (this : * const SkCanvas , props : * mut SkSurfaceProps) -> bool ; } extern "C" { # [link_name = "\u{1}?getBaseProps@SkCanvas@@QEBA?AVSkSurfaceProps@@XZ"] pub fn SkCanvas_getBaseProps (this : * const SkCanvas) -> SkSurfaceProps ; } extern "C" { # [link_name = "\u{1}?getTopProps@SkCanvas@@QEBA?AVSkSurfaceProps@@XZ"] pub fn SkCanvas_getTopProps (this : * const SkCanvas) -> SkSurfaceProps ; } extern "C" { # [link_name = "\u{1}?flush@SkCanvas@@QEAAXXZ"] pub fn SkCanvas_flush (this : * mut SkCanvas) ; } extern "C" { # [link_name = "\u{1}?makeSurface@SkCanvas@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"] pub fn SkCanvas_makeSurface (this : * mut SkCanvas , info : * const SkImageInfo , props : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?getSurface@SkCanvas@@QEBAPEAVSkSurface@@XZ"] pub fn SkCanvas_getSurface (this : * const SkCanvas) -> * mut SkSurface ; } extern "C" { # [link_name = "\u{1}?accessTopLayerPixels@SkCanvas@@QEAAPEAXPEAUSkImageInfo@@PEA_KPEAUSkIPoint@@@Z"] pub fn SkCanvas_accessTopLayerPixels (this : * mut SkCanvas , info : * mut SkImageInfo , rowBytes : * mut usize , origin : * mut SkIPoint) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?accessTopRasterHandle@SkCanvas@@QEBAPEAXXZ"] pub fn SkCanvas_accessTopRasterHandle (this : * const SkCanvas) -> SkRasterHandleAllocator_Handle ; } extern "C" { # [link_name = "\u{1}?peekPixels@SkCanvas@@QEAA_NPEAVSkPixmap@@@Z"] pub fn SkCanvas_peekPixels (this : * mut SkCanvas , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"] pub fn SkCanvas_readPixels (this : * mut SkCanvas , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkCanvas@@QEAA_NAEBVSkPixmap@@HH@Z"] pub fn SkCanvas_readPixels1 (this : * mut SkCanvas , pixmap : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkCanvas@@QEAA_NAEBVSkBitmap@@HH@Z"] pub fn SkCanvas_readPixels2 (this : * mut SkCanvas , bitmap : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?writePixels@SkCanvas@@QEAA_NAEBUSkImageInfo@@PEBX_KHH@Z"] pub fn SkCanvas_writePixels (this : * mut SkCanvas , info : * const SkImageInfo , pixels : * const :: core :: ffi :: c_void , rowBytes : usize , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?writePixels@SkCanvas@@QEAA_NAEBVSkBitmap@@HH@Z"] pub fn SkCanvas_writePixels1 (this : * mut SkCanvas , bitmap : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?save@SkCanvas@@QEAAHXZ"] pub fn SkCanvas_save (this : * mut SkCanvas) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?saveLayer@SkCanvas@@QEAAHPEBUSkRect@@PEBVSkPaint@@@Z"] pub fn SkCanvas_saveLayer (this : * mut SkCanvas , bounds : * const SkRect , paint : * const SkPaint) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?saveLayerAlpha@SkCanvas@@QEAAHPEBUSkRect@@I@Z"] pub fn SkCanvas_saveLayerAlpha (this : * mut SkCanvas , bounds : * const SkRect , alpha : U8CPU) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?saveLayer@SkCanvas@@QEAAHAEBUSaveLayerRec@1@@Z"] pub fn SkCanvas_saveLayer1 (this : * mut SkCanvas , layerRec : * const SkCanvas_SaveLayerRec) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?restore@SkCanvas@@QEAAXXZ"] pub fn SkCanvas_restore (this : * mut SkCanvas) ; } extern "C" { # [link_name = "\u{1}?getSaveCount@SkCanvas@@QEBAHXZ"] pub fn SkCanvas_getSaveCount (this : * const SkCanvas) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?restoreToCount@SkCanvas@@QEAAXH@Z"] pub fn SkCanvas_restoreToCount (this : * mut SkCanvas , saveCount : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?translate@SkCanvas@@QEAAXMM@Z"] pub fn SkCanvas_translate (this : * mut SkCanvas , dx : SkScalar , dy : SkScalar) ; } extern "C" { # [link_name = "\u{1}?scale@SkCanvas@@QEAAXMM@Z"] pub fn SkCanvas_scale (this : * mut SkCanvas , sx : SkScalar , sy : SkScalar) ; } extern "C" { # [link_name = "\u{1}?rotate@SkCanvas@@QEAAXM@Z"] pub fn SkCanvas_rotate (this : * mut SkCanvas , degrees : SkScalar) ; } extern "C" { # [link_name = "\u{1}?rotate@SkCanvas@@QEAAXMMM@Z"] pub fn SkCanvas_rotate1 (this : * mut SkCanvas , degrees : SkScalar , px : SkScalar , py : SkScalar) ; } extern "C" { # [link_name = "\u{1}?skew@SkCanvas@@QEAAXMM@Z"] pub fn SkCanvas_skew (this : * mut SkCanvas , sx : SkScalar , sy : SkScalar) ; } extern "C" { # [link_name = "\u{1}?concat@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"] pub fn SkCanvas_concat (this : * mut SkCanvas , matrix : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?concat@SkCanvas@@QEAAXAEBVSkM44@@@Z"] pub fn SkCanvas_concat1 (this : * mut SkCanvas , arg1 : * const SkM44) ; } extern "C" { # [link_name = "\u{1}?setMatrix@SkCanvas@@QEAAXAEBVSkM44@@@Z"] pub fn SkCanvas_setMatrix (this : * mut SkCanvas , matrix : * const SkM44) ; } extern "C" { # [link_name = "\u{1}?setMatrix@SkCanvas@@QEAAXAEBVSkMatrix@@@Z"] pub fn SkCanvas_setMatrix1 (this : * mut SkCanvas , matrix : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?resetMatrix@SkCanvas@@QEAAXXZ"] pub fn SkCanvas_resetMatrix (this : * mut SkCanvas) ; } extern "C" { # [link_name = "\u{1}?clipRect@SkCanvas@@QEAAXAEBUSkRect@@W4SkClipOp@@_N@Z"] pub fn SkCanvas_clipRect (this : * mut SkCanvas , rect : * const SkRect , op : SkClipOp , doAntiAlias : bool) ; } extern "C" { # [link_name = "\u{1}?androidFramework_setDeviceClipRestriction@SkCanvas@@QEAAXAEBUSkIRect@@@Z"] pub fn SkCanvas_androidFramework_setDeviceClipRestriction (this : * mut SkCanvas , rect : * const SkIRect) ; } extern "C" { # [link_name = "\u{1}?clipRRect@SkCanvas@@QEAAXAEBVSkRRect@@W4SkClipOp@@_N@Z"] pub fn SkCanvas_clipRRect (this : * mut SkCanvas , rrect : * const SkRRect , op : SkClipOp , doAntiAlias : bool) ; } extern "C" { # [link_name = "\u{1}?clipPath@SkCanvas@@QEAAXAEBVSkPath@@W4SkClipOp@@_N@Z"] pub fn SkCanvas_clipPath (this : * mut SkCanvas , path : * const SkPath , op : SkClipOp , doAntiAlias : bool) ; } extern "C" { # [link_name = "\u{1}?clipShader@SkCanvas@@QEAAXV?$sk_sp@VSkShader@@@@W4SkClipOp@@@Z"] pub fn SkCanvas_clipShader (this : * mut SkCanvas , arg1 : sk_sp < SkShader > , arg2 : SkClipOp) ; } extern "C" { # [link_name = "\u{1}?clipRegion@SkCanvas@@QEAAXAEBVSkRegion@@W4SkClipOp@@@Z"] pub fn SkCanvas_clipRegion (this : * mut SkCanvas , deviceRgn : * const SkRegion , op : SkClipOp) ; } extern "C" { # [link_name = "\u{1}?quickReject@SkCanvas@@QEBA_NAEBUSkRect@@@Z"] pub fn SkCanvas_quickReject (this : * const SkCanvas , rect : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?quickReject@SkCanvas@@QEBA_NAEBVSkPath@@@Z"] pub fn SkCanvas_quickReject1 (this : * const SkCanvas , path : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?getLocalClipBounds@SkCanvas@@QEBA?AUSkRect@@XZ"] pub fn SkCanvas_getLocalClipBounds (this : * const SkCanvas) -> SkRect ; } extern "C" { # [link_name = "\u{1}?getDeviceClipBounds@SkCanvas@@QEBA?AUSkIRect@@XZ"] pub fn SkCanvas_getDeviceClipBounds (this : * const SkCanvas) -> SkIRect ; } extern "C" { # [link_name = "\u{1}?drawColor@SkCanvas@@QEAAXAEBU?$SkRGBA4f@$02@@W4SkBlendMode@@@Z"] pub fn SkCanvas_drawColor (this : * mut SkCanvas , color : * const SkColor4f , mode : SkBlendMode) ; } extern "C" { # [link_name = "\u{1}?drawPaint@SkCanvas@@QEAAXAEBVSkPaint@@@Z"] pub fn SkCanvas_drawPaint (this : * mut SkCanvas , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawPoints@SkCanvas@@QEAAXW4PointMode@1@_KQEBUSkPoint@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawPoints (this : * mut SkCanvas , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawPoint@SkCanvas@@QEAAXMMAEBVSkPaint@@@Z"] pub fn SkCanvas_drawPoint (this : * mut SkCanvas , x : SkScalar , y : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawLine@SkCanvas@@QEAAXMMMMAEBVSkPaint@@@Z"] pub fn SkCanvas_drawLine (this : * mut SkCanvas , x0 : SkScalar , y0 : SkScalar , x1 : SkScalar , y1 : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawRect@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawRect (this : * mut SkCanvas , rect : * const SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawRegion@SkCanvas@@QEAAXAEBVSkRegion@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawRegion (this : * mut SkCanvas , region : * const SkRegion , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawOval@SkCanvas@@QEAAXAEBUSkRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawOval (this : * mut SkCanvas , oval : * const SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawRRect@SkCanvas@@QEAAXAEBVSkRRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawRRect (this : * mut SkCanvas , rrect : * const SkRRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawDRRect@SkCanvas@@QEAAXAEBVSkRRect@@0AEBVSkPaint@@@Z"] pub fn SkCanvas_drawDRRect (this : * mut SkCanvas , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawCircle@SkCanvas@@QEAAXMMMAEBVSkPaint@@@Z"] pub fn SkCanvas_drawCircle (this : * mut SkCanvas , cx : SkScalar , cy : SkScalar , radius : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawArc@SkCanvas@@QEAAXAEBUSkRect@@MM_NAEBVSkPaint@@@Z"] pub fn SkCanvas_drawArc (this : * mut SkCanvas , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawRoundRect@SkCanvas@@QEAAXAEBUSkRect@@MMAEBVSkPaint@@@Z"] pub fn SkCanvas_drawRoundRect (this : * mut SkCanvas , rect : * const SkRect , rx : SkScalar , ry : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawPath@SkCanvas@@QEAAXAEBVSkPath@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawPath (this : * mut SkCanvas , path : * const SkPath , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawImage@SkCanvas@@QEAAXPEBVSkImage@@MMAEBUSkSamplingOptions@@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawImage (this : * mut SkCanvas , arg1 : * const SkImage , x : SkScalar , y : SkScalar , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@1AEBUSkSamplingOptions@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"] pub fn SkCanvas_drawImageRect (this : * mut SkCanvas , arg1 : * const SkImage , src : * const SkRect , dst : * const SkRect , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint , arg4 : SkCanvas_SrcRectConstraint) ; } extern "C" { # [link_name = "\u{1}?drawImageRect@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkRect@@AEBUSkSamplingOptions@@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawImageRect1 (this : * mut SkCanvas , arg1 : * const SkImage , dst : * const SkRect , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawImageNine@SkCanvas@@QEAAXPEBVSkImage@@AEBUSkIRect@@AEBUSkRect@@W4SkFilterMode@@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawImageNine (this : * mut SkCanvas , image : * const SkImage , center : * const SkIRect , dst : * const SkRect , filter : SkFilterMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawImageLattice@SkCanvas@@QEAAXPEBVSkImage@@AEBULattice@1@AEBUSkRect@@W4SkFilterMode@@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawImageLattice (this : * mut SkCanvas , image : * const SkImage , lattice : * const SkCanvas_Lattice , dst : * const SkRect , filter : SkFilterMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?experimental_DrawEdgeAAQuad@SkCanvas@@QEAAXAEBUSkRect@@QEBUSkPoint@@W4QuadAAFlags@1@AEBU?$SkRGBA4f@$02@@W4SkBlendMode@@@Z"] pub fn SkCanvas_experimental_DrawEdgeAAQuad (this : * mut SkCanvas , rect : * const SkRect , clip : * const SkPoint , aaFlags : SkCanvas_QuadAAFlags , color : * const SkColor4f , mode : SkBlendMode) ; } extern "C" { # [link_name = "\u{1}?experimental_DrawEdgeAAImageSet@SkCanvas@@QEAAXQEBUImageSetEntry@1@HQEBUSkPoint@@QEBVSkMatrix@@AEBUSkSamplingOptions@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"] pub fn SkCanvas_experimental_DrawEdgeAAImageSet (this : * mut SkCanvas , imageSet : * const SkCanvas_ImageSetEntry , cnt : :: std :: os :: raw :: c_int , dstClips : * const SkPoint , preViewMatrices : * const SkMatrix , arg1 : * const SkSamplingOptions , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint) ; } extern "C" { # [link_name = "\u{1}?drawSimpleText@SkCanvas@@QEAAXPEBX_KW4SkTextEncoding@@MMAEBVSkFont@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawSimpleText (this : * mut SkCanvas , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawGlyphs@SkCanvas@@QEAAXHQEBGQEBUSkPoint@@QEBIHQEBDU2@AEBVSkFont@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawGlyphs (this : * mut SkCanvas , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , positions : * const SkPoint , clusters : * const u32 , textByteCount : :: std :: os :: raw :: c_int , utf8text : * const :: std :: os :: raw :: c_char , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawGlyphs@SkCanvas@@QEAAXHQEBGQEBUSkPoint@@U2@AEBVSkFont@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawGlyphs1 (this : * mut SkCanvas , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , positions : * const SkPoint , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawGlyphs@SkCanvas@@QEAAXHQEBGQEBUSkRSXform@@USkPoint@@AEBVSkFont@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawGlyphs2 (this : * mut SkCanvas , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , xforms : * const SkRSXform , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawTextBlob@SkCanvas@@QEAAXPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"] pub fn SkCanvas_drawTextBlob (this : * mut SkCanvas , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawPicture@SkCanvas@@QEAAXPEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawPicture (this : * mut SkCanvas , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawVertices@SkCanvas@@QEAAXPEBVSkVertices@@W4SkBlendMode@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawVertices (this : * mut SkCanvas , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawVertices@SkCanvas@@QEAAXAEBV?$sk_sp@VSkVertices@@@@W4SkBlendMode@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawVertices1 (this : * mut SkCanvas , vertices : * const sk_sp < SkVertices > , mode : SkBlendMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawMesh@SkCanvas@@QEAAXAEBVSkMesh@@V?$sk_sp@VSkBlender@@@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawMesh (this : * mut SkCanvas , mesh : * const SkMesh , blender : sk_sp < SkBlender > , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawPatch@SkCanvas@@QEAAXQEBUSkPoint@@QEBI0W4SkBlendMode@@AEBVSkPaint@@@Z"] pub fn SkCanvas_drawPatch (this : * mut SkCanvas , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawAtlas@SkCanvas@@QEAAXPEBVSkImage@@QEBUSkRSXform@@QEBUSkRect@@QEBIHW4SkBlendMode@@AEBUSkSamplingOptions@@PEBU4@PEBVSkPaint@@@Z"] pub fn SkCanvas_drawAtlas (this : * mut SkCanvas , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , sampling : * const SkSamplingOptions , cullRect : * const SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@PEBVSkMatrix@@@Z"] pub fn SkCanvas_drawDrawable (this : * mut SkCanvas , drawable : * mut SkDrawable , matrix : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?drawDrawable@SkCanvas@@QEAAXPEAVSkDrawable@@MM@Z"] pub fn SkCanvas_drawDrawable1 (this : * mut SkCanvas , drawable : * mut SkDrawable , x : SkScalar , y : SkScalar) ; } extern "C" { # [link_name = "\u{1}?drawAnnotation@SkCanvas@@QEAAXAEBUSkRect@@QEBDPEAVSkData@@@Z"] pub fn SkCanvas_drawAnnotation (this : * mut SkCanvas , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData) ; } extern "C" { # [link_name = "\u{1}?getLocalToDevice@SkCanvas@@QEBA?AVSkM44@@XZ"] pub fn SkCanvas_getLocalToDevice (this : * const SkCanvas) -> SkM44 ; } extern "C" { # [link_name = "\u{1}?getTotalMatrix@SkCanvas@@QEBA?AVSkMatrix@@XZ"] pub fn SkCanvas_getTotalMatrix (this : * const SkCanvas) -> SkMatrix ; } extern "C" { # [link_name = "\u{1}?temporary_internal_getRgnClip@SkCanvas@@QEAAXPEAVSkRegion@@@Z"] pub fn SkCanvas_temporary_internal_getRgnClip (this : * mut SkCanvas , region : * mut SkRegion) ; } extern "C" { # [link_name = "\u{1}?private_draw_shadow_rec@SkCanvas@@QEAAXAEBVSkPath@@AEBUSkDrawShadowRec@@@Z"] pub fn SkCanvas_private_draw_shadow_rec (this : * mut SkCanvas , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@QEAA@XZ"] pub fn SkCanvas_SkCanvas (this : * mut SkCanvas) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@QEAA@HHPEBVSkSurfaceProps@@@Z"] pub fn SkCanvas_SkCanvas1 (this : * mut SkCanvas , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@QEAA@V?$sk_sp@VSkBaseDevice@@@@@Z"] pub fn SkCanvas_SkCanvas2 (this : * mut SkCanvas , device : sk_sp < SkBaseDevice >) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@QEAA@AEBVSkBitmap@@@Z"] pub fn SkCanvas_SkCanvas3 (this : * mut SkCanvas , bitmap : * const SkBitmap) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@QEAA@AEBVSkBitmap@@AEBVSkSurfaceProps@@@Z"] pub fn SkCanvas_SkCanvas4 (this : * mut SkCanvas , bitmap : * const SkBitmap , props : * const SkSurfaceProps) ; } extern "C" { # [link_name = "\u{1}??0SkCanvas@@IEAA@AEBUSkIRect@@@Z"] pub fn SkCanvas_SkCanvas5 (this : * mut SkCanvas , bounds : * const SkIRect) ; } impl SkCanvas { # [inline] pub unsafe fn MakeRasterDirect (info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , props : * const SkSurfaceProps) -> u64 { SkCanvas_MakeRasterDirect (info , pixels , rowBytes , props) } # [inline] pub unsafe fn imageInfo (& self) -> SkImageInfo { SkCanvas_imageInfo (self) } # [inline] pub unsafe fn getProps (& self , props : * mut SkSurfaceProps) -> bool { SkCanvas_getProps (self , props) } # [inline] pub unsafe fn getBaseProps (& self) -> SkSurfaceProps { SkCanvas_getBaseProps (self) } # [inline] pub unsafe fn getTopProps (& self) -> SkSurfaceProps { SkCanvas_getTopProps (self) } # [inline] pub unsafe fn flush (& mut self) { SkCanvas_flush (self) } # [inline] pub unsafe fn makeSurface (& mut self , info : * const SkImageInfo , props : * const SkSurfaceProps) -> sk_sp < SkSurface > { SkCanvas_makeSurface (self , info , props) } # [inline] pub unsafe fn getSurface (& self) -> * mut SkSurface { SkCanvas_getSurface (self) } # [inline] pub unsafe fn accessTopLayerPixels (& mut self , info : * mut SkImageInfo , rowBytes : * mut usize , origin : * mut SkIPoint) -> * mut :: core :: ffi :: c_void { SkCanvas_accessTopLayerPixels (self , info , rowBytes , origin) } # [inline] pub unsafe fn accessTopRasterHandle (& self) -> SkRasterHandleAllocator_Handle { SkCanvas_accessTopRasterHandle (self) } # [inline] pub unsafe fn peekPixels (& mut self , pixmap : * mut SkPixmap) -> bool { SkCanvas_peekPixels (self , pixmap) } # [inline] pub unsafe fn readPixels (& mut self , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkCanvas_readPixels (self , dstInfo , dstPixels , dstRowBytes , srcX , srcY) } # [inline] pub unsafe fn readPixels1 (& mut self , pixmap : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkCanvas_readPixels1 (self , pixmap , srcX , srcY) } # [inline] pub unsafe fn readPixels2 (& mut self , bitmap : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkCanvas_readPixels2 (self , bitmap , srcX , srcY) } # [inline] pub unsafe fn writePixels (& mut self , info : * const SkImageInfo , pixels : * const :: core :: ffi :: c_void , rowBytes : usize , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> bool { SkCanvas_writePixels (self , info , pixels , rowBytes , x , y) } # [inline] pub unsafe fn writePixels1 (& mut self , bitmap : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> bool { SkCanvas_writePixels1 (self , bitmap , x , y) } # [inline] pub unsafe fn save (& mut self) -> :: std :: os :: raw :: c_int { SkCanvas_save (self) } # [inline] pub unsafe fn saveLayer (& mut self , bounds : * const SkRect , paint : * const SkPaint) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayer (self , bounds , paint) } # [inline] pub unsafe fn saveLayerAlpha (& mut self , bounds : * const SkRect , alpha : U8CPU) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayerAlpha (self , bounds , alpha) } # [inline] pub unsafe fn saveLayer1 (& mut self , layerRec : * const SkCanvas_SaveLayerRec) -> :: std :: os :: raw :: c_int { SkCanvas_saveLayer1 (self , layerRec) } # [inline] pub unsafe fn restore (& mut self) { SkCanvas_restore (self) } # [inline] pub unsafe fn getSaveCount (& self) -> :: std :: os :: raw :: c_int { SkCanvas_getSaveCount (self) } # [inline] pub unsafe fn restoreToCount (& mut self , saveCount : :: std :: os :: raw :: c_int) { SkCanvas_restoreToCount (self , saveCount) } # [inline] pub unsafe fn translate (& mut self , dx : SkScalar , dy : SkScalar) { SkCanvas_translate (self , dx , dy) } # [inline] pub unsafe fn scale (& mut self , sx : SkScalar , sy : SkScalar) { SkCanvas_scale (self , sx , sy) } # [inline] pub unsafe fn rotate (& mut self , degrees : SkScalar) { SkCanvas_rotate (self , degrees) } # [inline] pub unsafe fn rotate1 (& mut self , degrees : SkScalar , px : SkScalar , py : SkScalar) { SkCanvas_rotate1 (self , degrees , px , py) } # [inline] pub unsafe fn skew (& mut self , sx : SkScalar , sy : SkScalar) { SkCanvas_skew (self , sx , sy) } # [inline] pub unsafe fn concat (& mut self , matrix : * const SkMatrix) { SkCanvas_concat (self , matrix) } # [inline] pub unsafe fn concat1 (& mut self , arg1 : * const SkM44) { SkCanvas_concat1 (self , arg1) } # [inline] pub unsafe fn setMatrix (& mut self , matrix : * const SkM44) { SkCanvas_setMatrix (self , matrix) } # [inline] pub unsafe fn setMatrix1 (& mut self , matrix : * const SkMatrix) { SkCanvas_setMatrix1 (self , matrix) } # [inline] pub unsafe fn resetMatrix (& mut self) { SkCanvas_resetMatrix (self) } # [inline] pub unsafe fn clipRect (& mut self , rect : * const SkRect , op : SkClipOp , doAntiAlias : bool) { SkCanvas_clipRect (self , rect , op , doAntiAlias) } # [inline] pub unsafe fn androidFramework_setDeviceClipRestriction (& mut self , rect : * const SkIRect) { SkCanvas_androidFramework_setDeviceClipRestriction (self , rect) } # [inline] pub unsafe fn clipRRect (& mut self , rrect : * const SkRRect , op : SkClipOp , doAntiAlias : bool) { SkCanvas_clipRRect (self , rrect , op , doAntiAlias) } # [inline] pub unsafe fn clipPath (& mut self , path : * const SkPath , op : SkClipOp , doAntiAlias : bool) { SkCanvas_clipPath (self , path , op , doAntiAlias) } # [inline] pub unsafe fn clipShader (& mut self , arg1 : sk_sp < SkShader > , arg2 : SkClipOp) { SkCanvas_clipShader (self , arg1 , arg2) } # [inline] pub unsafe fn clipRegion (& mut self , deviceRgn : * const SkRegion , op : SkClipOp) { SkCanvas_clipRegion (self , deviceRgn , op) } # [inline] pub unsafe fn quickReject (& self , rect : * const SkRect) -> bool { SkCanvas_quickReject (self , rect) } # [inline] pub unsafe fn quickReject1 (& self , path : * const SkPath) -> bool { SkCanvas_quickReject1 (self , path) } # [inline] pub unsafe fn getLocalClipBounds (& self) -> SkRect { SkCanvas_getLocalClipBounds (self) } # [inline] pub unsafe fn getDeviceClipBounds (& self) -> SkIRect { SkCanvas_getDeviceClipBounds (self) } # [inline] pub unsafe fn drawColor (& mut self , color : * const SkColor4f , mode : SkBlendMode) { SkCanvas_drawColor (self , color , mode) } # [inline] pub unsafe fn drawPaint (& mut self , paint : * const SkPaint) { SkCanvas_drawPaint (self , paint) } # [inline] pub unsafe fn drawPoints (& mut self , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint) { SkCanvas_drawPoints (self , mode , count , pts , paint) } # [inline] pub unsafe fn drawPoint (& mut self , x : SkScalar , y : SkScalar , paint : * const SkPaint) { SkCanvas_drawPoint (self , x , y , paint) } # [inline] pub unsafe fn drawLine (& mut self , x0 : SkScalar , y0 : SkScalar , x1 : SkScalar , y1 : SkScalar , paint : * const SkPaint) { SkCanvas_drawLine (self , x0 , y0 , x1 , y1 , paint) } # [inline] pub unsafe fn drawRect (& mut self , rect : * const SkRect , paint : * const SkPaint) { SkCanvas_drawRect (self , rect , paint) } # [inline] pub unsafe fn drawRegion (& mut self , region : * const SkRegion , paint : * const SkPaint) { SkCanvas_drawRegion (self , region , paint) } # [inline] pub unsafe fn drawOval (& mut self , oval : * const SkRect , paint : * const SkPaint) { SkCanvas_drawOval (self , oval , paint) } # [inline] pub unsafe fn drawRRect (& mut self , rrect : * const SkRRect , paint : * const SkPaint) { SkCanvas_drawRRect (self , rrect , paint) } # [inline] pub unsafe fn drawDRRect (& mut self , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint) { SkCanvas_drawDRRect (self , outer , inner , paint) } # [inline] pub unsafe fn drawCircle (& mut self , cx : SkScalar , cy : SkScalar , radius : SkScalar , paint : * const SkPaint) { SkCanvas_drawCircle (self , cx , cy , radius , paint) } # [inline] pub unsafe fn drawArc (& mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint) { SkCanvas_drawArc (self , oval , startAngle , sweepAngle , useCenter , paint) } # [inline] pub unsafe fn drawRoundRect (& mut self , rect : * const SkRect , rx : SkScalar , ry : SkScalar , paint : * const SkPaint) { SkCanvas_drawRoundRect (self , rect , rx , ry , paint) } # [inline] pub unsafe fn drawPath (& mut self , path : * const SkPath , paint : * const SkPaint) { SkCanvas_drawPath (self , path , paint) } # [inline] pub unsafe fn drawImage (& mut self , arg1 : * const SkImage , x : SkScalar , y : SkScalar , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint) { SkCanvas_drawImage (self , arg1 , x , y , arg2 , arg3) } # [inline] pub unsafe fn drawImageRect (& mut self , arg1 : * const SkImage , src : * const SkRect , dst : * const SkRect , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint , arg4 : SkCanvas_SrcRectConstraint) { SkCanvas_drawImageRect (self , arg1 , src , dst , arg2 , arg3 , arg4) } # [inline] pub unsafe fn drawImageRect1 (& mut self , arg1 : * const SkImage , dst : * const SkRect , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint) { SkCanvas_drawImageRect1 (self , arg1 , dst , arg2 , arg3) } # [inline] pub unsafe fn drawImageNine (& mut self , image : * const SkImage , center : * const SkIRect , dst : * const SkRect , filter : SkFilterMode , paint : * const SkPaint) { SkCanvas_drawImageNine (self , image , center , dst , filter , paint) } # [inline] pub unsafe fn drawImageLattice (& mut self , image : * const SkImage , lattice : * const SkCanvas_Lattice , dst : * const SkRect , filter : SkFilterMode , paint : * const SkPaint) { SkCanvas_drawImageLattice (self , image , lattice , dst , filter , paint) } # [inline] pub unsafe fn experimental_DrawEdgeAAQuad (& mut self , rect : * const SkRect , clip : * const SkPoint , aaFlags : SkCanvas_QuadAAFlags , color : * const SkColor4f , mode : SkBlendMode) { SkCanvas_experimental_DrawEdgeAAQuad (self , rect , clip , aaFlags , color , mode) } # [inline] pub unsafe fn experimental_DrawEdgeAAImageSet (& mut self , imageSet : * const SkCanvas_ImageSetEntry , cnt : :: std :: os :: raw :: c_int , dstClips : * const SkPoint , preViewMatrices : * const SkMatrix , arg1 : * const SkSamplingOptions , paint : * const SkPaint , constraint : SkCanvas_SrcRectConstraint) { SkCanvas_experimental_DrawEdgeAAImageSet (self , imageSet , cnt , dstClips , preViewMatrices , arg1 , paint , constraint) } # [inline] pub unsafe fn drawSimpleText (& mut self , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , x : SkScalar , y : SkScalar , font : * const SkFont , paint : * const SkPaint) { SkCanvas_drawSimpleText (self , text , byteLength , encoding , x , y , font , paint) } # [inline] pub unsafe fn drawGlyphs (& mut self , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , positions : * const SkPoint , clusters : * const u32 , textByteCount : :: std :: os :: raw :: c_int , utf8text : * const :: std :: os :: raw :: c_char , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) { SkCanvas_drawGlyphs (self , count , glyphs , positions , clusters , textByteCount , utf8text , origin , font , paint) } # [inline] pub unsafe fn drawGlyphs1 (& mut self , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , positions : * const SkPoint , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) { SkCanvas_drawGlyphs1 (self , count , glyphs , positions , origin , font , paint) } # [inline] pub unsafe fn drawGlyphs2 (& mut self , count : :: std :: os :: raw :: c_int , glyphs : * const SkGlyphID , xforms : * const SkRSXform , origin : SkPoint , font : * const SkFont , paint : * const SkPaint) { SkCanvas_drawGlyphs2 (self , count , glyphs , xforms , origin , font , paint) } # [inline] pub unsafe fn drawTextBlob (& mut self , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint) { SkCanvas_drawTextBlob (self , blob , x , y , paint) } # [inline] pub unsafe fn drawPicture (& mut self , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint) { SkCanvas_drawPicture (self , picture , matrix , paint) } # [inline] pub unsafe fn drawVertices (& mut self , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint) { SkCanvas_drawVertices (self , vertices , mode , paint) } # [inline] pub unsafe fn drawVertices1 (& mut self , vertices : * const sk_sp < SkVertices > , mode : SkBlendMode , paint : * const SkPaint) { SkCanvas_drawVertices1 (self , vertices , mode , paint) } # [inline] pub unsafe fn drawMesh (& mut self , mesh : * const SkMesh , blender : sk_sp < SkBlender > , paint : * const SkPaint) { SkCanvas_drawMesh (self , mesh , blender , paint) } # [inline] pub unsafe fn drawPatch (& mut self , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint) { SkCanvas_drawPatch (self , cubics , colors , texCoords , mode , paint) } # [inline] pub unsafe fn drawAtlas (& mut self , atlas : * const SkImage , xform : * const SkRSXform , tex : * const SkRect , colors : * const SkColor , count : :: std :: os :: raw :: c_int , mode : SkBlendMode , sampling : * const SkSamplingOptions , cullRect : * const SkRect , paint : * const SkPaint) { SkCanvas_drawAtlas (self , atlas , xform , tex , colors , count , mode , sampling , cullRect , paint) } # [inline] pub unsafe fn drawDrawable (& mut self , drawable : * mut SkDrawable , matrix : * const SkMatrix) { SkCanvas_drawDrawable (self , drawable , matrix) } # [inline] pub unsafe fn drawDrawable1 (& mut self , drawable : * mut SkDrawable , x : SkScalar , y : SkScalar) { SkCanvas_drawDrawable1 (self , drawable , x , y) } # [inline] pub unsafe fn drawAnnotation (& mut self , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData) { SkCanvas_drawAnnotation (self , rect , key , value) } # [inline] pub unsafe fn getLocalToDevice (& self) -> SkM44 { SkCanvas_getLocalToDevice (self) } # [inline] pub unsafe fn getTotalMatrix (& self) -> SkMatrix { SkCanvas_getTotalMatrix (self) } # [inline] pub unsafe fn temporary_internal_getRgnClip (& mut self , region : * mut SkRegion) { SkCanvas_temporary_internal_getRgnClip (self , region) } # [inline] pub unsafe fn private_draw_shadow_rec (& mut self , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec) { SkCanvas_private_draw_shadow_rec (self , arg1 , arg2) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas1 (__bindgen_tmp . as_mut_ptr () , width , height , props) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (device : sk_sp < SkBaseDevice >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas2 (__bindgen_tmp . as_mut_ptr () , device) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (bitmap : * const SkBitmap) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas3 (__bindgen_tmp . as_mut_ptr () , bitmap) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new4 (bitmap : * const SkBitmap , props : * const SkSurfaceProps) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas4 (__bindgen_tmp . as_mut_ptr () , bitmap , props) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new5 (bounds : * const SkIRect) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCanvas_SkCanvas5 (__bindgen_tmp . as_mut_ptr () , bounds) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?getBaseLayerSize@SkCanvas@@UEBA?AUSkISize@@XZ"] pub fn SkCanvas_getBaseLayerSize (this : * mut :: core :: ffi :: c_void) -> SkISize ; } extern "C" { # [link_name = "\u{1}?recordingContext@SkCanvas@@UEAAPEAVGrRecordingContext@@XZ"] pub fn SkCanvas_recordingContext (this : * mut :: core :: ffi :: c_void) -> * mut GrRecordingContext ; } extern "C" { # [link_name = "\u{1}?recorder@SkCanvas@@UEAAPEAVRecorder@graphite@skgpu@@XZ"] pub fn SkCanvas_recorder (this : * mut :: core :: ffi :: c_void) -> * mut skgpu_graphite_Recorder ; } extern "C" { # [link_name = "\u{1}?isClipEmpty@SkCanvas@@UEBA_NXZ"] pub fn SkCanvas_isClipEmpty (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?isClipRect@SkCanvas@@UEBA_NXZ"] pub fn SkCanvas_isClipRect (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?onNewSurface@SkCanvas@@MEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@AEBVSkSurfaceProps@@@Z"] pub fn SkCanvas_onNewSurface (this : * mut :: core :: ffi :: c_void , info : * const SkImageInfo , props : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?onPeekPixels@SkCanvas@@MEAA_NPEAVSkPixmap@@@Z"] pub fn SkCanvas_onPeekPixels (this : * mut :: core :: ffi :: c_void , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?onAccessTopLayerPixels@SkCanvas@@MEAA_NPEAVSkPixmap@@@Z"] pub fn SkCanvas_onAccessTopLayerPixels (this : * mut :: core :: ffi :: c_void , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?onImageInfo@SkCanvas@@MEBA?AUSkImageInfo@@XZ"] pub fn SkCanvas_onImageInfo (this : * mut :: core :: ffi :: c_void) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?onGetProps@SkCanvas@@MEBA_NPEAVSkSurfaceProps@@_N@Z"] pub fn SkCanvas_onGetProps (this : * mut :: core :: ffi :: c_void , props : * mut SkSurfaceProps , top : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?onFlush@SkCanvas@@MEAAXXZ"] pub fn SkCanvas_onFlush (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?onDrawPaint@SkCanvas@@MEAAXAEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawPaint (this : * mut :: core :: ffi :: c_void , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawBehind@SkCanvas@@MEAAXAEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawBehind (this : * mut :: core :: ffi :: c_void , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawRect@SkCanvas@@MEAAXAEBUSkRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawRect (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawRRect@SkCanvas@@MEAAXAEBVSkRRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawRRect (this : * mut :: core :: ffi :: c_void , rrect : * const SkRRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawDRRect@SkCanvas@@MEAAXAEBVSkRRect@@0AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawDRRect (this : * mut :: core :: ffi :: c_void , outer : * const SkRRect , inner : * const SkRRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawOval@SkCanvas@@MEAAXAEBUSkRect@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawOval (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawArc@SkCanvas@@MEAAXAEBUSkRect@@MM_NAEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawArc (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , useCenter : bool , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawPath@SkCanvas@@MEAAXAEBVSkPath@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawPath (this : * mut :: core :: ffi :: c_void , path : * const SkPath , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawRegion@SkCanvas@@MEAAXAEBVSkRegion@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawRegion (this : * mut :: core :: ffi :: c_void , region : * const SkRegion , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawTextBlob@SkCanvas@@MEAAXPEBVSkTextBlob@@MMAEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawTextBlob (this : * mut :: core :: ffi :: c_void , blob : * const SkTextBlob , x : SkScalar , y : SkScalar , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawGlyphRunList@SkCanvas@@MEAAXAEBVGlyphRunList@sktext@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawGlyphRunList (this : * mut :: core :: ffi :: c_void , glyphRunList : * const sktext_GlyphRunList , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawPatch@SkCanvas@@MEAAXQEBUSkPoint@@QEBI0W4SkBlendMode@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawPatch (this : * mut :: core :: ffi :: c_void , cubics : * const SkPoint , colors : * const SkColor , texCoords : * const SkPoint , mode : SkBlendMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawPoints@SkCanvas@@MEAAXW4PointMode@1@_KQEBUSkPoint@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawPoints (this : * mut :: core :: ffi :: c_void , mode : SkCanvas_PointMode , count : usize , pts : * const SkPoint , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawImage2@SkCanvas@@MEAAXPEBVSkImage@@MMAEBUSkSamplingOptions@@PEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawImage2 (this : * mut :: core :: ffi :: c_void , arg1 : * const SkImage , dx : SkScalar , dy : SkScalar , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawImageRect2@SkCanvas@@MEAAXPEBVSkImage@@AEBUSkRect@@1AEBUSkSamplingOptions@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"] pub fn SkCanvas_onDrawImageRect2 (this : * mut :: core :: ffi :: c_void , arg1 : * const SkImage , src : * const SkRect , dst : * const SkRect , arg2 : * const SkSamplingOptions , arg3 : * const SkPaint , arg4 : SkCanvas_SrcRectConstraint) ; } extern "C" { # [link_name = "\u{1}?onDrawImageLattice2@SkCanvas@@MEAAXPEBVSkImage@@AEBULattice@1@AEBUSkRect@@W4SkFilterMode@@PEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawImageLattice2 (this : * mut :: core :: ffi :: c_void , arg1 : * const SkImage , arg2 : * const SkCanvas_Lattice , dst : * const SkRect , arg3 : SkFilterMode , arg4 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawAtlas2@SkCanvas@@MEAAXPEBVSkImage@@QEBUSkRSXform@@QEBUSkRect@@QEBIHW4SkBlendMode@@AEBUSkSamplingOptions@@PEBU4@PEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawAtlas2 (this : * mut :: core :: ffi :: c_void , arg1 : * const SkImage , arg2 : * const SkRSXform , src : * const SkRect , arg3 : * const SkColor , count : :: std :: os :: raw :: c_int , arg4 : SkBlendMode , arg5 : * const SkSamplingOptions , cull : * const SkRect , arg6 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawEdgeAAImageSet2@SkCanvas@@MEAAXQEBUImageSetEntry@1@HQEBUSkPoint@@QEBVSkMatrix@@AEBUSkSamplingOptions@@PEBVSkPaint@@W4SrcRectConstraint@1@@Z"] pub fn SkCanvas_onDrawEdgeAAImageSet2 (this : * mut :: core :: ffi :: c_void , imageSet : * const SkCanvas_ImageSetEntry , count : :: std :: os :: raw :: c_int , dstClips : * const SkPoint , preViewMatrices : * const SkMatrix , arg1 : * const SkSamplingOptions , arg2 : * const SkPaint , arg3 : SkCanvas_SrcRectConstraint) ; } extern "C" { # [link_name = "\u{1}?onDrawVerticesObject@SkCanvas@@MEAAXPEBVSkVertices@@W4SkBlendMode@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawVerticesObject (this : * mut :: core :: ffi :: c_void , vertices : * const SkVertices , mode : SkBlendMode , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawMesh@SkCanvas@@MEAAXAEBVSkMesh@@V?$sk_sp@VSkBlender@@@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawMesh (this : * mut :: core :: ffi :: c_void , arg1 : * const SkMesh , arg2 : sk_sp < SkBlender > , arg3 : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawAnnotation@SkCanvas@@MEAAXAEBUSkRect@@QEBDPEAVSkData@@@Z"] pub fn SkCanvas_onDrawAnnotation (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , key : * const :: std :: os :: raw :: c_char , value : * mut SkData) ; } extern "C" { # [link_name = "\u{1}?onDrawShadowRec@SkCanvas@@MEAAXAEBVSkPath@@AEBUSkDrawShadowRec@@@Z"] pub fn SkCanvas_onDrawShadowRec (this : * mut :: core :: ffi :: c_void , arg1 : * const SkPath , arg2 : * const SkDrawShadowRec) ; } extern "C" { # [link_name = "\u{1}?onDrawDrawable@SkCanvas@@MEAAXPEAVSkDrawable@@PEBVSkMatrix@@@Z"] pub fn SkCanvas_onDrawDrawable (this : * mut :: core :: ffi :: c_void , drawable : * mut SkDrawable , matrix : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?onDrawPicture@SkCanvas@@MEAAXPEBVSkPicture@@PEBVSkMatrix@@PEBVSkPaint@@@Z"] pub fn SkCanvas_onDrawPicture (this : * mut :: core :: ffi :: c_void , picture : * const SkPicture , matrix : * const SkMatrix , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?onDrawEdgeAAQuad@SkCanvas@@MEAAXAEBUSkRect@@QEBUSkPoint@@W4QuadAAFlags@1@AEBU?$SkRGBA4f@$02@@W4SkBlendMode@@@Z"] pub fn SkCanvas_onDrawEdgeAAQuad (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , clip : * const SkPoint , aaFlags : SkCanvas_QuadAAFlags , color : * const SkColor4f , mode : SkBlendMode) ; } extern "C" { # [link_name = "\u{1}?onClipRect@SkCanvas@@MEAAXAEBUSkRect@@W4SkClipOp@@W4ClipEdgeStyle@1@@Z"] pub fn SkCanvas_onClipRect (this : * mut :: core :: ffi :: c_void , rect : * const SkRect , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle) ; } extern "C" { # [link_name = "\u{1}?onClipRRect@SkCanvas@@MEAAXAEBVSkRRect@@W4SkClipOp@@W4ClipEdgeStyle@1@@Z"] pub fn SkCanvas_onClipRRect (this : * mut :: core :: ffi :: c_void , rrect : * const SkRRect , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle) ; } extern "C" { # [link_name = "\u{1}?onClipPath@SkCanvas@@MEAAXAEBVSkPath@@W4SkClipOp@@W4ClipEdgeStyle@1@@Z"] pub fn SkCanvas_onClipPath (this : * mut :: core :: ffi :: c_void , path : * const SkPath , op : SkClipOp , edgeStyle : SkCanvas_ClipEdgeStyle) ; } extern "C" { # [link_name = "\u{1}?onClipShader@SkCanvas@@MEAAXV?$sk_sp@VSkShader@@@@W4SkClipOp@@@Z"] pub fn SkCanvas_onClipShader (this : * mut :: core :: ffi :: c_void , arg1 : sk_sp < SkShader > , arg2 : SkClipOp) ; } extern "C" { # [link_name = "\u{1}?onClipRegion@SkCanvas@@MEAAXAEBVSkRegion@@W4SkClipOp@@@Z"] pub fn SkCanvas_onClipRegion (this : * mut :: core :: ffi :: c_void , deviceRgn : * const SkRegion , op : SkClipOp) ; } extern "C" { # [link_name = "\u{1}?onResetClip@SkCanvas@@MEAAXXZ"] pub fn SkCanvas_onResetClip (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?onDiscard@SkCanvas@@MEAAXXZ"] pub fn SkCanvas_onDiscard (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?onConvertGlyphRunListToSlug@SkCanvas@@MEAA?AV?$sk_sp@VSlug@gpu@sktext@@@@AEBVGlyphRunList@sktext@@AEBVSkPaint@@@Z"] pub fn SkCanvas_onConvertGlyphRunListToSlug (this : * mut :: core :: ffi :: c_void , glyphRunList : * const sktext_GlyphRunList , paint : * const SkPaint) -> sk_sp < sktext_gpu_Slug > ; } extern "C" { # [link_name = "\u{1}?onDrawSlug@SkCanvas@@MEAAXPEBVSlug@gpu@sktext@@@Z"] pub fn SkCanvas_onDrawSlug (this : * mut :: core :: ffi :: c_void , slug : * const sktext_gpu_Slug) ; } # [repr (C)] # [derive (Debug)] pub struct SkAutoCanvasRestore { pub fCanvas : * mut SkCanvas , pub fSaveCount : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_SkAutoCanvasRestore () { assert_eq ! (:: core :: mem :: size_of :: < SkAutoCanvasRestore > () , 16usize , concat ! ("Size of: " , stringify ! (SkAutoCanvasRestore))) ; assert_eq ! (:: core :: mem :: align_of :: < SkAutoCanvasRestore > () , 8usize , concat ! ("Alignment of " , stringify ! (SkAutoCanvasRestore))) ; fn test_field_fCanvas () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkAutoCanvasRestore > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCanvas) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkAutoCanvasRestore) , "::" , stringify ! (fCanvas))) ; } test_field_fCanvas () ; fn test_field_fSaveCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkAutoCanvasRestore > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSaveCount) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkAutoCanvasRestore) , "::" , stringify ! (fSaveCount))) ; } test_field_fSaveCount () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSerialProcs { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDeserialProcs { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkFlattenable { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFlattenable_Type { SkColorFilter = 0 , SkBlender = 1 , SkDrawable = 2 , SkDrawLooper = 3 , SkImageFilter = 4 , SkMaskFilter = 5 , SkPathEffect = 6 , SkShader = 7 , } pub type SkFlattenable_Factory = :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut SkReadBuffer) -> sk_sp < SkFlattenable > > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFlattenable_PrivateInitializer { pub _address : u8 , } # [test] fn bindgen_test_layout_SkFlattenable_PrivateInitializer () { assert_eq ! (:: core :: mem :: size_of :: < SkFlattenable_PrivateInitializer > () , 1usize , concat ! ("Size of: " , stringify ! (SkFlattenable_PrivateInitializer))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFlattenable_PrivateInitializer > () , 1usize , concat ! ("Alignment of " , stringify ! (SkFlattenable_PrivateInitializer))) ; } extern "C" { # [link_name = "\u{1}?InitEffects@PrivateInitializer@SkFlattenable@@SAXXZ"] pub fn SkFlattenable_PrivateInitializer_InitEffects () ; } extern "C" { # [link_name = "\u{1}?InitImageFilters@PrivateInitializer@SkFlattenable@@SAXXZ"] pub fn SkFlattenable_PrivateInitializer_InitImageFilters () ; } impl SkFlattenable_PrivateInitializer { # [inline] pub unsafe fn InitEffects () { SkFlattenable_PrivateInitializer_InitEffects () } # [inline] pub unsafe fn InitImageFilters () { SkFlattenable_PrivateInitializer_InitImageFilters () } } pub type SkFlattenable_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkFlattenable () { assert_eq ! (:: core :: mem :: size_of :: < SkFlattenable > () , 16usize , concat ! ("Size of: " , stringify ! (SkFlattenable))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFlattenable > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFlattenable))) ; } extern "C" { # [link_name = "\u{1}?NameToFactory@SkFlattenable@@SAP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@ZQEBD@Z"] pub fn SkFlattenable_NameToFactory (name : * const :: std :: os :: raw :: c_char) -> SkFlattenable_Factory ; } extern "C" { # [link_name = "\u{1}?FactoryToName@SkFlattenable@@SAPEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@Z@Z"] pub fn SkFlattenable_FactoryToName (arg1 : SkFlattenable_Factory) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [link_name = "\u{1}?Register@SkFlattenable@@SAXQEBDP6A?AV?$sk_sp@VSkFlattenable@@@@AEAVSkReadBuffer@@@Z@Z"] pub fn SkFlattenable_Register (name : * const :: std :: os :: raw :: c_char , arg1 : SkFlattenable_Factory) ; } extern "C" { # [link_name = "\u{1}?serialize@SkFlattenable@@QEBA?AV?$sk_sp@VSkData@@@@PEBUSkSerialProcs@@@Z"] pub fn SkFlattenable_serialize (this : * const SkFlattenable , arg1 : * const SkSerialProcs) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?serialize@SkFlattenable@@QEBA_KPEAX_KPEBUSkSerialProcs@@@Z"] pub fn SkFlattenable_serialize1 (this : * const SkFlattenable , memory : * mut :: core :: ffi :: c_void , memory_size : usize , arg1 : * const SkSerialProcs) -> usize ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkFlattenable@@SA?AV?$sk_sp@VSkFlattenable@@@@W4Type@1@PEBX_KPEBUSkDeserialProcs@@@Z"] pub fn SkFlattenable_Deserialize (arg1 : SkFlattenable_Type , data : * const :: core :: ffi :: c_void , length : usize , procs : * const SkDeserialProcs) -> sk_sp < SkFlattenable > ; } impl SkFlattenable { # [inline] pub unsafe fn NameToFactory (name : * const :: std :: os :: raw :: c_char) -> SkFlattenable_Factory { SkFlattenable_NameToFactory (name) } # [inline] pub unsafe fn FactoryToName (arg1 : SkFlattenable_Factory) -> * const :: std :: os :: raw :: c_char { SkFlattenable_FactoryToName (arg1) } # [inline] pub unsafe fn Register (name : * const :: std :: os :: raw :: c_char , arg1 : SkFlattenable_Factory) { SkFlattenable_Register (name , arg1) } # [inline] pub unsafe fn serialize (& self , arg1 : * const SkSerialProcs) -> sk_sp < SkData > { SkFlattenable_serialize (self , arg1) } # [inline] pub unsafe fn serialize1 (& self , memory : * mut :: core :: ffi :: c_void , memory_size : usize , arg1 : * const SkSerialProcs) -> usize { SkFlattenable_serialize1 (self , memory , memory_size , arg1) } # [inline] pub unsafe fn Deserialize (arg1 : SkFlattenable_Type , data : * const :: core :: ffi :: c_void , length : usize , procs : * const SkDeserialProcs) -> sk_sp < SkFlattenable > { SkFlattenable_Deserialize (arg1 , data , length , procs) } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkColorFilter { pub _bindgen_opaque_blob : [u64 ; 2usize] , } pub type SkColorFilter_INHERITED = SkFlattenable ; # [test] fn bindgen_test_layout_SkColorFilter () { assert_eq ! (:: core :: mem :: size_of :: < SkColorFilter > () , 16usize , concat ! ("Size of: " , stringify ! (SkColorFilter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkColorFilter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkColorFilter))) ; } extern "C" { # [link_name = "\u{1}?asAColorMode@SkColorFilter@@QEBA_NPEAIPEAW4SkBlendMode@@@Z"] pub fn SkColorFilter_asAColorMode (this : * const SkColorFilter , color : * mut SkColor , mode : * mut SkBlendMode) -> bool ; } extern "C" { # [link_name = "\u{1}?asAColorMatrix@SkColorFilter@@QEBA_NQEAM@Z"] pub fn SkColorFilter_asAColorMatrix (this : * const SkColorFilter , matrix : * mut f32) -> bool ; } extern "C" { # [link_name = "\u{1}?isAlphaUnchanged@SkColorFilter@@QEBA_NXZ"] pub fn SkColorFilter_isAlphaUnchanged (this : * const SkColorFilter) -> bool ; } extern "C" { # [link_name = "\u{1}?filterColor@SkColorFilter@@QEBAII@Z"] pub fn SkColorFilter_filterColor (this : * const SkColorFilter , arg1 : SkColor) -> SkColor ; } extern "C" { # [link_name = "\u{1}?filterColor4f@SkColorFilter@@QEBA?AU?$SkRGBA4f@$02@@AEBU2@PEAVSkColorSpace@@1@Z"] pub fn SkColorFilter_filterColor4f (this : * const SkColorFilter , srcColor : * const SkColor4f , srcCS : * mut SkColorSpace , dstCS : * mut SkColorSpace) -> SkColor4f ; } extern "C" { # [link_name = "\u{1}?makeComposed@SkColorFilter@@QEBA?AV?$sk_sp@VSkColorFilter@@@@V2@@Z"] pub fn SkColorFilter_makeComposed (this : * const SkColorFilter , inner : sk_sp < SkColorFilter >) -> sk_sp < SkColorFilter > ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkColorFilter@@SA?AV?$sk_sp@VSkColorFilter@@@@PEBX_KPEBUSkDeserialProcs@@@Z"] pub fn SkColorFilter_Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkColorFilter > ; } impl SkColorFilter { # [inline] pub unsafe fn asAColorMode (& self , color : * mut SkColor , mode : * mut SkBlendMode) -> bool { SkColorFilter_asAColorMode (self , color , mode) } # [inline] pub unsafe fn asAColorMatrix (& self , matrix : * mut f32) -> bool { SkColorFilter_asAColorMatrix (self , matrix) } # [inline] pub unsafe fn isAlphaUnchanged (& self) -> bool { SkColorFilter_isAlphaUnchanged (self) } # [inline] pub unsafe fn filterColor (& self , arg1 : SkColor) -> SkColor { SkColorFilter_filterColor (self , arg1) } # [inline] pub unsafe fn filterColor4f (& self , srcColor : * const SkColor4f , srcCS : * mut SkColorSpace , dstCS : * mut SkColorSpace) -> SkColor4f { SkColorFilter_filterColor4f (self , srcColor , srcCS , dstCS) } # [inline] pub unsafe fn makeComposed (& self , inner : sk_sp < SkColorFilter >) -> sk_sp < SkColorFilter > { SkColorFilter_makeComposed (self , inner) } # [inline] pub unsafe fn Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkColorFilter > { SkColorFilter_Deserialize (data , size , procs) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathFillType { Winding = 0 , EvenOdd = 1 , InverseWinding = 2 , InverseEvenOdd = 3 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathDirection { CW = 0 , CCW = 1 , } pub const SkPathSegmentMask_kLine_SkPathSegmentMask : SkPathSegmentMask = 1 ; pub const SkPathSegmentMask_kQuad_SkPathSegmentMask : SkPathSegmentMask = 2 ; pub const SkPathSegmentMask_kConic_SkPathSegmentMask : SkPathSegmentMask = 4 ; pub const SkPathSegmentMask_kCubic_SkPathSegmentMask : SkPathSegmentMask = 8 ; pub type SkPathSegmentMask = :: std :: os :: raw :: c_int ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathVerb { Move = 0 , Line = 1 , Quad = 2 , Conic = 3 , Cubic = 4 , Close = 5 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPathRef { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct SkPath { pub fPathRef : sk_sp < SkPathRef > , pub fLastMoveToIndex : :: std :: os :: raw :: c_int , pub fConvexity : u8 , pub fFirstDirection : u8 , pub _bitfield_align_1 : [u8 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 1usize] > , pub __bindgen_padding_0 : u8 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPath_ArcSize { Small = 0 , Large = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPath_AddPathMode { Append = 0 , Extend = 1 , } pub const SkPath_SegmentMask_kLine_SegmentMask : SkPath_SegmentMask = 1 ; pub const SkPath_SegmentMask_kQuad_SegmentMask : SkPath_SegmentMask = 2 ; pub const SkPath_SegmentMask_kConic_SegmentMask : SkPath_SegmentMask = 4 ; pub const SkPath_SegmentMask_kCubic_SegmentMask : SkPath_SegmentMask = 8 ; pub type SkPath_SegmentMask = :: std :: os :: raw :: c_int ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPath_Verb { Move = 0 , Line = 1 , Quad = 2 , Conic = 3 , Cubic = 4 , Close = 5 , Done = 6 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPath_Iter { pub fPts : * const SkPoint , pub fVerbs : * const u8 , pub fVerbStop : * const u8 , pub fConicWeights : * const SkScalar , pub fMoveTo : SkPoint , pub fLastPt : SkPoint , pub fForceClose : bool , pub fNeedClose : bool , pub fCloseLine : bool , } # [test] fn bindgen_test_layout_SkPath_Iter () { assert_eq ! (:: core :: mem :: size_of :: < SkPath_Iter > () , 56usize , concat ! ("Size of: " , stringify ! (SkPath_Iter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPath_Iter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPath_Iter))) ; fn test_field_fPts () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPts) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fPts))) ; } test_field_fPts () ; fn test_field_fVerbs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVerbs) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fVerbs))) ; } test_field_fVerbs () ; fn test_field_fVerbStop () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVerbStop) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fVerbStop))) ; } test_field_fVerbStop () ; fn test_field_fConicWeights () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fConicWeights) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fConicWeights))) ; } test_field_fConicWeights () ; fn test_field_fMoveTo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMoveTo) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fMoveTo))) ; } test_field_fMoveTo () ; fn test_field_fLastPt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastPt) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fLastPt))) ; } test_field_fLastPt () ; fn test_field_fForceClose () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fForceClose) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fForceClose))) ; } test_field_fForceClose () ; fn test_field_fNeedClose () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNeedClose) as usize - ptr as usize } , 49usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fNeedClose))) ; } test_field_fNeedClose () ; fn test_field_fCloseLine () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCloseLine) as usize - ptr as usize } , 50usize , concat ! ("Offset of field: " , stringify ! (SkPath_Iter) , "::" , stringify ! (fCloseLine))) ; } test_field_fCloseLine () ; } extern "C" { # [link_name = "\u{1}?setPath@Iter@SkPath@@QEAAXAEBV2@_N@Z"] pub fn SkPath_Iter_setPath (this : * mut SkPath_Iter , path : * const SkPath , forceClose : bool) ; } extern "C" { # [link_name = "\u{1}?next@Iter@SkPath@@QEAA?AW4Verb@2@QEAUSkPoint@@@Z"] pub fn SkPath_Iter_next (this : * mut SkPath_Iter , pts : * mut SkPoint) -> SkPath_Verb ; } extern "C" { # [link_name = "\u{1}?isClosedContour@Iter@SkPath@@QEBA_NXZ"] pub fn SkPath_Iter_isClosedContour (this : * const SkPath_Iter) -> bool ; } extern "C" { # [link_name = "\u{1}??0Iter@SkPath@@QEAA@XZ"] pub fn SkPath_Iter_Iter (this : * mut SkPath_Iter) ; } extern "C" { # [link_name = "\u{1}??0Iter@SkPath@@QEAA@AEBV1@_N@Z"] pub fn SkPath_Iter_Iter1 (this : * mut SkPath_Iter , path : * const SkPath , forceClose : bool) ; } impl SkPath_Iter { # [inline] pub unsafe fn setPath (& mut self , path : * const SkPath , forceClose : bool) { SkPath_Iter_setPath (self , path , forceClose) } # [inline] pub unsafe fn next (& mut self , pts : * mut SkPoint) -> SkPath_Verb { SkPath_Iter_next (self , pts) } # [inline] pub unsafe fn isClosedContour (& self) -> bool { SkPath_Iter_isClosedContour (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPath_Iter_Iter (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (path : * const SkPath , forceClose : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPath_Iter_Iter1 (__bindgen_tmp . as_mut_ptr () , path , forceClose) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPath_RangeIter { pub fVerb : * const u8 , pub fPoints : * const SkPoint , pub fWeights : * const SkScalar , } # [test] fn bindgen_test_layout_SkPath_RangeIter () { assert_eq ! (:: core :: mem :: size_of :: < SkPath_RangeIter > () , 24usize , concat ! ("Size of: " , stringify ! (SkPath_RangeIter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPath_RangeIter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPath_RangeIter))) ; fn test_field_fVerb () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RangeIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVerb) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPath_RangeIter) , "::" , stringify ! (fVerb))) ; } test_field_fVerb () ; fn test_field_fPoints () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RangeIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPoints) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPath_RangeIter) , "::" , stringify ! (fPoints))) ; } test_field_fPoints () ; fn test_field_fWeights () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RangeIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWeights) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPath_RangeIter) , "::" , stringify ! (fWeights))) ; } test_field_fWeights () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPath_RawIter { pub fIter : SkPath_RangeIter , pub fEnd : SkPath_RangeIter , pub fConicWeight : SkScalar , } # [test] fn bindgen_test_layout_SkPath_RawIter () { assert_eq ! (:: core :: mem :: size_of :: < SkPath_RawIter > () , 56usize , concat ! ("Size of: " , stringify ! (SkPath_RawIter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPath_RawIter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPath_RawIter))) ; fn test_field_fIter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RawIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIter) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPath_RawIter) , "::" , stringify ! (fIter))) ; } test_field_fIter () ; fn test_field_fEnd () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RawIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEnd) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPath_RawIter) , "::" , stringify ! (fEnd))) ; } test_field_fEnd () ; fn test_field_fConicWeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath_RawIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fConicWeight) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkPath_RawIter) , "::" , stringify ! (fConicWeight))) ; } test_field_fConicWeight () ; } extern "C" { # [link_name = "\u{1}?setPath@RawIter@SkPath@@QEAAXAEBV2@@Z"] pub fn SkPath_RawIter_setPath (this : * mut SkPath_RawIter , arg1 : * const SkPath) ; } extern "C" { # [link_name = "\u{1}?next@RawIter@SkPath@@QEAA?AW4Verb@2@QEAUSkPoint@@@Z"] pub fn SkPath_RawIter_next (this : * mut SkPath_RawIter , arg1 : * mut SkPoint) -> SkPath_Verb ; } impl SkPath_RawIter { # [inline] pub unsafe fn setPath (& mut self , arg1 : * const SkPath) { SkPath_RawIter_setPath (self , arg1) } # [inline] pub unsafe fn next (& mut self , arg1 : * mut SkPoint) -> SkPath_Verb { SkPath_RawIter_next (self , arg1) } } # [test] fn bindgen_test_layout_SkPath () { assert_eq ! (:: core :: mem :: size_of :: < SkPath > () , 16usize , concat ! ("Size of: " , stringify ! (SkPath))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPath > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPath))) ; fn test_field_fPathRef () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPathRef) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPath) , "::" , stringify ! (fPathRef))) ; } test_field_fPathRef () ; fn test_field_fLastMoveToIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastMoveToIndex) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPath) , "::" , stringify ! (fLastMoveToIndex))) ; } test_field_fLastMoveToIndex () ; fn test_field_fConvexity () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fConvexity) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkPath) , "::" , stringify ! (fConvexity))) ; } test_field_fConvexity () ; fn test_field_fFirstDirection () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPath > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFirstDirection) as usize - ptr as usize } , 13usize , concat ! ("Offset of field: " , stringify ! (SkPath) , "::" , stringify ! (fFirstDirection))) ; } test_field_fFirstDirection () ; } extern "C" { # [link_name = "\u{1}?Make@SkPath@@SA?AV1@QEBUSkPoint@@HQEBEHQEBMHW4SkPathFillType@@_N@Z"] pub fn SkPath_Make (arg1 : * const SkPoint , pointCount : :: std :: os :: raw :: c_int , arg2 : * const u8 , verbCount : :: std :: os :: raw :: c_int , arg3 : * const SkScalar , conicWeightCount : :: std :: os :: raw :: c_int , arg4 : SkPathFillType , isVolatile : bool) -> SkPath ; } extern "C" { # [link_name = "\u{1}?Rect@SkPath@@SA?AV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_Rect (arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath ; } extern "C" { # [link_name = "\u{1}?Oval@SkPath@@SA?AV1@AEBUSkRect@@W4SkPathDirection@@@Z"] pub fn SkPath_Oval (arg1 : * const SkRect , arg2 : SkPathDirection) -> SkPath ; } extern "C" { # [link_name = "\u{1}?Oval@SkPath@@SA?AV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_Oval1 (arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath ; } extern "C" { # [link_name = "\u{1}?Circle@SkPath@@SA?AV1@MMMW4SkPathDirection@@@Z"] pub fn SkPath_Circle (center_x : SkScalar , center_y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> SkPath ; } extern "C" { # [link_name = "\u{1}?RRect@SkPath@@SA?AV1@AEBVSkRRect@@W4SkPathDirection@@@Z"] pub fn SkPath_RRect (arg1 : * const SkRRect , dir : SkPathDirection) -> SkPath ; } extern "C" { # [link_name = "\u{1}?RRect@SkPath@@SA?AV1@AEBVSkRRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_RRect1 (arg1 : * const SkRRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath ; } extern "C" { # [link_name = "\u{1}?RRect@SkPath@@SA?AV1@AEBUSkRect@@MMW4SkPathDirection@@@Z"] pub fn SkPath_RRect2 (bounds : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPathDirection) -> SkPath ; } extern "C" { # [link_name = "\u{1}?Polygon@SkPath@@SA?AV1@QEBUSkPoint@@H_NW4SkPathFillType@@1@Z"] pub fn SkPath_Polygon (pts : * const SkPoint , count : :: std :: os :: raw :: c_int , isClosed : bool , arg1 : SkPathFillType , isVolatile : bool) -> SkPath ; } extern "C" { # [link_name = "\u{1}?isInterpolatable@SkPath@@QEBA_NAEBV1@@Z"] pub fn SkPath_isInterpolatable (this : * const SkPath , compare : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?interpolate@SkPath@@QEBA_NAEBV1@MPEAV1@@Z"] pub fn SkPath_interpolate (this : * const SkPath , ending : * const SkPath , weight : SkScalar , out : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?isConvex@SkPath@@QEBA_NXZ"] pub fn SkPath_isConvex (this : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?isOval@SkPath@@QEBA_NPEAUSkRect@@@Z"] pub fn SkPath_isOval (this : * const SkPath , bounds : * mut SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?isRRect@SkPath@@QEBA_NPEAVSkRRect@@@Z"] pub fn SkPath_isRRect (this : * const SkPath , rrect : * mut SkRRect) -> bool ; } extern "C" { # [link_name = "\u{1}?reset@SkPath@@QEAAAEAV1@XZ"] pub fn SkPath_reset (this : * mut SkPath) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rewind@SkPath@@QEAAAEAV1@XZ"] pub fn SkPath_rewind (this : * mut SkPath) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?isEmpty@SkPath@@QEBA_NXZ"] pub fn SkPath_isEmpty (this : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?isLastContourClosed@SkPath@@QEBA_NXZ"] pub fn SkPath_isLastContourClosed (this : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?isFinite@SkPath@@QEBA_NXZ"] pub fn SkPath_isFinite (this : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?IsLineDegenerate@SkPath@@SA_NAEBUSkPoint@@0_N@Z"] pub fn SkPath_IsLineDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , exact : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?IsQuadDegenerate@SkPath@@SA_NAEBUSkPoint@@00_N@Z"] pub fn SkPath_IsQuadDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , exact : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?IsCubicDegenerate@SkPath@@SA_NAEBUSkPoint@@000_N@Z"] pub fn SkPath_IsCubicDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , p4 : * const SkPoint , exact : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?isLine@SkPath@@QEBA_NQEAUSkPoint@@@Z"] pub fn SkPath_isLine (this : * const SkPath , line : * mut SkPoint) -> bool ; } extern "C" { # [link_name = "\u{1}?countPoints@SkPath@@QEBAHXZ"] pub fn SkPath_countPoints (this : * const SkPath) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getPoint@SkPath@@QEBA?AUSkPoint@@H@Z"] pub fn SkPath_getPoint (this : * const SkPath , index : :: std :: os :: raw :: c_int) -> SkPoint ; } extern "C" { # [link_name = "\u{1}?getPoints@SkPath@@QEBAHQEAUSkPoint@@H@Z"] pub fn SkPath_getPoints (this : * const SkPath , points : * mut SkPoint , max : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?countVerbs@SkPath@@QEBAHXZ"] pub fn SkPath_countVerbs (this : * const SkPath) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getVerbs@SkPath@@QEBAHQEAEH@Z"] pub fn SkPath_getVerbs (this : * const SkPath , verbs : * mut u8 , max : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?approximateBytesUsed@SkPath@@QEBA_KXZ"] pub fn SkPath_approximateBytesUsed (this : * const SkPath) -> usize ; } extern "C" { # [link_name = "\u{1}?swap@SkPath@@QEAAXAEAV1@@Z"] pub fn SkPath_swap (this : * mut SkPath , other : * mut SkPath) ; } extern "C" { # [link_name = "\u{1}?getBounds@SkPath@@QEBAAEBUSkRect@@XZ"] pub fn SkPath_getBounds (this : * const SkPath) -> * const SkRect ; } extern "C" { # [link_name = "\u{1}?computeTightBounds@SkPath@@QEBA?AUSkRect@@XZ"] pub fn SkPath_computeTightBounds (this : * const SkPath) -> SkRect ; } extern "C" { # [link_name = "\u{1}?conservativelyContainsRect@SkPath@@QEBA_NAEBUSkRect@@@Z"] pub fn SkPath_conservativelyContainsRect (this : * const SkPath , rect : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?incReserve@SkPath@@QEAAXH@Z"] pub fn SkPath_incReserve (this : * mut SkPath , extraPtCount : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?moveTo@SkPath@@QEAAAEAV1@MM@Z"] pub fn SkPath_moveTo (this : * mut SkPath , x : SkScalar , y : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rMoveTo@SkPath@@QEAAAEAV1@MM@Z"] pub fn SkPath_rMoveTo (this : * mut SkPath , dx : SkScalar , dy : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?lineTo@SkPath@@QEAAAEAV1@MM@Z"] pub fn SkPath_lineTo (this : * mut SkPath , x : SkScalar , y : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rLineTo@SkPath@@QEAAAEAV1@MM@Z"] pub fn SkPath_rLineTo (this : * mut SkPath , dx : SkScalar , dy : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?quadTo@SkPath@@QEAAAEAV1@MMMM@Z"] pub fn SkPath_quadTo (this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rQuadTo@SkPath@@QEAAAEAV1@MMMM@Z"] pub fn SkPath_rQuadTo (this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?conicTo@SkPath@@QEAAAEAV1@MMMMM@Z"] pub fn SkPath_conicTo (this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , w : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rConicTo@SkPath@@QEAAAEAV1@MMMMM@Z"] pub fn SkPath_rConicTo (this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , w : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?cubicTo@SkPath@@QEAAAEAV1@MMMMMM@Z"] pub fn SkPath_cubicTo (this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , x3 : SkScalar , y3 : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rCubicTo@SkPath@@QEAAAEAV1@MMMMMM@Z"] pub fn SkPath_rCubicTo (this : * mut SkPath , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , dx3 : SkScalar , dy3 : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPath@@QEAAAEAV1@AEBUSkRect@@MM_N@Z"] pub fn SkPath_arcTo (this : * mut SkPath , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , forceMoveTo : bool) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPath@@QEAAAEAV1@MMMMM@Z"] pub fn SkPath_arcTo1 (this : * mut SkPath , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , radius : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPath@@QEAAAEAV1@MMMW4ArcSize@1@W4SkPathDirection@@MM@Z"] pub fn SkPath_arcTo2 (this : * mut SkPath , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPathDirection , x : SkScalar , y : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?rArcTo@SkPath@@QEAAAEAV1@MMMW4ArcSize@1@W4SkPathDirection@@MM@Z"] pub fn SkPath_rArcTo (this : * mut SkPath , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPathDirection , dx : SkScalar , dy : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?close@SkPath@@QEAAAEAV1@XZ"] pub fn SkPath_close (this : * mut SkPath) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?ConvertConicToQuads@SkPath@@SAHAEBUSkPoint@@00MQEAU2@H@Z"] pub fn SkPath_ConvertConicToQuads (p0 : * const SkPoint , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar , pts : * mut SkPoint , pow2 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?isRect@SkPath@@QEBA_NPEAUSkRect@@PEA_NPEAW4SkPathDirection@@@Z"] pub fn SkPath_isRect (this : * const SkPath , rect : * mut SkRect , isClosed : * mut bool , direction : * mut SkPathDirection) -> bool ; } extern "C" { # [link_name = "\u{1}?addRect@SkPath@@QEAAAEAV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_addRect (this : * mut SkPath , rect : * const SkRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addOval@SkPath@@QEAAAEAV1@AEBUSkRect@@W4SkPathDirection@@@Z"] pub fn SkPath_addOval (this : * mut SkPath , oval : * const SkRect , dir : SkPathDirection) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addOval@SkPath@@QEAAAEAV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_addOval1 (this : * mut SkPath , oval : * const SkRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addCircle@SkPath@@QEAAAEAV1@MMMW4SkPathDirection@@@Z"] pub fn SkPath_addCircle (this : * mut SkPath , x : SkScalar , y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addArc@SkPath@@QEAAAEAV1@AEBUSkRect@@MM@Z"] pub fn SkPath_addArc (this : * mut SkPath , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addRoundRect@SkPath@@QEAAAEAV1@AEBUSkRect@@MMW4SkPathDirection@@@Z"] pub fn SkPath_addRoundRect (this : * mut SkPath , rect : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPathDirection) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addRoundRect@SkPath@@QEAAAEAV1@AEBUSkRect@@QEBMW4SkPathDirection@@@Z"] pub fn SkPath_addRoundRect1 (this : * mut SkPath , rect : * const SkRect , radii : * const SkScalar , dir : SkPathDirection) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addRRect@SkPath@@QEAAAEAV1@AEBVSkRRect@@W4SkPathDirection@@@Z"] pub fn SkPath_addRRect (this : * mut SkPath , rrect : * const SkRRect , dir : SkPathDirection) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addRRect@SkPath@@QEAAAEAV1@AEBVSkRRect@@W4SkPathDirection@@I@Z"] pub fn SkPath_addRRect1 (this : * mut SkPath , rrect : * const SkRRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addPoly@SkPath@@QEAAAEAV1@QEBUSkPoint@@H_N@Z"] pub fn SkPath_addPoly (this : * mut SkPath , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , close : bool) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addPath@SkPath@@QEAAAEAV1@AEBV1@MMW4AddPathMode@1@@Z"] pub fn SkPath_addPath (this : * mut SkPath , src : * const SkPath , dx : SkScalar , dy : SkScalar , mode : SkPath_AddPathMode) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?addPath@SkPath@@QEAAAEAV1@AEBV1@AEBVSkMatrix@@W4AddPathMode@1@@Z"] pub fn SkPath_addPath1 (this : * mut SkPath , src : * const SkPath , matrix : * const SkMatrix , mode : SkPath_AddPathMode) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?reverseAddPath@SkPath@@QEAAAEAV1@AEBV1@@Z"] pub fn SkPath_reverseAddPath (this : * mut SkPath , src : * const SkPath) -> * mut SkPath ; } extern "C" { # [link_name = "\u{1}?offset@SkPath@@QEBAXMMPEAV1@@Z"] pub fn SkPath_offset (this : * const SkPath , dx : SkScalar , dy : SkScalar , dst : * mut SkPath) ; } extern "C" { # [link_name = "\u{1}?transform@SkPath@@QEBAXAEBVSkMatrix@@PEAV1@W4SkApplyPerspectiveClip@@@Z"] pub fn SkPath_transform (this : * const SkPath , matrix : * const SkMatrix , dst : * mut SkPath , pc : SkApplyPerspectiveClip) ; } extern "C" { # [link_name = "\u{1}?getLastPt@SkPath@@QEBA_NPEAUSkPoint@@@Z"] pub fn SkPath_getLastPt (this : * const SkPath , lastPt : * mut SkPoint) -> bool ; } extern "C" { # [link_name = "\u{1}?setLastPt@SkPath@@QEAAXMM@Z"] pub fn SkPath_setLastPt (this : * mut SkPath , x : SkScalar , y : SkScalar) ; } extern "C" { # [link_name = "\u{1}?getSegmentMasks@SkPath@@QEBAIXZ"] pub fn SkPath_getSegmentMasks (this : * const SkPath) -> u32 ; } extern "C" { # [link_name = "\u{1}?contains@SkPath@@QEBA_NMM@Z"] pub fn SkPath_contains (this : * const SkPath , x : SkScalar , y : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?dump@SkPath@@QEBAXPEAVSkWStream@@_N@Z"] pub fn SkPath_dump (this : * const SkPath , stream : * mut SkWStream , dumpAsHex : bool) ; } extern "C" { # [link_name = "\u{1}?dumpArrays@SkPath@@QEBAXPEAVSkWStream@@_N@Z"] pub fn SkPath_dumpArrays (this : * const SkPath , stream : * mut SkWStream , dumpAsHex : bool) ; } extern "C" { # [link_name = "\u{1}?writeToMemory@SkPath@@QEBA_KPEAX@Z"] pub fn SkPath_writeToMemory (this : * const SkPath , buffer : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?serialize@SkPath@@QEBA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkPath_serialize (this : * const SkPath) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?readFromMemory@SkPath@@QEAA_KPEBX_K@Z"] pub fn SkPath_readFromMemory (this : * mut SkPath , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?getGenerationID@SkPath@@QEBAIXZ"] pub fn SkPath_getGenerationID (this : * const SkPath) -> u32 ; } extern "C" { # [link_name = "\u{1}?isValid@SkPath@@QEBA_NXZ"] pub fn SkPath_isValid (this : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}??0SkPath@@QEAA@XZ"] pub fn SkPath_SkPath (this : * mut SkPath) ; } extern "C" { # [link_name = "\u{1}??0SkPath@@QEAA@AEBV0@@Z"] pub fn SkPath_SkPath1 (this : * mut SkPath , path : * const SkPath) ; } impl SkPath { # [inline] pub fn fFillType (& self) -> u8 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 2u8) as u8) } } # [inline] pub fn set_fFillType (& mut self , val : u8) { unsafe { let val : u8 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 2u8 , val as u64) } } # [inline] pub fn fIsVolatile (& self) -> u8 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (2usize , 1u8) as u8) } } # [inline] pub fn set_fIsVolatile (& mut self , val : u8) { unsafe { let val : u8 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (fFillType : u8 , fIsVolatile : u8) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 2u8 , { let fFillType : u8 = unsafe { :: core :: mem :: transmute (fFillType) } ; fFillType as u64 }) ; __bindgen_bitfield_unit . set (2usize , 1u8 , { let fIsVolatile : u8 = unsafe { :: core :: mem :: transmute (fIsVolatile) } ; fIsVolatile as u64 }) ; __bindgen_bitfield_unit } # [inline] pub unsafe fn Make (arg1 : * const SkPoint , pointCount : :: std :: os :: raw :: c_int , arg2 : * const u8 , verbCount : :: std :: os :: raw :: c_int , arg3 : * const SkScalar , conicWeightCount : :: std :: os :: raw :: c_int , arg4 : SkPathFillType , isVolatile : bool) -> SkPath { SkPath_Make (arg1 , pointCount , arg2 , verbCount , arg3 , conicWeightCount , arg4 , isVolatile) } # [inline] pub unsafe fn Rect (arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath { SkPath_Rect (arg1 , arg2 , startIndex) } # [inline] pub unsafe fn Oval (arg1 : * const SkRect , arg2 : SkPathDirection) -> SkPath { SkPath_Oval (arg1 , arg2) } # [inline] pub unsafe fn Oval1 (arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath { SkPath_Oval1 (arg1 , arg2 , startIndex) } # [inline] pub unsafe fn Circle (center_x : SkScalar , center_y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> SkPath { SkPath_Circle (center_x , center_y , radius , dir) } # [inline] pub unsafe fn RRect (arg1 : * const SkRRect , dir : SkPathDirection) -> SkPath { SkPath_RRect (arg1 , dir) } # [inline] pub unsafe fn RRect1 (arg1 : * const SkRRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> SkPath { SkPath_RRect1 (arg1 , arg2 , startIndex) } # [inline] pub unsafe fn RRect2 (bounds : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPathDirection) -> SkPath { SkPath_RRect2 (bounds , rx , ry , dir) } # [inline] pub unsafe fn Polygon (pts : * const SkPoint , count : :: std :: os :: raw :: c_int , isClosed : bool , arg1 : SkPathFillType , isVolatile : bool) -> SkPath { SkPath_Polygon (pts , count , isClosed , arg1 , isVolatile) } # [inline] pub unsafe fn isInterpolatable (& self , compare : * const SkPath) -> bool { SkPath_isInterpolatable (self , compare) } # [inline] pub unsafe fn interpolate (& self , ending : * const SkPath , weight : SkScalar , out : * mut SkPath) -> bool { SkPath_interpolate (self , ending , weight , out) } # [inline] pub unsafe fn isConvex (& self) -> bool { SkPath_isConvex (self) } # [inline] pub unsafe fn isOval (& self , bounds : * mut SkRect) -> bool { SkPath_isOval (self , bounds) } # [inline] pub unsafe fn isRRect (& self , rrect : * mut SkRRect) -> bool { SkPath_isRRect (self , rrect) } # [inline] pub unsafe fn reset (& mut self) -> * mut SkPath { SkPath_reset (self) } # [inline] pub unsafe fn rewind (& mut self) -> * mut SkPath { SkPath_rewind (self) } # [inline] pub unsafe fn isEmpty (& self) -> bool { SkPath_isEmpty (self) } # [inline] pub unsafe fn isLastContourClosed (& self) -> bool { SkPath_isLastContourClosed (self) } # [inline] pub unsafe fn isFinite (& self) -> bool { SkPath_isFinite (self) } # [inline] pub unsafe fn IsLineDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , exact : bool) -> bool { SkPath_IsLineDegenerate (p1 , p2 , exact) } # [inline] pub unsafe fn IsQuadDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , exact : bool) -> bool { SkPath_IsQuadDegenerate (p1 , p2 , p3 , exact) } # [inline] pub unsafe fn IsCubicDegenerate (p1 : * const SkPoint , p2 : * const SkPoint , p3 : * const SkPoint , p4 : * const SkPoint , exact : bool) -> bool { SkPath_IsCubicDegenerate (p1 , p2 , p3 , p4 , exact) } # [inline] pub unsafe fn isLine (& self , line : * mut SkPoint) -> bool { SkPath_isLine (self , line) } # [inline] pub unsafe fn countPoints (& self) -> :: std :: os :: raw :: c_int { SkPath_countPoints (self) } # [inline] pub unsafe fn getPoint (& self , index : :: std :: os :: raw :: c_int) -> SkPoint { SkPath_getPoint (self , index) } # [inline] pub unsafe fn getPoints (& self , points : * mut SkPoint , max : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkPath_getPoints (self , points , max) } # [inline] pub unsafe fn countVerbs (& self) -> :: std :: os :: raw :: c_int { SkPath_countVerbs (self) } # [inline] pub unsafe fn getVerbs (& self , verbs : * mut u8 , max : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkPath_getVerbs (self , verbs , max) } # [inline] pub unsafe fn approximateBytesUsed (& self) -> usize { SkPath_approximateBytesUsed (self) } # [inline] pub unsafe fn swap (& mut self , other : * mut SkPath) { SkPath_swap (self , other) } # [inline] pub unsafe fn getBounds (& self) -> * const SkRect { SkPath_getBounds (self) } # [inline] pub unsafe fn computeTightBounds (& self) -> SkRect { SkPath_computeTightBounds (self) } # [inline] pub unsafe fn conservativelyContainsRect (& self , rect : * const SkRect) -> bool { SkPath_conservativelyContainsRect (self , rect) } # [inline] pub unsafe fn incReserve (& mut self , extraPtCount : :: std :: os :: raw :: c_int) { SkPath_incReserve (self , extraPtCount) } # [inline] pub unsafe fn moveTo (& mut self , x : SkScalar , y : SkScalar) -> * mut SkPath { SkPath_moveTo (self , x , y) } # [inline] pub unsafe fn rMoveTo (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkPath { SkPath_rMoveTo (self , dx , dy) } # [inline] pub unsafe fn lineTo (& mut self , x : SkScalar , y : SkScalar) -> * mut SkPath { SkPath_lineTo (self , x , y) } # [inline] pub unsafe fn rLineTo (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkPath { SkPath_rLineTo (self , dx , dy) } # [inline] pub unsafe fn quadTo (& mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar) -> * mut SkPath { SkPath_quadTo (self , x1 , y1 , x2 , y2) } # [inline] pub unsafe fn rQuadTo (& mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar) -> * mut SkPath { SkPath_rQuadTo (self , dx1 , dy1 , dx2 , dy2) } # [inline] pub unsafe fn conicTo (& mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , w : SkScalar) -> * mut SkPath { SkPath_conicTo (self , x1 , y1 , x2 , y2 , w) } # [inline] pub unsafe fn rConicTo (& mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , w : SkScalar) -> * mut SkPath { SkPath_rConicTo (self , dx1 , dy1 , dx2 , dy2 , w) } # [inline] pub unsafe fn cubicTo (& mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , x3 : SkScalar , y3 : SkScalar) -> * mut SkPath { SkPath_cubicTo (self , x1 , y1 , x2 , y2 , x3 , y3) } # [inline] pub unsafe fn rCubicTo (& mut self , dx1 : SkScalar , dy1 : SkScalar , dx2 : SkScalar , dy2 : SkScalar , dx3 : SkScalar , dy3 : SkScalar) -> * mut SkPath { SkPath_rCubicTo (self , dx1 , dy1 , dx2 , dy2 , dx3 , dy3) } # [inline] pub unsafe fn arcTo (& mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar , forceMoveTo : bool) -> * mut SkPath { SkPath_arcTo (self , oval , startAngle , sweepAngle , forceMoveTo) } # [inline] pub unsafe fn arcTo1 (& mut self , x1 : SkScalar , y1 : SkScalar , x2 : SkScalar , y2 : SkScalar , radius : SkScalar) -> * mut SkPath { SkPath_arcTo1 (self , x1 , y1 , x2 , y2 , radius) } # [inline] pub unsafe fn arcTo2 (& mut self , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPathDirection , x : SkScalar , y : SkScalar) -> * mut SkPath { SkPath_arcTo2 (self , rx , ry , xAxisRotate , largeArc , sweep , x , y) } # [inline] pub unsafe fn rArcTo (& mut self , rx : SkScalar , ry : SkScalar , xAxisRotate : SkScalar , largeArc : SkPath_ArcSize , sweep : SkPathDirection , dx : SkScalar , dy : SkScalar) -> * mut SkPath { SkPath_rArcTo (self , rx , ry , xAxisRotate , largeArc , sweep , dx , dy) } # [inline] pub unsafe fn close (& mut self) -> * mut SkPath { SkPath_close (self) } # [inline] pub unsafe fn ConvertConicToQuads (p0 : * const SkPoint , p1 : * const SkPoint , p2 : * const SkPoint , w : SkScalar , pts : * mut SkPoint , pow2 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkPath_ConvertConicToQuads (p0 , p1 , p2 , w , pts , pow2) } # [inline] pub unsafe fn isRect (& self , rect : * mut SkRect , isClosed : * mut bool , direction : * mut SkPathDirection) -> bool { SkPath_isRect (self , rect , isClosed , direction) } # [inline] pub unsafe fn addRect (& mut self , rect : * const SkRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath { SkPath_addRect (self , rect , dir , start) } # [inline] pub unsafe fn addOval (& mut self , oval : * const SkRect , dir : SkPathDirection) -> * mut SkPath { SkPath_addOval (self , oval , dir) } # [inline] pub unsafe fn addOval1 (& mut self , oval : * const SkRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath { SkPath_addOval1 (self , oval , dir , start) } # [inline] pub unsafe fn addCircle (& mut self , x : SkScalar , y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> * mut SkPath { SkPath_addCircle (self , x , y , radius , dir) } # [inline] pub unsafe fn addArc (& mut self , oval : * const SkRect , startAngle : SkScalar , sweepAngle : SkScalar) -> * mut SkPath { SkPath_addArc (self , oval , startAngle , sweepAngle) } # [inline] pub unsafe fn addRoundRect (& mut self , rect : * const SkRect , rx : SkScalar , ry : SkScalar , dir : SkPathDirection) -> * mut SkPath { SkPath_addRoundRect (self , rect , rx , ry , dir) } # [inline] pub unsafe fn addRoundRect1 (& mut self , rect : * const SkRect , radii : * const SkScalar , dir : SkPathDirection) -> * mut SkPath { SkPath_addRoundRect1 (self , rect , radii , dir) } # [inline] pub unsafe fn addRRect (& mut self , rrect : * const SkRRect , dir : SkPathDirection) -> * mut SkPath { SkPath_addRRect (self , rrect , dir) } # [inline] pub unsafe fn addRRect1 (& mut self , rrect : * const SkRRect , dir : SkPathDirection , start : :: std :: os :: raw :: c_uint) -> * mut SkPath { SkPath_addRRect1 (self , rrect , dir , start) } # [inline] pub unsafe fn addPoly (& mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , close : bool) -> * mut SkPath { SkPath_addPoly (self , pts , count , close) } # [inline] pub unsafe fn addPath (& mut self , src : * const SkPath , dx : SkScalar , dy : SkScalar , mode : SkPath_AddPathMode) -> * mut SkPath { SkPath_addPath (self , src , dx , dy , mode) } # [inline] pub unsafe fn addPath1 (& mut self , src : * const SkPath , matrix : * const SkMatrix , mode : SkPath_AddPathMode) -> * mut SkPath { SkPath_addPath1 (self , src , matrix , mode) } # [inline] pub unsafe fn reverseAddPath (& mut self , src : * const SkPath) -> * mut SkPath { SkPath_reverseAddPath (self , src) } # [inline] pub unsafe fn offset (& self , dx : SkScalar , dy : SkScalar , dst : * mut SkPath) { SkPath_offset (self , dx , dy , dst) } # [inline] pub unsafe fn transform (& self , matrix : * const SkMatrix , dst : * mut SkPath , pc : SkApplyPerspectiveClip) { SkPath_transform (self , matrix , dst , pc) } # [inline] pub unsafe fn getLastPt (& self , lastPt : * mut SkPoint) -> bool { SkPath_getLastPt (self , lastPt) } # [inline] pub unsafe fn setLastPt (& mut self , x : SkScalar , y : SkScalar) { SkPath_setLastPt (self , x , y) } # [inline] pub unsafe fn getSegmentMasks (& self) -> u32 { SkPath_getSegmentMasks (self) } # [inline] pub unsafe fn contains (& self , x : SkScalar , y : SkScalar) -> bool { SkPath_contains (self , x , y) } # [inline] pub unsafe fn dump (& self , stream : * mut SkWStream , dumpAsHex : bool) { SkPath_dump (self , stream , dumpAsHex) } # [inline] pub unsafe fn dumpArrays (& self , stream : * mut SkWStream , dumpAsHex : bool) { SkPath_dumpArrays (self , stream , dumpAsHex) } # [inline] pub unsafe fn writeToMemory (& self , buffer : * mut :: core :: ffi :: c_void) -> usize { SkPath_writeToMemory (self , buffer) } # [inline] pub unsafe fn serialize (& self) -> sk_sp < SkData > { SkPath_serialize (self) } # [inline] pub unsafe fn readFromMemory (& mut self , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize { SkPath_readFromMemory (self , buffer , length) } # [inline] pub unsafe fn getGenerationID (& self) -> u32 { SkPath_getGenerationID (self) } # [inline] pub unsafe fn isValid (& self) -> bool { SkPath_isValid (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPath_SkPath (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (path : * const SkPath) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPath_SkPath1 (__bindgen_tmp . as_mut_ptr () , path) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkTDArray < T > { pub fArray : * mut T , pub fReserve : :: std :: os :: raw :: c_int , pub fCount : :: std :: os :: raw :: c_int , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkContourMeasure { pub _bindgen_opaque_blob : [u64 ; 7usize] , } pub const SkContourMeasure_MatrixFlags_kGetPosition_MatrixFlag : SkContourMeasure_MatrixFlags = 1 ; pub const SkContourMeasure_MatrixFlags_kGetTangent_MatrixFlag : SkContourMeasure_MatrixFlags = 2 ; pub const SkContourMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag : SkContourMeasure_MatrixFlags = 3 ; pub type SkContourMeasure_MatrixFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkContourMeasure_Segment { pub fDistance : SkScalar , pub fPtIndex : :: std :: os :: raw :: c_uint , pub _bitfield_align_1 : [u32 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 4usize] > , } # [test] fn bindgen_test_layout_SkContourMeasure_Segment () { assert_eq ! (:: core :: mem :: size_of :: < SkContourMeasure_Segment > () , 12usize , concat ! ("Size of: " , stringify ! (SkContourMeasure_Segment))) ; assert_eq ! (:: core :: mem :: align_of :: < SkContourMeasure_Segment > () , 4usize , concat ! ("Alignment of " , stringify ! (SkContourMeasure_Segment))) ; fn test_field_fDistance () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkContourMeasure_Segment > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDistance) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkContourMeasure_Segment) , "::" , stringify ! (fDistance))) ; } test_field_fDistance () ; fn test_field_fPtIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkContourMeasure_Segment > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPtIndex) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkContourMeasure_Segment) , "::" , stringify ! (fPtIndex))) ; } test_field_fPtIndex () ; } extern "C" { # [link_name = "\u{1}?getScalarT@Segment@SkContourMeasure@@QEBAMXZ"] pub fn SkContourMeasure_Segment_getScalarT (this : * const SkContourMeasure_Segment) -> SkScalar ; } impl SkContourMeasure_Segment { # [inline] pub fn fTValue (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 30u8) as u32) } } # [inline] pub fn set_fTValue (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 30u8 , val as u64) } } # [inline] pub fn fType (& self) -> :: std :: os :: raw :: c_uint { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (30usize , 2u8) as u32) } } # [inline] pub fn set_fType (& mut self , val : :: std :: os :: raw :: c_uint) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (30usize , 2u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (fTValue : :: std :: os :: raw :: c_uint , fType : :: std :: os :: raw :: c_uint) -> __BindgenBitfieldUnit < [u8 ; 4usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 4usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 30u8 , { let fTValue : u32 = unsafe { :: core :: mem :: transmute (fTValue) } ; fTValue as u64 }) ; __bindgen_bitfield_unit . set (30usize , 2u8 , { let fType : u32 = unsafe { :: core :: mem :: transmute (fType) } ; fType as u64 }) ; __bindgen_bitfield_unit } # [inline] pub unsafe fn getScalarT (& self) -> SkScalar { SkContourMeasure_Segment_getScalarT (self) } } # [test] fn bindgen_test_layout_SkContourMeasure () { assert_eq ! (:: core :: mem :: size_of :: < SkContourMeasure > () , 56usize , concat ! ("Size of: " , stringify ! (SkContourMeasure))) ; assert_eq ! (:: core :: mem :: align_of :: < SkContourMeasure > () , 8usize , concat ! ("Alignment of " , stringify ! (SkContourMeasure))) ; } extern "C" { # [link_name = "\u{1}?getPosTan@SkContourMeasure@@QEBA_NMPEAUSkPoint@@0@Z"] pub fn SkContourMeasure_getPosTan (this : * const SkContourMeasure , distance : SkScalar , position : * mut SkPoint , tangent : * mut SkVector) -> bool ; } extern "C" { # [link_name = "\u{1}?getMatrix@SkContourMeasure@@QEBA_NMPEAVSkMatrix@@W4MatrixFlags@1@@Z"] pub fn SkContourMeasure_getMatrix (this : * const SkContourMeasure , distance : SkScalar , matrix : * mut SkMatrix , flags : SkContourMeasure_MatrixFlags) -> bool ; } extern "C" { # [link_name = "\u{1}?getSegment@SkContourMeasure@@QEBA_NMMPEAVSkPath@@_N@Z"] pub fn SkContourMeasure_getSegment (this : * const SkContourMeasure , startD : SkScalar , stopD : SkScalar , dst : * mut SkPath , startWithMoveTo : bool) -> bool ; } impl SkContourMeasure { # [inline] pub unsafe fn getPosTan (& self , distance : SkScalar , position : * mut SkPoint , tangent : * mut SkVector) -> bool { SkContourMeasure_getPosTan (self , distance , position , tangent) } # [inline] pub unsafe fn getMatrix (& self , distance : SkScalar , matrix : * mut SkMatrix , flags : SkContourMeasure_MatrixFlags) -> bool { SkContourMeasure_getMatrix (self , distance , matrix , flags) } # [inline] pub unsafe fn getSegment (& self , startD : SkScalar , stopD : SkScalar , dst : * mut SkPath , startWithMoveTo : bool) -> bool { SkContourMeasure_getSegment (self , startD , stopD , dst , startWithMoveTo) } } # [repr (C)] # [derive (Debug)] pub struct SkContourMeasureIter { pub fImpl : u64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkContourMeasureIter_Impl { _unused : [u8 ; 0] , } # [test] fn bindgen_test_layout_SkContourMeasureIter () { assert_eq ! (:: core :: mem :: size_of :: < SkContourMeasureIter > () , 8usize , concat ! ("Size of: " , stringify ! (SkContourMeasureIter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkContourMeasureIter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkContourMeasureIter))) ; fn test_field_fImpl () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkContourMeasureIter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImpl) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkContourMeasureIter) , "::" , stringify ! (fImpl))) ; } test_field_fImpl () ; } extern "C" { # [link_name = "\u{1}?reset@SkContourMeasureIter@@QEAAXAEBVSkPath@@_NM@Z"] pub fn SkContourMeasureIter_reset (this : * mut SkContourMeasureIter , path : * const SkPath , forceClosed : bool , resScale : SkScalar) ; } extern "C" { # [link_name = "\u{1}?next@SkContourMeasureIter@@QEAA?AV?$sk_sp@VSkContourMeasure@@@@XZ"] pub fn SkContourMeasureIter_next (this : * mut SkContourMeasureIter) -> sk_sp < SkContourMeasure > ; } extern "C" { # [link_name = "\u{1}??0SkContourMeasureIter@@QEAA@XZ"] pub fn SkContourMeasureIter_SkContourMeasureIter (this : * mut SkContourMeasureIter) ; } extern "C" { # [link_name = "\u{1}??0SkContourMeasureIter@@QEAA@AEBVSkPath@@_NM@Z"] pub fn SkContourMeasureIter_SkContourMeasureIter1 (this : * mut SkContourMeasureIter , path : * const SkPath , forceClosed : bool , resScale : SkScalar) ; } impl SkContourMeasureIter { # [inline] pub unsafe fn reset (& mut self , path : * const SkPath , forceClosed : bool , resScale : SkScalar) { SkContourMeasureIter_reset (self , path , forceClosed , resScale) } # [inline] pub unsafe fn next (& mut self) -> sk_sp < SkContourMeasure > { SkContourMeasureIter_next (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkContourMeasureIter_SkContourMeasureIter (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (path : * const SkPath , forceClosed : bool , resScale : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkContourMeasureIter_SkContourMeasureIter1 (__bindgen_tmp . as_mut_ptr () , path , forceClosed , resScale) ; __bindgen_tmp . assume_init () } } impl SkCoverageMode { pub const Last : SkCoverageMode = SkCoverageMode :: Xor ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCoverageMode { Union = 0 , Intersect = 1 , Difference = 2 , ReverseDifference = 3 , Xor = 4 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCubicMap { pub fCoeff : [SkPoint ; 3usize] , pub fType : SkCubicMap_Type , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkCubicMap_Type { Line = 0 , CubeRoot = 1 , Solver = 2 , } # [test] fn bindgen_test_layout_SkCubicMap () { assert_eq ! (:: core :: mem :: size_of :: < SkCubicMap > () , 28usize , concat ! ("Size of: " , stringify ! (SkCubicMap))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCubicMap > () , 4usize , concat ! ("Alignment of " , stringify ! (SkCubicMap))) ; fn test_field_fCoeff () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCubicMap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCoeff) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCubicMap) , "::" , stringify ! (fCoeff))) ; } test_field_fCoeff () ; fn test_field_fType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCubicMap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fType) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCubicMap) , "::" , stringify ! (fType))) ; } test_field_fType () ; } extern "C" { # [link_name = "\u{1}?computeYFromX@SkCubicMap@@QEBAMM@Z"] pub fn SkCubicMap_computeYFromX (this : * const SkCubicMap , x : f32) -> f32 ; } extern "C" { # [link_name = "\u{1}?computeFromT@SkCubicMap@@QEBA?AUSkPoint@@M@Z"] pub fn SkCubicMap_computeFromT (this : * const SkCubicMap , t : f32) -> SkPoint ; } extern "C" { # [link_name = "\u{1}??0SkCubicMap@@QEAA@USkPoint@@0@Z"] pub fn SkCubicMap_SkCubicMap (this : * mut SkCubicMap , p1 : SkPoint , p2 : SkPoint) ; } impl SkCubicMap { # [inline] pub unsafe fn computeYFromX (& self , x : f32) -> f32 { SkCubicMap_computeYFromX (self , x) } # [inline] pub unsafe fn computeFromT (& self , t : f32) -> SkPoint { SkCubicMap_computeFromT (self , t) } # [inline] pub unsafe fn new (p1 : SkPoint , p2 : SkPoint) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCubicMap_SkCubicMap (__bindgen_tmp . as_mut_ptr () , p1 , p2) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDataTable { pub _bindgen_opaque_blob : [u64 ; 7usize] , } pub type SkDataTable_FreeProc = :: core :: option :: Option < unsafe extern "C" fn (context : * mut :: core :: ffi :: c_void) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDataTable_Dir { pub fPtr : * const :: core :: ffi :: c_void , pub fSize : usize , } # [test] fn bindgen_test_layout_SkDataTable_Dir () { assert_eq ! (:: core :: mem :: size_of :: < SkDataTable_Dir > () , 16usize , concat ! ("Size of: " , stringify ! (SkDataTable_Dir))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDataTable_Dir > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDataTable_Dir))) ; fn test_field_fPtr () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDataTable_Dir > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPtr) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkDataTable_Dir) , "::" , stringify ! (fPtr))) ; } test_field_fPtr () ; fn test_field_fSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDataTable_Dir > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSize) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkDataTable_Dir) , "::" , stringify ! (fSize))) ; } test_field_fSize () ; } # [repr (C)] # [derive (Copy , Clone)] pub union SkDataTable__bindgen_ty_1 { pub fDir : * const SkDataTable_Dir , pub fElems : * const :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_SkDataTable__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < SkDataTable__bindgen_ty_1 > () , 8usize , concat ! ("Size of: " , stringify ! (SkDataTable__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDataTable__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDataTable__bindgen_ty_1))) ; fn test_field_fDir () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDataTable__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDir) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkDataTable__bindgen_ty_1) , "::" , stringify ! (fDir))) ; } test_field_fDir () ; fn test_field_fElems () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDataTable__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fElems) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkDataTable__bindgen_ty_1) , "::" , stringify ! (fElems))) ; } test_field_fElems () ; } pub type SkDataTable_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkDataTable () { assert_eq ! (:: core :: mem :: size_of :: < SkDataTable > () , 56usize , concat ! ("Size of: " , stringify ! (SkDataTable))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDataTable > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDataTable))) ; } extern "C" { # [link_name = "\u{1}?atSize@SkDataTable@@QEBA_KH@Z"] pub fn SkDataTable_atSize (this : * const SkDataTable , index : :: std :: os :: raw :: c_int) -> usize ; } extern "C" { # [link_name = "\u{1}?at@SkDataTable@@QEBAPEBXHPEA_K@Z"] pub fn SkDataTable_at (this : * const SkDataTable , index : :: std :: os :: raw :: c_int , size : * mut usize) -> * const :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?MakeEmpty@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@XZ"] pub fn SkDataTable_MakeEmpty () -> sk_sp < SkDataTable > ; } extern "C" { # [link_name = "\u{1}?MakeCopyArrays@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBQEBXQEB_KH@Z"] pub fn SkDataTable_MakeCopyArrays (ptrs : * const * const :: core :: ffi :: c_void , sizes : * const usize , count : :: std :: os :: raw :: c_int) -> sk_sp < SkDataTable > ; } extern "C" { # [link_name = "\u{1}?MakeCopyArray@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBX_KH@Z"] pub fn SkDataTable_MakeCopyArray (array : * const :: core :: ffi :: c_void , elemSize : usize , count : :: std :: os :: raw :: c_int) -> sk_sp < SkDataTable > ; } extern "C" { # [link_name = "\u{1}?MakeArrayProc@SkDataTable@@SA?AV?$sk_sp@VSkDataTable@@@@PEBX_KHP6AXPEAX@Z2@Z"] pub fn SkDataTable_MakeArrayProc (array : * const :: core :: ffi :: c_void , elemSize : usize , count : :: std :: os :: raw :: c_int , proc_ : SkDataTable_FreeProc , context : * mut :: core :: ffi :: c_void) -> sk_sp < SkDataTable > ; } impl SkDataTable { # [inline] pub unsafe fn atSize (& self , index : :: std :: os :: raw :: c_int) -> usize { SkDataTable_atSize (self , index) } # [inline] pub unsafe fn at (& self , index : :: std :: os :: raw :: c_int , size : * mut usize) -> * const :: core :: ffi :: c_void { SkDataTable_at (self , index , size) } # [inline] pub unsafe fn MakeEmpty () -> sk_sp < SkDataTable > { SkDataTable_MakeEmpty () } # [inline] pub unsafe fn MakeCopyArrays (ptrs : * const * const :: core :: ffi :: c_void , sizes : * const usize , count : :: std :: os :: raw :: c_int) -> sk_sp < SkDataTable > { SkDataTable_MakeCopyArrays (ptrs , sizes , count) } # [inline] pub unsafe fn MakeCopyArray (array : * const :: core :: ffi :: c_void , elemSize : usize , count : :: std :: os :: raw :: c_int) -> sk_sp < SkDataTable > { SkDataTable_MakeCopyArray (array , elemSize , count) } # [inline] pub unsafe fn MakeArrayProc (array : * const :: core :: ffi :: c_void , elemSize : usize , count : :: std :: os :: raw :: c_int , proc_ : SkDataTable_FreeProc , context : * mut :: core :: ffi :: c_void) -> sk_sp < SkDataTable > { SkDataTable_MakeArrayProc (array , elemSize , count , proc_ , context) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBackendSemaphore { _unused : [u8 ; 0] , } impl GrBackendApi { pub const OpenGL_GrBackend : GrBackendApi = GrBackendApi :: OpenGL ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrBackendApi { OpenGL = 0 , Vulkan = 1 , Metal = 2 , Direct3D = 3 , Dawn = 4 , Mock = 5 , } pub use self :: GrBackendApi as GrBackend ; # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrMipmapped { No = 0 , Yes = 1 , } pub use self :: GrMipmapped as GrMipMapped ; # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrRenderable { No = 0 , Yes = 1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrProtected { No = 0 , Yes = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrSurfaceOrigin { TopLeft = 0 , BottomLeft = 1 , } pub const kAll_GrBackendState : u32 = 4294967295 ; pub type GrGpuFinishedContext = * mut :: core :: ffi :: c_void ; pub type GrGpuFinishedProc = :: core :: option :: Option < unsafe extern "C" fn (finishedContext : GrGpuFinishedContext) > ; pub type GrGpuSubmittedContext = * mut :: core :: ffi :: c_void ; pub type GrGpuSubmittedProc = :: core :: option :: Option < unsafe extern "C" fn (submittedContext : GrGpuSubmittedContext , success : bool) > ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrFlushInfo { pub fNumSemaphores : usize , pub fSignalSemaphores : * mut GrBackendSemaphore , pub fFinishedProc : GrGpuFinishedProc , pub fFinishedContext : GrGpuFinishedContext , pub fSubmittedProc : GrGpuSubmittedProc , pub fSubmittedContext : GrGpuSubmittedContext , } # [test] fn bindgen_test_layout_GrFlushInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrFlushInfo > () , 48usize , concat ! ("Size of: " , stringify ! (GrFlushInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrFlushInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrFlushInfo))) ; fn test_field_fNumSemaphores () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNumSemaphores) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fNumSemaphores))) ; } test_field_fNumSemaphores () ; fn test_field_fSignalSemaphores () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSignalSemaphores) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fSignalSemaphores))) ; } test_field_fSignalSemaphores () ; fn test_field_fFinishedProc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFinishedProc) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fFinishedProc))) ; } test_field_fFinishedProc () ; fn test_field_fFinishedContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFinishedContext) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fFinishedContext))) ; } test_field_fFinishedContext () ; fn test_field_fSubmittedProc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubmittedProc) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fSubmittedProc))) ; } test_field_fSubmittedProc () ; fn test_field_fSubmittedContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrFlushInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubmittedContext) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (GrFlushInfo) , "::" , stringify ! (fSubmittedContext))) ; } test_field_fSubmittedContext () ; } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrSemaphoresSubmitted { No = 0 , Yes = 1 , } pub type VkBool32 = u32 ; pub type VkDeviceSize = u64 ; pub type VkFlags = u32 ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkBuffer_T { _unused : [u8 ; 0] , } pub type VkBuffer = * mut VkBuffer_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkImage_T { _unused : [u8 ; 0] , } pub type VkImage = * mut VkImage_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkInstance_T { _unused : [u8 ; 0] , } pub type VkInstance = * mut VkInstance_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkPhysicalDevice_T { _unused : [u8 ; 0] , } pub type VkPhysicalDevice = * mut VkPhysicalDevice_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkDevice_T { _unused : [u8 ; 0] , } pub type VkDevice = * mut VkDevice_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkQueue_T { _unused : [u8 ; 0] , } pub type VkQueue = * mut VkQueue_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkCommandBuffer_T { _unused : [u8 ; 0] , } pub type VkCommandBuffer = * mut VkCommandBuffer_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkDeviceMemory_T { _unused : [u8 ; 0] , } pub type VkDeviceMemory = * mut VkDeviceMemory_T ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkRenderPass_T { _unused : [u8 ; 0] , } pub type VkRenderPass = * mut VkRenderPass_T ; impl VkImageLayout { pub const DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ; } impl VkImageLayout { pub const DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL ; } impl VkImageLayout { pub const FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: SHADING_RATE_OPTIMAL_NV ; } impl VkImageLayout { pub const DEPTH_ATTACHMENT_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: DEPTH_ATTACHMENT_OPTIMAL ; } impl VkImageLayout { pub const DEPTH_READ_ONLY_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: DEPTH_READ_ONLY_OPTIMAL ; } impl VkImageLayout { pub const STENCIL_ATTACHMENT_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: STENCIL_ATTACHMENT_OPTIMAL ; } impl VkImageLayout { pub const STENCIL_READ_ONLY_OPTIMAL_KHR : VkImageLayout = VkImageLayout :: STENCIL_READ_ONLY_OPTIMAL ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkImageLayout { UNDEFINED = 0 , GENERAL = 1 , COLOR_ATTACHMENT_OPTIMAL = 2 , DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3 , DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4 , SHADER_READ_ONLY_OPTIMAL = 5 , TRANSFER_SRC_OPTIMAL = 6 , TRANSFER_DST_OPTIMAL = 7 , PREINITIALIZED = 8 , DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000 , DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001 , DEPTH_ATTACHMENT_OPTIMAL = 1000241000 , DEPTH_READ_ONLY_OPTIMAL = 1000241001 , STENCIL_ATTACHMENT_OPTIMAL = 1000241002 , STENCIL_READ_ONLY_OPTIMAL = 1000241003 , PRESENT_SRC_KHR = 1000001002 , SHARED_PRESENT_KHR = 1000111000 , SHADING_RATE_OPTIMAL_NV = 1000164003 , FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000 , READ_ONLY_OPTIMAL_KHR = 1000314000 , ATTACHMENT_OPTIMAL_KHR = 1000314001 , MAX_ENUM = 2147483647 , } impl VkFormat { pub const G8B8G8R8_422_UNORM_KHR : VkFormat = VkFormat :: G8B8G8R8_422_UNORM ; } impl VkFormat { pub const B8G8R8G8_422_UNORM_KHR : VkFormat = VkFormat :: B8G8R8G8_422_UNORM ; } impl VkFormat { pub const G8_B8_R8_3PLANE_420_UNORM_KHR : VkFormat = VkFormat :: G8_B8_R8_3PLANE_420_UNORM ; } impl VkFormat { pub const G8_B8R8_2PLANE_420_UNORM_KHR : VkFormat = VkFormat :: G8_B8R8_2PLANE_420_UNORM ; } impl VkFormat { pub const G8_B8_R8_3PLANE_422_UNORM_KHR : VkFormat = VkFormat :: G8_B8_R8_3PLANE_422_UNORM ; } impl VkFormat { pub const G8_B8R8_2PLANE_422_UNORM_KHR : VkFormat = VkFormat :: G8_B8R8_2PLANE_422_UNORM ; } impl VkFormat { pub const G8_B8_R8_3PLANE_444_UNORM_KHR : VkFormat = VkFormat :: G8_B8_R8_3PLANE_444_UNORM ; } impl VkFormat { pub const R10X6_UNORM_PACK16_KHR : VkFormat = VkFormat :: R10X6_UNORM_PACK16 ; } impl VkFormat { pub const R10X6G10X6_UNORM_2PACK16_KHR : VkFormat = VkFormat :: R10X6G10X6_UNORM_2PACK16 ; } impl VkFormat { pub const R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR : VkFormat = VkFormat :: R10X6G10X6B10X6A10X6_UNORM_4PACK16 ; } impl VkFormat { pub const G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR : VkFormat = VkFormat :: G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 ; } impl VkFormat { pub const B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR : VkFormat = VkFormat :: B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 ; } impl VkFormat { pub const G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 ; } impl VkFormat { pub const G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 ; } impl VkFormat { pub const G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 ; } impl VkFormat { pub const G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 ; } impl VkFormat { pub const G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 ; } impl VkFormat { pub const R12X4_UNORM_PACK16_KHR : VkFormat = VkFormat :: R12X4_UNORM_PACK16 ; } impl VkFormat { pub const R12X4G12X4_UNORM_2PACK16_KHR : VkFormat = VkFormat :: R12X4G12X4_UNORM_2PACK16 ; } impl VkFormat { pub const R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR : VkFormat = VkFormat :: R12X4G12X4B12X4A12X4_UNORM_4PACK16 ; } impl VkFormat { pub const G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR : VkFormat = VkFormat :: G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 ; } impl VkFormat { pub const B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR : VkFormat = VkFormat :: B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 ; } impl VkFormat { pub const G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 ; } impl VkFormat { pub const G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 ; } impl VkFormat { pub const G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 ; } impl VkFormat { pub const G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 ; } impl VkFormat { pub const G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR : VkFormat = VkFormat :: G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 ; } impl VkFormat { pub const G16B16G16R16_422_UNORM_KHR : VkFormat = VkFormat :: G16B16G16R16_422_UNORM ; } impl VkFormat { pub const B16G16R16G16_422_UNORM_KHR : VkFormat = VkFormat :: B16G16R16G16_422_UNORM ; } impl VkFormat { pub const G16_B16_R16_3PLANE_420_UNORM_KHR : VkFormat = VkFormat :: G16_B16_R16_3PLANE_420_UNORM ; } impl VkFormat { pub const G16_B16R16_2PLANE_420_UNORM_KHR : VkFormat = VkFormat :: G16_B16R16_2PLANE_420_UNORM ; } impl VkFormat { pub const G16_B16_R16_3PLANE_422_UNORM_KHR : VkFormat = VkFormat :: G16_B16_R16_3PLANE_422_UNORM ; } impl VkFormat { pub const G16_B16R16_2PLANE_422_UNORM_KHR : VkFormat = VkFormat :: G16_B16R16_2PLANE_422_UNORM ; } impl VkFormat { pub const G16_B16_R16_3PLANE_444_UNORM_KHR : VkFormat = VkFormat :: G16_B16_R16_3PLANE_444_UNORM ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkFormat { UNDEFINED = 0 , R4G4_UNORM_PACK8 = 1 , R4G4B4A4_UNORM_PACK16 = 2 , B4G4R4A4_UNORM_PACK16 = 3 , R5G6B5_UNORM_PACK16 = 4 , B5G6R5_UNORM_PACK16 = 5 , R5G5B5A1_UNORM_PACK16 = 6 , B5G5R5A1_UNORM_PACK16 = 7 , A1R5G5B5_UNORM_PACK16 = 8 , R8_UNORM = 9 , R8_SNORM = 10 , R8_USCALED = 11 , R8_SSCALED = 12 , R8_UINT = 13 , R8_SINT = 14 , R8_SRGB = 15 , R8G8_UNORM = 16 , R8G8_SNORM = 17 , R8G8_USCALED = 18 , R8G8_SSCALED = 19 , R8G8_UINT = 20 , R8G8_SINT = 21 , R8G8_SRGB = 22 , R8G8B8_UNORM = 23 , R8G8B8_SNORM = 24 , R8G8B8_USCALED = 25 , R8G8B8_SSCALED = 26 , R8G8B8_UINT = 27 , R8G8B8_SINT = 28 , R8G8B8_SRGB = 29 , B8G8R8_UNORM = 30 , B8G8R8_SNORM = 31 , B8G8R8_USCALED = 32 , B8G8R8_SSCALED = 33 , B8G8R8_UINT = 34 , B8G8R8_SINT = 35 , B8G8R8_SRGB = 36 , R8G8B8A8_UNORM = 37 , R8G8B8A8_SNORM = 38 , R8G8B8A8_USCALED = 39 , R8G8B8A8_SSCALED = 40 , R8G8B8A8_UINT = 41 , R8G8B8A8_SINT = 42 , R8G8B8A8_SRGB = 43 , B8G8R8A8_UNORM = 44 , B8G8R8A8_SNORM = 45 , B8G8R8A8_USCALED = 46 , B8G8R8A8_SSCALED = 47 , B8G8R8A8_UINT = 48 , B8G8R8A8_SINT = 49 , B8G8R8A8_SRGB = 50 , A8B8G8R8_UNORM_PACK32 = 51 , A8B8G8R8_SNORM_PACK32 = 52 , A8B8G8R8_USCALED_PACK32 = 53 , A8B8G8R8_SSCALED_PACK32 = 54 , A8B8G8R8_UINT_PACK32 = 55 , A8B8G8R8_SINT_PACK32 = 56 , A8B8G8R8_SRGB_PACK32 = 57 , A2R10G10B10_UNORM_PACK32 = 58 , A2R10G10B10_SNORM_PACK32 = 59 , A2R10G10B10_USCALED_PACK32 = 60 , A2R10G10B10_SSCALED_PACK32 = 61 , A2R10G10B10_UINT_PACK32 = 62 , A2R10G10B10_SINT_PACK32 = 63 , A2B10G10R10_UNORM_PACK32 = 64 , A2B10G10R10_SNORM_PACK32 = 65 , A2B10G10R10_USCALED_PACK32 = 66 , A2B10G10R10_SSCALED_PACK32 = 67 , A2B10G10R10_UINT_PACK32 = 68 , A2B10G10R10_SINT_PACK32 = 69 , R16_UNORM = 70 , R16_SNORM = 71 , R16_USCALED = 72 , R16_SSCALED = 73 , R16_UINT = 74 , R16_SINT = 75 , R16_SFLOAT = 76 , R16G16_UNORM = 77 , R16G16_SNORM = 78 , R16G16_USCALED = 79 , R16G16_SSCALED = 80 , R16G16_UINT = 81 , R16G16_SINT = 82 , R16G16_SFLOAT = 83 , R16G16B16_UNORM = 84 , R16G16B16_SNORM = 85 , R16G16B16_USCALED = 86 , R16G16B16_SSCALED = 87 , R16G16B16_UINT = 88 , R16G16B16_SINT = 89 , R16G16B16_SFLOAT = 90 , R16G16B16A16_UNORM = 91 , R16G16B16A16_SNORM = 92 , R16G16B16A16_USCALED = 93 , R16G16B16A16_SSCALED = 94 , R16G16B16A16_UINT = 95 , R16G16B16A16_SINT = 96 , R16G16B16A16_SFLOAT = 97 , R32_UINT = 98 , R32_SINT = 99 , R32_SFLOAT = 100 , R32G32_UINT = 101 , R32G32_SINT = 102 , R32G32_SFLOAT = 103 , R32G32B32_UINT = 104 , R32G32B32_SINT = 105 , R32G32B32_SFLOAT = 106 , R32G32B32A32_UINT = 107 , R32G32B32A32_SINT = 108 , R32G32B32A32_SFLOAT = 109 , R64_UINT = 110 , R64_SINT = 111 , R64_SFLOAT = 112 , R64G64_UINT = 113 , R64G64_SINT = 114 , R64G64_SFLOAT = 115 , R64G64B64_UINT = 116 , R64G64B64_SINT = 117 , R64G64B64_SFLOAT = 118 , R64G64B64A64_UINT = 119 , R64G64B64A64_SINT = 120 , R64G64B64A64_SFLOAT = 121 , B10G11R11_UFLOAT_PACK32 = 122 , E5B9G9R9_UFLOAT_PACK32 = 123 , D16_UNORM = 124 , X8_D24_UNORM_PACK32 = 125 , D32_SFLOAT = 126 , S8_UINT = 127 , D16_UNORM_S8_UINT = 128 , D24_UNORM_S8_UINT = 129 , D32_SFLOAT_S8_UINT = 130 , BC1_RGB_UNORM_BLOCK = 131 , BC1_RGB_SRGB_BLOCK = 132 , BC1_RGBA_UNORM_BLOCK = 133 , BC1_RGBA_SRGB_BLOCK = 134 , BC2_UNORM_BLOCK = 135 , BC2_SRGB_BLOCK = 136 , BC3_UNORM_BLOCK = 137 , BC3_SRGB_BLOCK = 138 , BC4_UNORM_BLOCK = 139 , BC4_SNORM_BLOCK = 140 , BC5_UNORM_BLOCK = 141 , BC5_SNORM_BLOCK = 142 , BC6H_UFLOAT_BLOCK = 143 , BC6H_SFLOAT_BLOCK = 144 , BC7_UNORM_BLOCK = 145 , BC7_SRGB_BLOCK = 146 , ETC2_R8G8B8_UNORM_BLOCK = 147 , ETC2_R8G8B8_SRGB_BLOCK = 148 , ETC2_R8G8B8A1_UNORM_BLOCK = 149 , ETC2_R8G8B8A1_SRGB_BLOCK = 150 , ETC2_R8G8B8A8_UNORM_BLOCK = 151 , ETC2_R8G8B8A8_SRGB_BLOCK = 152 , EAC_R11_UNORM_BLOCK = 153 , EAC_R11_SNORM_BLOCK = 154 , EAC_R11G11_UNORM_BLOCK = 155 , EAC_R11G11_SNORM_BLOCK = 156 , ASTC_4x4_UNORM_BLOCK = 157 , ASTC_4x4_SRGB_BLOCK = 158 , ASTC_5x4_UNORM_BLOCK = 159 , ASTC_5x4_SRGB_BLOCK = 160 , ASTC_5x5_UNORM_BLOCK = 161 , ASTC_5x5_SRGB_BLOCK = 162 , ASTC_6x5_UNORM_BLOCK = 163 , ASTC_6x5_SRGB_BLOCK = 164 , ASTC_6x6_UNORM_BLOCK = 165 , ASTC_6x6_SRGB_BLOCK = 166 , ASTC_8x5_UNORM_BLOCK = 167 , ASTC_8x5_SRGB_BLOCK = 168 , ASTC_8x6_UNORM_BLOCK = 169 , ASTC_8x6_SRGB_BLOCK = 170 , ASTC_8x8_UNORM_BLOCK = 171 , ASTC_8x8_SRGB_BLOCK = 172 , ASTC_10x5_UNORM_BLOCK = 173 , ASTC_10x5_SRGB_BLOCK = 174 , ASTC_10x6_UNORM_BLOCK = 175 , ASTC_10x6_SRGB_BLOCK = 176 , ASTC_10x8_UNORM_BLOCK = 177 , ASTC_10x8_SRGB_BLOCK = 178 , ASTC_10x10_UNORM_BLOCK = 179 , ASTC_10x10_SRGB_BLOCK = 180 , ASTC_12x10_UNORM_BLOCK = 181 , ASTC_12x10_SRGB_BLOCK = 182 , ASTC_12x12_UNORM_BLOCK = 183 , ASTC_12x12_SRGB_BLOCK = 184 , G8B8G8R8_422_UNORM = 1000156000 , B8G8R8G8_422_UNORM = 1000156001 , G8_B8_R8_3PLANE_420_UNORM = 1000156002 , G8_B8R8_2PLANE_420_UNORM = 1000156003 , G8_B8_R8_3PLANE_422_UNORM = 1000156004 , G8_B8R8_2PLANE_422_UNORM = 1000156005 , G8_B8_R8_3PLANE_444_UNORM = 1000156006 , R10X6_UNORM_PACK16 = 1000156007 , R10X6G10X6_UNORM_2PACK16 = 1000156008 , R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009 , G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010 , B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011 , G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012 , G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013 , G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014 , G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015 , G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016 , R12X4_UNORM_PACK16 = 1000156017 , R12X4G12X4_UNORM_2PACK16 = 1000156018 , R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019 , G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020 , B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021 , G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022 , G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023 , G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024 , G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025 , G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026 , G16B16G16R16_422_UNORM = 1000156027 , B16G16R16G16_422_UNORM = 1000156028 , G16_B16_R16_3PLANE_420_UNORM = 1000156029 , G16_B16R16_2PLANE_420_UNORM = 1000156030 , G16_B16_R16_3PLANE_422_UNORM = 1000156031 , G16_B16R16_2PLANE_422_UNORM = 1000156032 , G16_B16_R16_3PLANE_444_UNORM = 1000156033 , PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000 , PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001 , PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002 , PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003 , PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004 , PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005 , PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006 , PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007 , ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000 , ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001 , ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002 , ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003 , ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004 , ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005 , ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006 , ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007 , ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008 , ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009 , ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010 , ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011 , ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012 , ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013 , G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000 , G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001 , G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002 , G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003 , A4R4G4B4_UNORM_PACK16_EXT = 1000340000 , A4B4G4R4_UNORM_PACK16_EXT = 1000340001 , MAX_ENUM = 2147483647 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkImageTiling { OPTIMAL = 0 , LINEAR = 1 , DRM_FORMAT_MODIFIER_EXT = 1000158000 , MAX_ENUM = 2147483647 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkSharingMode { EXCLUSIVE = 0 , CONCURRENT = 1 , MAX_ENUM = 2147483647 , } impl VkFilter { pub const CUBIC_EXT : VkFilter = VkFilter :: CUBIC_IMG ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkFilter { NEAREST = 0 , LINEAR = 1 , CUBIC_IMG = 1000015000 , MAX_ENUM = 2147483647 , } pub type VkFormatFeatureFlags = VkFlags ; pub type VkImageUsageFlags = VkFlags ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkExtent2D { pub width : u32 , pub height : u32 , } # [test] fn bindgen_test_layout_VkExtent2D () { assert_eq ! (:: core :: mem :: size_of :: < VkExtent2D > () , 8usize , concat ! ("Size of: " , stringify ! (VkExtent2D))) ; assert_eq ! (:: core :: mem :: align_of :: < VkExtent2D > () , 4usize , concat ! ("Alignment of " , stringify ! (VkExtent2D))) ; fn test_field_width () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkExtent2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . width) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (VkExtent2D) , "::" , stringify ! (width))) ; } test_field_width () ; fn test_field_height () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkExtent2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . height) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (VkExtent2D) , "::" , stringify ! (height))) ; } test_field_height () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkOffset2D { pub x : i32 , pub y : i32 , } # [test] fn bindgen_test_layout_VkOffset2D () { assert_eq ! (:: core :: mem :: size_of :: < VkOffset2D > () , 8usize , concat ! ("Size of: " , stringify ! (VkOffset2D))) ; assert_eq ! (:: core :: mem :: align_of :: < VkOffset2D > () , 4usize , concat ! ("Alignment of " , stringify ! (VkOffset2D))) ; fn test_field_x () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkOffset2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . x) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (VkOffset2D) , "::" , stringify ! (x))) ; } test_field_x () ; fn test_field_y () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkOffset2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . y) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (VkOffset2D) , "::" , stringify ! (y))) ; } test_field_y () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct VkRect2D { pub offset : VkOffset2D , pub extent : VkExtent2D , } # [test] fn bindgen_test_layout_VkRect2D () { assert_eq ! (:: core :: mem :: size_of :: < VkRect2D > () , 16usize , concat ! ("Size of: " , stringify ! (VkRect2D))) ; assert_eq ! (:: core :: mem :: align_of :: < VkRect2D > () , 4usize , concat ! ("Alignment of " , stringify ! (VkRect2D))) ; fn test_field_offset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkRect2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . offset) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (VkRect2D) , "::" , stringify ! (offset))) ; } test_field_offset () ; fn test_field_extent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < VkRect2D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . extent) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (VkRect2D) , "::" , stringify ! (extent))) ; } test_field_extent () ; } pub type PFN_vkVoidFunction = :: core :: option :: Option < unsafe extern "C" fn () > ; # [repr (C)] # [repr (align (4))] pub struct VkPhysicalDeviceFeatures { pub _bindgen_opaque_blob : [u32 ; 55usize] , } # [test] fn bindgen_test_layout_VkPhysicalDeviceFeatures () { assert_eq ! (:: core :: mem :: size_of :: < VkPhysicalDeviceFeatures > () , 220usize , concat ! ("Size of: " , stringify ! (VkPhysicalDeviceFeatures))) ; assert_eq ! (:: core :: mem :: align_of :: < VkPhysicalDeviceFeatures > () , 4usize , concat ! ("Alignment of " , stringify ! (VkPhysicalDeviceFeatures))) ; } impl VkSamplerYcbcrModelConversion { pub const RGB_IDENTITY_KHR : VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion :: RGB_IDENTITY ; } impl VkSamplerYcbcrModelConversion { pub const YCBCR_IDENTITY_KHR : VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion :: YCBCR_IDENTITY ; } impl VkSamplerYcbcrModelConversion { pub const YCBCR_709_KHR : VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion :: YCBCR_709 ; } impl VkSamplerYcbcrModelConversion { pub const YCBCR_601_KHR : VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion :: YCBCR_601 ; } impl VkSamplerYcbcrModelConversion { pub const YCBCR_2020_KHR : VkSamplerYcbcrModelConversion = VkSamplerYcbcrModelConversion :: YCBCR_2020 ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkSamplerYcbcrModelConversion { RGB_IDENTITY = 0 , YCBCR_IDENTITY = 1 , YCBCR_709 = 2 , YCBCR_601 = 3 , YCBCR_2020 = 4 , MAX_ENUM = 2147483647 , } impl VkSamplerYcbcrRange { pub const ITU_FULL_KHR : VkSamplerYcbcrRange = VkSamplerYcbcrRange :: ITU_FULL ; } impl VkSamplerYcbcrRange { pub const ITU_NARROW_KHR : VkSamplerYcbcrRange = VkSamplerYcbcrRange :: ITU_NARROW ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkSamplerYcbcrRange { ITU_FULL = 0 , ITU_NARROW = 1 , MAX_ENUM = 2147483647 , } impl VkChromaLocation { pub const COSITED_EVEN_KHR : VkChromaLocation = VkChromaLocation :: COSITED_EVEN ; } impl VkChromaLocation { pub const MIDPOINT_KHR : VkChromaLocation = VkChromaLocation :: MIDPOINT ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum VkChromaLocation { COSITED_EVEN = 0 , MIDPOINT = 1 , MAX_ENUM = 2147483647 , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct VkPhysicalDeviceFeatures2 { pub _bindgen_opaque_blob : [u64 ; 30usize] , } # [test] fn bindgen_test_layout_VkPhysicalDeviceFeatures2 () { assert_eq ! (:: core :: mem :: size_of :: < VkPhysicalDeviceFeatures2 > () , 240usize , concat ! ("Size of: " , stringify ! (VkPhysicalDeviceFeatures2))) ; assert_eq ! (:: core :: mem :: align_of :: < VkPhysicalDeviceFeatures2 > () , 8usize , concat ! ("Alignment of " , stringify ! (VkPhysicalDeviceFeatures2))) ; } pub type GrVkBackendMemory = isize ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkAlloc { pub fMemory : VkDeviceMemory , pub fOffset : VkDeviceSize , pub fSize : VkDeviceSize , pub fFlags : u32 , pub fBackendMemory : GrVkBackendMemory , pub fUsesSystemHeap : bool , } pub const GrVkAlloc_Flag_kNoncoherent_Flag : GrVkAlloc_Flag = 1 ; pub const GrVkAlloc_Flag_kMappable_Flag : GrVkAlloc_Flag = 2 ; pub const GrVkAlloc_Flag_kLazilyAllocated_Flag : GrVkAlloc_Flag = 4 ; pub type GrVkAlloc_Flag = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_GrVkAlloc () { assert_eq ! (:: core :: mem :: size_of :: < GrVkAlloc > () , 48usize , concat ! ("Size of: " , stringify ! (GrVkAlloc))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkAlloc > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkAlloc))) ; fn test_field_fMemory () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMemory) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fMemory))) ; } test_field_fMemory () ; fn test_field_fOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOffset) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fOffset))) ; } test_field_fOffset () ; fn test_field_fSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSize) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fSize))) ; } test_field_fSize () ; fn test_field_fFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFlags) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fFlags))) ; } test_field_fFlags () ; fn test_field_fBackendMemory () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackendMemory) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fBackendMemory))) ; } test_field_fBackendMemory () ; fn test_field_fUsesSystemHeap () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkAlloc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUsesSystemHeap) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (GrVkAlloc) , "::" , stringify ! (fUsesSystemHeap))) ; } test_field_fUsesSystemHeap () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkYcbcrConversionInfo { pub fFormat : VkFormat , pub fExternalFormat : u64 , pub fYcbcrModel : VkSamplerYcbcrModelConversion , pub fYcbcrRange : VkSamplerYcbcrRange , pub fXChromaOffset : VkChromaLocation , pub fYChromaOffset : VkChromaLocation , pub fChromaFilter : VkFilter , pub fForceExplicitReconstruction : VkBool32 , pub fFormatFeatures : VkFormatFeatureFlags , } # [test] fn bindgen_test_layout_GrVkYcbcrConversionInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkYcbcrConversionInfo > () , 48usize , concat ! ("Size of: " , stringify ! (GrVkYcbcrConversionInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkYcbcrConversionInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkYcbcrConversionInfo))) ; fn test_field_fFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormat) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fFormat))) ; } test_field_fFormat () ; fn test_field_fExternalFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExternalFormat) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fExternalFormat))) ; } test_field_fExternalFormat () ; fn test_field_fYcbcrModel () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYcbcrModel) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fYcbcrModel))) ; } test_field_fYcbcrModel () ; fn test_field_fYcbcrRange () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYcbcrRange) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fYcbcrRange))) ; } test_field_fYcbcrRange () ; fn test_field_fXChromaOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXChromaOffset) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fXChromaOffset))) ; } test_field_fXChromaOffset () ; fn test_field_fYChromaOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYChromaOffset) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fYChromaOffset))) ; } test_field_fYChromaOffset () ; fn test_field_fChromaFilter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fChromaFilter) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fChromaFilter))) ; } test_field_fChromaFilter () ; fn test_field_fForceExplicitReconstruction () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fForceExplicitReconstruction) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fForceExplicitReconstruction))) ; } test_field_fForceExplicitReconstruction () ; fn test_field_fFormatFeatures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkYcbcrConversionInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormatFeatures) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (GrVkYcbcrConversionInfo) , "::" , stringify ! (fFormatFeatures))) ; } test_field_fFormatFeatures () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkImageInfo { pub fImage : VkImage , pub fAlloc : GrVkAlloc , pub fImageTiling : VkImageTiling , pub fImageLayout : VkImageLayout , pub fFormat : VkFormat , pub fImageUsageFlags : VkImageUsageFlags , pub fSampleCount : u32 , pub fLevelCount : u32 , pub fCurrentQueueFamily : u32 , pub fProtected : GrProtected , pub fYcbcrConversionInfo : GrVkYcbcrConversionInfo , pub fSharingMode : VkSharingMode , } # [test] fn bindgen_test_layout_GrVkImageInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkImageInfo > () , 144usize , concat ! ("Size of: " , stringify ! (GrVkImageInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkImageInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkImageInfo))) ; fn test_field_fImage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImage) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fImage))) ; } test_field_fImage () ; fn test_field_fAlloc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlloc) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fAlloc))) ; } test_field_fAlloc () ; fn test_field_fImageTiling () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageTiling) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fImageTiling))) ; } test_field_fImageTiling () ; fn test_field_fImageLayout () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageLayout) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fImageLayout))) ; } test_field_fImageLayout () ; fn test_field_fFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormat) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fFormat))) ; } test_field_fFormat () ; fn test_field_fImageUsageFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageUsageFlags) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fImageUsageFlags))) ; } test_field_fImageUsageFlags () ; fn test_field_fSampleCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSampleCount) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fSampleCount))) ; } test_field_fSampleCount () ; fn test_field_fLevelCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLevelCount) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fLevelCount))) ; } test_field_fLevelCount () ; fn test_field_fCurrentQueueFamily () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCurrentQueueFamily) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fCurrentQueueFamily))) ; } test_field_fCurrentQueueFamily () ; fn test_field_fProtected () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProtected) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fProtected))) ; } test_field_fProtected () ; fn test_field_fYcbcrConversionInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYcbcrConversionInfo) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fYcbcrConversionInfo))) ; } test_field_fYcbcrConversionInfo () ; fn test_field_fSharingMode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSharingMode) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (GrVkImageInfo) , "::" , stringify ! (fSharingMode))) ; } test_field_fSharingMode () ; } pub type GrVkGetProc = [u64 ; 8usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkDrawableInfo { pub fSecondaryCommandBuffer : VkCommandBuffer , pub fColorAttachmentIndex : u32 , pub fCompatibleRenderPass : VkRenderPass , pub fFormat : VkFormat , pub fDrawBounds : * mut VkRect2D , } # [test] fn bindgen_test_layout_GrVkDrawableInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkDrawableInfo > () , 40usize , concat ! ("Size of: " , stringify ! (GrVkDrawableInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkDrawableInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkDrawableInfo))) ; fn test_field_fSecondaryCommandBuffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSecondaryCommandBuffer) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkDrawableInfo) , "::" , stringify ! (fSecondaryCommandBuffer))) ; } test_field_fSecondaryCommandBuffer () ; fn test_field_fColorAttachmentIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorAttachmentIndex) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkDrawableInfo) , "::" , stringify ! (fColorAttachmentIndex))) ; } test_field_fColorAttachmentIndex () ; fn test_field_fCompatibleRenderPass () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCompatibleRenderPass) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrVkDrawableInfo) , "::" , stringify ! (fCompatibleRenderPass))) ; } test_field_fCompatibleRenderPass () ; fn test_field_fFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormat) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrVkDrawableInfo) , "::" , stringify ! (fFormat))) ; } test_field_fFormat () ; fn test_field_fDrawBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDrawBounds) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrVkDrawableInfo) , "::" , stringify ! (fDrawBounds))) ; } test_field_fDrawBounds () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkSurfaceInfo { pub fSampleCount : u32 , pub fLevelCount : u32 , pub fProtected : GrProtected , pub fImageTiling : VkImageTiling , pub fFormat : VkFormat , pub fImageUsageFlags : VkImageUsageFlags , pub fYcbcrConversionInfo : GrVkYcbcrConversionInfo , pub fSharingMode : VkSharingMode , } # [test] fn bindgen_test_layout_GrVkSurfaceInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkSurfaceInfo > () , 80usize , concat ! ("Size of: " , stringify ! (GrVkSurfaceInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkSurfaceInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkSurfaceInfo))) ; fn test_field_fSampleCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSampleCount) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fSampleCount))) ; } test_field_fSampleCount () ; fn test_field_fLevelCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLevelCount) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fLevelCount))) ; } test_field_fLevelCount () ; fn test_field_fProtected () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProtected) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fProtected))) ; } test_field_fProtected () ; fn test_field_fImageTiling () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageTiling) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fImageTiling))) ; } test_field_fImageTiling () ; fn test_field_fFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormat) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fFormat))) ; } test_field_fFormat () ; fn test_field_fImageUsageFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageUsageFlags) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fImageUsageFlags))) ; } test_field_fImageUsageFlags () ; fn test_field_fYcbcrConversionInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYcbcrConversionInfo) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fYcbcrConversionInfo))) ; } test_field_fYcbcrConversionInfo () ; fn test_field_fSharingMode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSharingMode) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (GrVkSurfaceInfo) , "::" , stringify ! (fSharingMode))) ; } test_field_fSharingMode () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBackendSurfaceMutableStateImpl { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkBackendSurfaceInfo { pub fImageInfo : GrVkImageInfo , } # [test] fn bindgen_test_layout_GrVkBackendSurfaceInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkBackendSurfaceInfo > () , 144usize , concat ! ("Size of: " , stringify ! (GrVkBackendSurfaceInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkBackendSurfaceInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkBackendSurfaceInfo))) ; fn test_field_fImageInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendSurfaceInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendSurfaceInfo) , "::" , stringify ! (fImageInfo))) ; } test_field_fImageInfo () ; } extern "C" { # [link_name = "\u{1}?cleanup@GrVkBackendSurfaceInfo@@QEAAXXZ"] pub fn GrVkBackendSurfaceInfo_cleanup (this : * mut GrVkBackendSurfaceInfo) ; } extern "C" { # [link_name = "\u{1}?assign@GrVkBackendSurfaceInfo@@QEAAXAEBU1@_N@Z"] pub fn GrVkBackendSurfaceInfo_assign (this : * mut GrVkBackendSurfaceInfo , arg1 : * const GrVkBackendSurfaceInfo , isValid : bool) ; } extern "C" { # [link_name = "\u{1}?snapImageInfo@GrVkBackendSurfaceInfo@@QEBA?AUGrVkImageInfo@@PEBVGrBackendSurfaceMutableStateImpl@@@Z"] pub fn GrVkBackendSurfaceInfo_snapImageInfo (this : * const GrVkBackendSurfaceInfo , arg1 : * const GrBackendSurfaceMutableStateImpl) -> GrVkImageInfo ; } impl GrVkBackendSurfaceInfo { # [inline] pub unsafe fn cleanup (& mut self) { GrVkBackendSurfaceInfo_cleanup (self) } # [inline] pub unsafe fn assign (& mut self , arg1 : * const GrVkBackendSurfaceInfo , isValid : bool) { GrVkBackendSurfaceInfo_assign (self , arg1 , isValid) } # [inline] pub unsafe fn snapImageInfo (& self , arg1 : * const GrBackendSurfaceMutableStateImpl) -> GrVkImageInfo { GrVkBackendSurfaceInfo_snapImageInfo (self , arg1) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkSharedImageInfo { pub fLayout : u32 , pub fQueueFamilyIndex : u32 , } # [test] fn bindgen_test_layout_GrVkSharedImageInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrVkSharedImageInfo > () , 8usize , concat ! ("Size of: " , stringify ! (GrVkSharedImageInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkSharedImageInfo > () , 4usize , concat ! ("Alignment of " , stringify ! (GrVkSharedImageInfo))) ; fn test_field_fLayout () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSharedImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLayout) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkSharedImageInfo) , "::" , stringify ! (fLayout))) ; } test_field_fLayout () ; fn test_field_fQueueFamilyIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkSharedImageInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fQueueFamilyIndex) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrVkSharedImageInfo) , "::" , stringify ! (fQueueFamilyIndex))) ; } test_field_fQueueFamilyIndex () ; } # [repr (C)] # [derive (Copy , Clone)] pub struct GrBackendSurfaceMutableState { pub __bindgen_anon_1 : GrBackendSurfaceMutableState__bindgen_ty_1 , pub fBackend : GrBackend , pub fIsValid : bool , } # [repr (C)] # [derive (Copy , Clone)] pub union GrBackendSurfaceMutableState__bindgen_ty_1 { pub fPlaceholder : :: std :: os :: raw :: c_char , pub fVkState : GrVkSharedImageInfo , } # [test] fn bindgen_test_layout_GrBackendSurfaceMutableState__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendSurfaceMutableState__bindgen_ty_1 > () , 8usize , concat ! ("Size of: " , stringify ! (GrBackendSurfaceMutableState__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendSurfaceMutableState__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (GrBackendSurfaceMutableState__bindgen_ty_1))) ; fn test_field_fPlaceholder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendSurfaceMutableState__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPlaceholder) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendSurfaceMutableState__bindgen_ty_1) , "::" , stringify ! (fPlaceholder))) ; } test_field_fPlaceholder () ; fn test_field_fVkState () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendSurfaceMutableState__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkState) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendSurfaceMutableState__bindgen_ty_1) , "::" , stringify ! (fVkState))) ; } test_field_fVkState () ; } # [test] fn bindgen_test_layout_GrBackendSurfaceMutableState () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendSurfaceMutableState > () , 16usize , concat ! ("Size of: " , stringify ! (GrBackendSurfaceMutableState))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendSurfaceMutableState > () , 4usize , concat ! ("Alignment of " , stringify ! (GrBackendSurfaceMutableState))) ; fn test_field_fBackend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendSurfaceMutableState > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackend) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendSurfaceMutableState) , "::" , stringify ! (fBackend))) ; } test_field_fBackend () ; fn test_field_fIsValid () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendSurfaceMutableState > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsValid) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrBackendSurfaceMutableState) , "::" , stringify ! (fIsValid))) ; } test_field_fIsValid () ; } extern "C" { # [link_name = "\u{1}??0GrBackendSurfaceMutableState@@QEAA@AEBV0@@Z"] pub fn GrBackendSurfaceMutableState_GrBackendSurfaceMutableState (this : * mut GrBackendSurfaceMutableState , that : * const GrBackendSurfaceMutableState) ; } impl GrBackendSurfaceMutableState { # [inline] pub unsafe fn new (that : * const GrBackendSurfaceMutableState) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendSurfaceMutableState_GrBackendSurfaceMutableState (__bindgen_tmp . as_mut_ptr () , that) ; __bindgen_tmp . assume_init () } } impl SkTileMode { pub const LastTileMode : SkTileMode = SkTileMode :: Decal ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTileMode { Clamp = 0 , Repeat = 1 , Mirror = 2 , Decal = 3 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkArenaAlloc { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShader { pub _bindgen_opaque_blob : [u64 ; 2usize] , } impl SkShader_GradientType { pub const Last : SkShader_GradientType = SkShader_GradientType :: Conical ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkShader_GradientType { None = 0 , Color = 1 , Linear = 2 , Radial = 3 , Sweep = 4 , Conical = 5 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShader_GradientInfo { pub fColorCount : :: std :: os :: raw :: c_int , pub fColors : * mut SkColor , pub fColorOffsets : * mut SkScalar , pub fPoint : [SkPoint ; 2usize] , pub fRadius : [SkScalar ; 2usize] , pub fTileMode : SkTileMode , pub fGradientFlags : u32 , } # [test] fn bindgen_test_layout_SkShader_GradientInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkShader_GradientInfo > () , 56usize , concat ! ("Size of: " , stringify ! (SkShader_GradientInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShader_GradientInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShader_GradientInfo))) ; fn test_field_fColorCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorCount) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fColorCount))) ; } test_field_fColorCount () ; fn test_field_fColors () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColors) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fColors))) ; } test_field_fColors () ; fn test_field_fColorOffsets () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorOffsets) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fColorOffsets))) ; } test_field_fColorOffsets () ; fn test_field_fPoint () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPoint) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fPoint))) ; } test_field_fPoint () ; fn test_field_fRadius () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRadius) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fRadius))) ; } test_field_fRadius () ; fn test_field_fTileMode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTileMode) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fTileMode))) ; } test_field_fTileMode () ; fn test_field_fGradientFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShader_GradientInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGradientFlags) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (SkShader_GradientInfo) , "::" , stringify ! (fGradientFlags))) ; } test_field_fGradientFlags () ; } pub type SkShader_INHERITED = SkFlattenable ; # [test] fn bindgen_test_layout_SkShader () { assert_eq ! (:: core :: mem :: size_of :: < SkShader > () , 16usize , concat ! ("Size of: " , stringify ! (SkShader))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShader > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShader))) ; } extern "C" { # [link_name = "\u{1}?isAImage@SkShader@@QEBAPEAVSkImage@@PEAVSkMatrix@@QEAW4SkTileMode@@@Z"] pub fn SkShader_isAImage (this : * const SkShader , localMatrix : * mut SkMatrix , xy : * mut SkTileMode) -> * mut SkImage ; } extern "C" { # [link_name = "\u{1}?makeWithLocalMatrix@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@AEBVSkMatrix@@@Z"] pub fn SkShader_makeWithLocalMatrix (this : * const SkShader , arg1 : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?makeWithColorFilter@SkShader@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@VSkColorFilter@@@@@Z"] pub fn SkShader_makeWithColorFilter (this : * const SkShader , arg1 : sk_sp < SkColorFilter >) -> sk_sp < SkShader > ; } impl SkShader { # [inline] pub unsafe fn isAImage (& self , localMatrix : * mut SkMatrix , xy : * mut SkTileMode) -> * mut SkImage { SkShader_isAImage (self , localMatrix , xy) } # [inline] pub unsafe fn makeWithLocalMatrix (& self , arg1 : * const SkMatrix) -> sk_sp < SkShader > { SkShader_makeWithLocalMatrix (self , arg1) } # [inline] pub unsafe fn makeWithColorFilter (& self , arg1 : sk_sp < SkColorFilter >) -> sk_sp < SkShader > { SkShader_makeWithColorFilter (self , arg1) } } extern "C" { # [link_name = "\u{1}?asAGradient@SkShader@@UEBA?AW4GradientType@1@PEAUGradientInfo@1@@Z"] pub fn SkShader_asAGradient (this : * mut :: core :: ffi :: c_void , info : * mut SkShader_GradientInfo) -> SkShader_GradientType ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkMipmap { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPromiseImageTexture { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct SkImage { pub _base : SkRefCnt , pub fInfo : SkImageInfo , pub fUniqueID : u32 , } pub type SkImage_ReleaseContext = * mut :: core :: ffi :: c_void ; pub type SkImage_RasterReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (pixels : * const :: core :: ffi :: c_void , arg1 : SkImage_ReleaseContext) > ; impl SkImage_CompressionType { pub const Last : SkImage_CompressionType = SkImage_CompressionType :: BC1_RGBA8_UNORM ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_CompressionType { None = 0 , ETC2_RGB8_UNORM = 1 , BC1_RGB8_UNORM = 2 , BC1_RGBA8_UNORM = 3 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_BitDepth { U8 = 0 , F16 = 1 , } pub type SkImage_TextureReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (releaseContext : SkImage_ReleaseContext) > ; pub type SkImage_PromiseImageTextureContext = * mut :: core :: ffi :: c_void ; pub type SkImage_PromiseImageTextureFulfillProc = :: core :: option :: Option < unsafe extern "C" fn (arg1 : SkImage_PromiseImageTextureContext) -> sk_sp < SkPromiseImageTexture > > ; pub type SkImage_PromiseImageTextureReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (arg1 : SkImage_PromiseImageTextureContext) > ; pub type SkImage_CubicResampler = SkCubicResampler ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_CachingHint { Allow = 0 , Disallow = 1 , } # [repr (C)] pub struct SkImage_AsyncReadResult__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] # [derive (Debug)] pub struct SkImage_AsyncReadResult { pub vtable_ : * const SkImage_AsyncReadResult__bindgen_vtable , } # [test] fn bindgen_test_layout_SkImage_AsyncReadResult () { assert_eq ! (:: core :: mem :: size_of :: < SkImage_AsyncReadResult > () , 8usize , concat ! ("Size of: " , stringify ! (SkImage_AsyncReadResult))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImage_AsyncReadResult > () , 8usize , concat ! ("Alignment of " , stringify ! (SkImage_AsyncReadResult))) ; } pub type SkImage_ReadPixelsContext = * mut :: core :: ffi :: c_void ; pub type SkImage_ReadPixelsCallback = :: core :: option :: Option < unsafe extern "C" fn (arg1 : SkImage_ReadPixelsContext , arg2 : u8) > ; # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_RescaleGamma { kSrc = 0 , kLinear = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_RescaleMode { kNearest = 0 , kRepeatedLinear = 1 , kRepeatedCubic = 2 , } pub type SkImage_BackendTextureReleaseProc = u8 ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImage_LegacyBitmapMode { kRO_LegacyBitmapMode = 0 , } pub type SkImage_INHERITED = SkRefCnt ; pub const SkImage_kCompressionTypeCount : :: std :: os :: raw :: c_int = 4 ; extern "C" { # [link_name = "\u{1}?kETC1_CompressionType@SkImage@@2W4CompressionType@1@B"] pub static SkImage_kETC1_CompressionType : SkImage_CompressionType ; } # [test] fn bindgen_test_layout_SkImage () { assert_eq ! (:: core :: mem :: size_of :: < SkImage > () , 48usize , concat ! ("Size of: " , stringify ! (SkImage))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImage > () , 8usize , concat ! ("Alignment of " , stringify ! (SkImage))) ; fn test_field_fInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImage > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInfo) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkImage) , "::" , stringify ! (fInfo))) ; } test_field_fInfo () ; fn test_field_fUniqueID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImage > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUniqueID) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkImage) , "::" , stringify ! (fUniqueID))) ; } test_field_fUniqueID () ; } extern "C" { # [link_name = "\u{1}?MakeRasterCopy@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@@Z"] pub fn SkImage_MakeRasterCopy (pixmap : * const SkPixmap) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeRasterData@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBUSkImageInfo@@V?$sk_sp@VSkData@@@@_K@Z"] pub fn SkImage_MakeRasterData (info : * const SkImageInfo , pixels : sk_sp < SkData > , rowBytes : usize) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromRaster@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkPixmap@@P6AXPEBXPEAX@Z2@Z"] pub fn SkImage_MakeFromRaster (pixmap : * const SkPixmap , rasterReleaseProc : SkImage_RasterReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromBitmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@AEBVSkBitmap@@@Z"] pub fn SkImage_MakeFromBitmap (bitmap : * const SkBitmap) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromGenerator@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$unique_ptr@VSkImageGenerator@@U?$default_delete@VSkImageGenerator@@@std@@@std@@@Z"] pub fn SkImage_MakeFromGenerator (imageGenerator : u64) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromEncoded@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkData@@@@V?$optional@W4SkAlphaType@@@std@@@Z"] pub fn SkImage_MakeFromEncoded (encoded : sk_sp < SkData > , alphaType : [u32 ; 2usize]) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeRasterFromCompressed@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkData@@@@HHW4CompressionType@1@@Z"] pub fn SkImage_MakeRasterFromCompressed (data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromPicture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkPicture@@@@AEBUSkISize@@PEBVSkMatrix@@PEBVSkPaint@@W4BitDepth@1@V?$sk_sp@VSkColorSpace@@@@VSkSurfaceProps@@@Z"] pub fn SkImage_MakeFromPicture (picture : sk_sp < SkPicture > , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : sk_sp < SkColorSpace > , props : SkSurfaceProps) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeTextureFromCompressed@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrDirectContext@@V?$sk_sp@VSkData@@@@HHW4CompressionType@1@W4GrMipmapped@@W4GrProtected@@@Z"] pub fn SkImage_MakeTextureFromCompressed (direct : * mut GrDirectContext , data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType , mipmapped : GrMipmapped , isProtected : GrProtected) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z6@Z"] pub fn SkImage_MakeFromTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromCompressedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z5@Z"] pub fn SkImage_MakeFromCompressedTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeCrossContextFromPixmap@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrDirectContext@@AEBVSkPixmap@@_N2@Z"] pub fn SkImage_MakeCrossContextFromPixmap (context : * mut GrDirectContext , pixmap : * const SkPixmap , buildMips : bool , limitToMaxTextureSize : bool) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4SkColorType@@@Z"] pub fn SkImage_MakeFromAdoptedTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4SkColorType@@W4SkAlphaType@@@Z"] pub fn SkImage_MakeFromAdoptedTexture1 (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromAdoptedTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImage_MakeFromAdoptedTexture2 (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromYUVATextures@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVGrYUVABackendTextures@@V?$sk_sp@VSkColorSpace@@@@P6AXPEAX@Z3@Z"] pub fn SkImage_MakeFromYUVATextures (context : * mut GrRecordingContext , yuvaTextures : * const GrYUVABackendTextures , imageColorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeFromYUVAPixmaps@SkImage@@SA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@AEBVSkYUVAPixmaps@@W4GrMipmapped@@_NV?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImage_MakeFromYUVAPixmaps (context : * mut GrRecordingContext , pixmaps : * const SkYUVAPixmaps , buildMips : GrMipmapped , limitToMaxTextureSize : bool , imageColorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakePromiseTexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VGrContextThreadSafeProxy@@@@AEBVGrBackendFormat@@USkISize@@W4GrMipmapped@@W4GrSurfaceOrigin@@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6A?AV?$sk_sp@VSkPromiseImageTexture@@@@PEAX@ZP6AX8@Z8@Z"] pub fn SkImage_MakePromiseTexture (gpuContextProxy : sk_sp < GrContextThreadSafeProxy > , backendFormat : * const GrBackendFormat , dimensions : SkISize , mipmapped : GrMipmapped , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkImage_PromiseImageTextureFulfillProc , textureReleaseProc : SkImage_PromiseImageTextureReleaseProc , textureContext : SkImage_PromiseImageTextureContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakePromiseYUVATexture@SkImage@@SA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VGrContextThreadSafeProxy@@@@AEBVGrYUVABackendTextureInfo@@V?$sk_sp@VSkColorSpace@@@@P6A?AV?$sk_sp@VSkPromiseImageTexture@@@@PEAX@ZP6AX3@ZQEAPEAX@Z"] pub fn SkImage_MakePromiseYUVATexture (gpuContextProxy : sk_sp < GrContextThreadSafeProxy > , backendTextureInfo : * const GrYUVABackendTextureInfo , imageColorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkImage_PromiseImageTextureFulfillProc , textureReleaseProc : SkImage_PromiseImageTextureReleaseProc , textureContexts : * mut SkImage_PromiseImageTextureContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?alphaType@SkImage@@QEBA?AW4SkAlphaType@@XZ"] pub fn SkImage_alphaType (this : * const SkImage) -> SkAlphaType ; } extern "C" { # [link_name = "\u{1}?colorType@SkImage@@QEBA?AW4SkColorType@@XZ"] pub fn SkImage_colorType (this : * const SkImage) -> SkColorType ; } extern "C" { # [link_name = "\u{1}?colorSpace@SkImage@@QEBAPEAVSkColorSpace@@XZ"] pub fn SkImage_colorSpace (this : * const SkImage) -> * mut SkColorSpace ; } extern "C" { # [link_name = "\u{1}?refColorSpace@SkImage@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkImage_refColorSpace (this : * const SkImage) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?isAlphaOnly@SkImage@@QEBA_NXZ"] pub fn SkImage_isAlphaOnly (this : * const SkImage) -> bool ; } extern "C" { # [link_name = "\u{1}?makeShader@SkImage@@QEBA?AV?$sk_sp@VSkShader@@@@W4SkTileMode@@0AEBUSkSamplingOptions@@PEBVSkMatrix@@@Z"] pub fn SkImage_makeShader (this : * const SkImage , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?makeRawShader@SkImage@@QEBA?AV?$sk_sp@VSkShader@@@@W4SkTileMode@@0AEBUSkSamplingOptions@@PEBVSkMatrix@@@Z"] pub fn SkImage_makeRawShader (this : * const SkImage , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?peekPixels@SkImage@@QEBA_NPEAVSkPixmap@@@Z"] pub fn SkImage_peekPixels (this : * const SkImage , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?isTextureBacked@SkImage@@QEBA_NXZ"] pub fn SkImage_isTextureBacked (this : * const SkImage) -> bool ; } extern "C" { # [link_name = "\u{1}?textureSize@SkImage@@QEBA_KXZ"] pub fn SkImage_textureSize (this : * const SkImage) -> usize ; } extern "C" { # [link_name = "\u{1}?isValid@SkImage@@QEBA_NPEAVGrRecordingContext@@@Z"] pub fn SkImage_isValid (this : * const SkImage , context : * mut GrRecordingContext) -> bool ; } extern "C" { # [link_name = "\u{1}?flush@SkImage@@QEBA?AW4GrSemaphoresSubmitted@@PEAVGrDirectContext@@AEBUGrFlushInfo@@@Z"] pub fn SkImage_flush (this : * const SkImage , context : * mut GrDirectContext , flushInfo : * const GrFlushInfo) -> GrSemaphoresSubmitted ; } extern "C" { # [link_name = "\u{1}?flushAndSubmit@SkImage@@QEBAXPEAVGrDirectContext@@@Z"] pub fn SkImage_flushAndSubmit (this : * const SkImage , arg1 : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?getBackendTexture@SkImage@@QEBA?AVGrBackendTexture@@_NPEAW4GrSurfaceOrigin@@@Z"] pub fn SkImage_getBackendTexture (this : * const SkImage , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?readPixels@SkImage@@QEBA_NPEAVGrDirectContext@@AEBUSkImageInfo@@PEAX_KHHW4CachingHint@1@@Z"] pub fn SkImage_readPixels (this : * const SkImage , context : * mut GrDirectContext , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkImage@@QEBA_NPEAVGrDirectContext@@AEBVSkPixmap@@HHW4CachingHint@1@@Z"] pub fn SkImage_readPixels1 (this : * const SkImage , context : * mut GrDirectContext , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkImage@@QEBA_NAEBUSkImageInfo@@PEAX_KHHW4CachingHint@1@@Z"] pub fn SkImage_readPixels2 (this : * const SkImage , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkImage@@QEBA_NAEBVSkPixmap@@HHW4CachingHint@1@@Z"] pub fn SkImage_readPixels3 (this : * const SkImage , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool ; } extern "C" { # [link_name = "\u{1}?asyncRescaleAndReadPixels@SkImage@@QEBAXAEBUSkImageInfo@@AEBUSkIRect@@W4RescaleGamma@1@W4RescaleMode@1@P6AXPEAXV?$unique_ptr@$$CBVAsyncReadResult@SkImage@@U?$default_delete@$$CBVAsyncReadResult@SkImage@@@std@@@std@@@Z4@Z"] pub fn SkImage_asyncRescaleAndReadPixels (this : * const SkImage , info : * const SkImageInfo , srcRect : * const SkIRect , rescaleGamma : SkImage_RescaleGamma , rescaleMode : SkImage_RescaleMode , callback : SkImage_ReadPixelsCallback , context : SkImage_ReadPixelsContext) ; } extern "C" { # [link_name = "\u{1}?asyncRescaleAndReadPixelsYUV420@SkImage@@QEBAXW4SkYUVColorSpace@@V?$sk_sp@VSkColorSpace@@@@AEBUSkIRect@@AEBUSkISize@@W4RescaleGamma@1@W4RescaleMode@1@P6AXPEAXV?$unique_ptr@$$CBVAsyncReadResult@SkImage@@U?$default_delete@$$CBVAsyncReadResult@SkImage@@@std@@@std@@@Z6@Z"] pub fn SkImage_asyncRescaleAndReadPixelsYUV420 (this : * const SkImage , yuvColorSpace : SkYUVColorSpace , dstColorSpace : sk_sp < SkColorSpace > , srcRect : * const SkIRect , dstSize : * const SkISize , rescaleGamma : SkImage_RescaleGamma , rescaleMode : SkImage_RescaleMode , callback : SkImage_ReadPixelsCallback , context : SkImage_ReadPixelsContext) ; } extern "C" { # [link_name = "\u{1}?scalePixels@SkImage@@QEBA_NAEBVSkPixmap@@AEBUSkSamplingOptions@@W4CachingHint@1@@Z"] pub fn SkImage_scalePixels (this : * const SkImage , dst : * const SkPixmap , arg1 : * const SkSamplingOptions , cachingHint : SkImage_CachingHint) -> bool ; } extern "C" { # [link_name = "\u{1}?encodeToData@SkImage@@QEBA?AV?$sk_sp@VSkData@@@@W4SkEncodedImageFormat@@H@Z"] pub fn SkImage_encodeToData (this : * const SkImage , encodedImageFormat : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?encodeToData@SkImage@@QEBA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkImage_encodeToData1 (this : * const SkImage) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?refEncodedData@SkImage@@QEBA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkImage_refEncodedData (this : * const SkImage) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?makeSubset@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@AEBUSkIRect@@PEAVGrDirectContext@@@Z"] pub fn SkImage_makeSubset (this : * const SkImage , subset : * const SkIRect , direct : * mut GrDirectContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?hasMipmaps@SkImage@@QEBA_NXZ"] pub fn SkImage_hasMipmaps (this : * const SkImage) -> bool ; } extern "C" { # [link_name = "\u{1}?withDefaultMipmaps@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"] pub fn SkImage_withDefaultMipmaps (this : * const SkImage) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrDirectContext@@W4GrMipmapped@@W4SkBudgeted@@@Z"] pub fn SkImage_makeTextureImage (this : * const SkImage , arg1 : * mut GrDirectContext , arg2 : GrMipmapped , arg3 : SkBudgeted) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeNonTextureImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"] pub fn SkImage_makeNonTextureImage (this : * const SkImage) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeRasterImage@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@W4CachingHint@1@@Z"] pub fn SkImage_makeRasterImage (this : * const SkImage , cachingHint : SkImage_CachingHint) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeWithFilter@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@PEBVSkImageFilter@@AEBUSkIRect@@2PEAU5@PEAUSkIPoint@@@Z"] pub fn SkImage_makeWithFilter (this : * const SkImage , context : * mut GrRecordingContext , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?MakeBackendTextureFromSkImage@SkImage@@SA_NPEAVGrDirectContext@@V?$sk_sp@VSkImage@@@@PEAVGrBackendTexture@@PEAV?$function@$$A6AXVGrBackendTexture@@@Z@std@@@Z"] pub fn SkImage_MakeBackendTextureFromSkImage (context : * mut GrDirectContext , image : sk_sp < SkImage > , backendTexture : * mut GrBackendTexture , backendTextureReleaseProc : * mut SkImage_BackendTextureReleaseProc) -> bool ; } extern "C" { # [link_name = "\u{1}?asLegacyBitmap@SkImage@@QEBA_NPEAVSkBitmap@@W4LegacyBitmapMode@1@@Z"] pub fn SkImage_asLegacyBitmap (this : * const SkImage , bitmap : * mut SkBitmap , legacyBitmapMode : SkImage_LegacyBitmapMode) -> bool ; } extern "C" { # [link_name = "\u{1}?isLazyGenerated@SkImage@@QEBA_NXZ"] pub fn SkImage_isLazyGenerated (this : * const SkImage) -> bool ; } extern "C" { # [link_name = "\u{1}?makeColorSpace@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkColorSpace@@@@PEAVGrDirectContext@@@Z"] pub fn SkImage_makeColorSpace (this : * const SkImage , target : sk_sp < SkColorSpace > , direct : * mut GrDirectContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeColorTypeAndColorSpace@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@W4SkColorType@@V?$sk_sp@VSkColorSpace@@@@PEAVGrDirectContext@@@Z"] pub fn SkImage_makeColorTypeAndColorSpace (this : * const SkImage , targetColorType : SkColorType , targetColorSpace : sk_sp < SkColorSpace > , direct : * mut GrDirectContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?reinterpretColorSpace@SkImage@@QEBA?AV?$sk_sp@VSkImage@@@@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkImage_reinterpretColorSpace (this : * const SkImage , newColorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > ; } impl SkImage { # [inline] pub unsafe fn MakeRasterCopy (pixmap : * const SkPixmap) -> sk_sp < SkImage > { SkImage_MakeRasterCopy (pixmap) } # [inline] pub unsafe fn MakeRasterData (info : * const SkImageInfo , pixels : sk_sp < SkData > , rowBytes : usize) -> sk_sp < SkImage > { SkImage_MakeRasterData (info , pixels , rowBytes) } # [inline] pub unsafe fn MakeFromRaster (pixmap : * const SkPixmap , rasterReleaseProc : SkImage_RasterReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > { SkImage_MakeFromRaster (pixmap , rasterReleaseProc , releaseContext) } # [inline] pub unsafe fn MakeFromBitmap (bitmap : * const SkBitmap) -> sk_sp < SkImage > { SkImage_MakeFromBitmap (bitmap) } # [inline] pub unsafe fn MakeFromGenerator (imageGenerator : u64) -> sk_sp < SkImage > { SkImage_MakeFromGenerator (imageGenerator) } # [inline] pub unsafe fn MakeFromEncoded (encoded : sk_sp < SkData > , alphaType : [u32 ; 2usize]) -> sk_sp < SkImage > { SkImage_MakeFromEncoded (encoded , alphaType) } # [inline] pub unsafe fn MakeRasterFromCompressed (data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType) -> sk_sp < SkImage > { SkImage_MakeRasterFromCompressed (data , width , height , type_) } # [inline] pub unsafe fn MakeFromPicture (picture : sk_sp < SkPicture > , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : sk_sp < SkColorSpace > , props : SkSurfaceProps) -> sk_sp < SkImage > { SkImage_MakeFromPicture (picture , dimensions , matrix , paint , bitDepth , colorSpace , props) } # [inline] pub unsafe fn MakeTextureFromCompressed (direct : * mut GrDirectContext , data : sk_sp < SkData > , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType , mipmapped : GrMipmapped , isProtected : GrProtected) -> sk_sp < SkImage > { SkImage_MakeTextureFromCompressed (direct , data , width , height , type_ , mipmapped , isProtected) } # [inline] pub unsafe fn MakeFromTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > { SkImage_MakeFromTexture (context , backendTexture , origin , colorType , alphaType , colorSpace , textureReleaseProc , releaseContext) } # [inline] pub unsafe fn MakeFromCompressedTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > { SkImage_MakeFromCompressedTexture (context , backendTexture , origin , alphaType , colorSpace , textureReleaseProc , releaseContext) } # [inline] pub unsafe fn MakeCrossContextFromPixmap (context : * mut GrDirectContext , pixmap : * const SkPixmap , buildMips : bool , limitToMaxTextureSize : bool) -> sk_sp < SkImage > { SkImage_MakeCrossContextFromPixmap (context , pixmap , buildMips , limitToMaxTextureSize) } # [inline] pub unsafe fn MakeFromAdoptedTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType) -> sk_sp < SkImage > { SkImage_MakeFromAdoptedTexture (context , backendTexture , textureOrigin , colorType) } # [inline] pub unsafe fn MakeFromAdoptedTexture1 (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType) -> sk_sp < SkImage > { SkImage_MakeFromAdoptedTexture1 (context , backendTexture , textureOrigin , colorType , alphaType) } # [inline] pub unsafe fn MakeFromAdoptedTexture2 (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > { SkImage_MakeFromAdoptedTexture2 (context , backendTexture , textureOrigin , colorType , alphaType , colorSpace) } # [inline] pub unsafe fn MakeFromYUVATextures (context : * mut GrRecordingContext , yuvaTextures : * const GrYUVABackendTextures , imageColorSpace : sk_sp < SkColorSpace > , textureReleaseProc : SkImage_TextureReleaseProc , releaseContext : SkImage_ReleaseContext) -> sk_sp < SkImage > { SkImage_MakeFromYUVATextures (context , yuvaTextures , imageColorSpace , textureReleaseProc , releaseContext) } # [inline] pub unsafe fn MakeFromYUVAPixmaps (context : * mut GrRecordingContext , pixmaps : * const SkYUVAPixmaps , buildMips : GrMipmapped , limitToMaxTextureSize : bool , imageColorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > { SkImage_MakeFromYUVAPixmaps (context , pixmaps , buildMips , limitToMaxTextureSize , imageColorSpace) } # [inline] pub unsafe fn MakePromiseTexture (gpuContextProxy : sk_sp < GrContextThreadSafeProxy > , backendFormat : * const GrBackendFormat , dimensions : SkISize , mipmapped : GrMipmapped , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkImage_PromiseImageTextureFulfillProc , textureReleaseProc : SkImage_PromiseImageTextureReleaseProc , textureContext : SkImage_PromiseImageTextureContext) -> sk_sp < SkImage > { SkImage_MakePromiseTexture (gpuContextProxy , backendFormat , dimensions , mipmapped , origin , colorType , alphaType , colorSpace , textureFulfillProc , textureReleaseProc , textureContext) } # [inline] pub unsafe fn MakePromiseYUVATexture (gpuContextProxy : sk_sp < GrContextThreadSafeProxy > , backendTextureInfo : * const GrYUVABackendTextureInfo , imageColorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkImage_PromiseImageTextureFulfillProc , textureReleaseProc : SkImage_PromiseImageTextureReleaseProc , textureContexts : * mut SkImage_PromiseImageTextureContext) -> sk_sp < SkImage > { SkImage_MakePromiseYUVATexture (gpuContextProxy , backendTextureInfo , imageColorSpace , textureFulfillProc , textureReleaseProc , textureContexts) } # [inline] pub unsafe fn alphaType (& self) -> SkAlphaType { SkImage_alphaType (self) } # [inline] pub unsafe fn colorType (& self) -> SkColorType { SkImage_colorType (self) } # [inline] pub unsafe fn colorSpace (& self) -> * mut SkColorSpace { SkImage_colorSpace (self) } # [inline] pub unsafe fn refColorSpace (& self) -> sk_sp < SkColorSpace > { SkImage_refColorSpace (self) } # [inline] pub unsafe fn isAlphaOnly (& self) -> bool { SkImage_isAlphaOnly (self) } # [inline] pub unsafe fn makeShader (& self , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkImage_makeShader (self , tmx , tmy , arg1 , localMatrix) } # [inline] pub unsafe fn makeRawShader (& self , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkImage_makeRawShader (self , tmx , tmy , arg1 , localMatrix) } # [inline] pub unsafe fn peekPixels (& self , pixmap : * mut SkPixmap) -> bool { SkImage_peekPixels (self , pixmap) } # [inline] pub unsafe fn isTextureBacked (& self) -> bool { SkImage_isTextureBacked (self) } # [inline] pub unsafe fn textureSize (& self) -> usize { SkImage_textureSize (self) } # [inline] pub unsafe fn isValid (& self , context : * mut GrRecordingContext) -> bool { SkImage_isValid (self , context) } # [inline] pub unsafe fn flush (& self , context : * mut GrDirectContext , flushInfo : * const GrFlushInfo) -> GrSemaphoresSubmitted { SkImage_flush (self , context , flushInfo) } # [inline] pub unsafe fn flushAndSubmit (& self , arg1 : * mut GrDirectContext) { SkImage_flushAndSubmit (self , arg1) } # [inline] pub unsafe fn getBackendTexture (& self , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin) -> GrBackendTexture { SkImage_getBackendTexture (self , flushPendingGrContextIO , origin) } # [inline] pub unsafe fn readPixels (& self , context : * mut GrDirectContext , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool { SkImage_readPixels (self , context , dstInfo , dstPixels , dstRowBytes , srcX , srcY , cachingHint) } # [inline] pub unsafe fn readPixels1 (& self , context : * mut GrDirectContext , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool { SkImage_readPixels1 (self , context , dst , srcX , srcY , cachingHint) } # [inline] pub unsafe fn readPixels2 (& self , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool { SkImage_readPixels2 (self , dstInfo , dstPixels , dstRowBytes , srcX , srcY , cachingHint) } # [inline] pub unsafe fn readPixels3 (& self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int , cachingHint : SkImage_CachingHint) -> bool { SkImage_readPixels3 (self , dst , srcX , srcY , cachingHint) } # [inline] pub unsafe fn asyncRescaleAndReadPixels (& self , info : * const SkImageInfo , srcRect : * const SkIRect , rescaleGamma : SkImage_RescaleGamma , rescaleMode : SkImage_RescaleMode , callback : SkImage_ReadPixelsCallback , context : SkImage_ReadPixelsContext) { SkImage_asyncRescaleAndReadPixels (self , info , srcRect , rescaleGamma , rescaleMode , callback , context) } # [inline] pub unsafe fn asyncRescaleAndReadPixelsYUV420 (& self , yuvColorSpace : SkYUVColorSpace , dstColorSpace : sk_sp < SkColorSpace > , srcRect : * const SkIRect , dstSize : * const SkISize , rescaleGamma : SkImage_RescaleGamma , rescaleMode : SkImage_RescaleMode , callback : SkImage_ReadPixelsCallback , context : SkImage_ReadPixelsContext) { SkImage_asyncRescaleAndReadPixelsYUV420 (self , yuvColorSpace , dstColorSpace , srcRect , dstSize , rescaleGamma , rescaleMode , callback , context) } # [inline] pub unsafe fn scalePixels (& self , dst : * const SkPixmap , arg1 : * const SkSamplingOptions , cachingHint : SkImage_CachingHint) -> bool { SkImage_scalePixels (self , dst , arg1 , cachingHint) } # [inline] pub unsafe fn encodeToData (& self , encodedImageFormat : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int) -> sk_sp < SkData > { SkImage_encodeToData (self , encodedImageFormat , quality) } # [inline] pub unsafe fn encodeToData1 (& self) -> sk_sp < SkData > { SkImage_encodeToData1 (self) } # [inline] pub unsafe fn refEncodedData (& self) -> sk_sp < SkData > { SkImage_refEncodedData (self) } # [inline] pub unsafe fn makeSubset (& self , subset : * const SkIRect , direct : * mut GrDirectContext) -> sk_sp < SkImage > { SkImage_makeSubset (self , subset , direct) } # [inline] pub unsafe fn hasMipmaps (& self) -> bool { SkImage_hasMipmaps (self) } # [inline] pub unsafe fn withDefaultMipmaps (& self) -> sk_sp < SkImage > { SkImage_withDefaultMipmaps (self) } # [inline] pub unsafe fn makeTextureImage (& self , arg1 : * mut GrDirectContext , arg2 : GrMipmapped , arg3 : SkBudgeted) -> sk_sp < SkImage > { SkImage_makeTextureImage (self , arg1 , arg2 , arg3) } # [inline] pub unsafe fn makeNonTextureImage (& self) -> sk_sp < SkImage > { SkImage_makeNonTextureImage (self) } # [inline] pub unsafe fn makeRasterImage (& self , cachingHint : SkImage_CachingHint) -> sk_sp < SkImage > { SkImage_makeRasterImage (self , cachingHint) } # [inline] pub unsafe fn makeWithFilter (& self , context : * mut GrRecordingContext , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint) -> sk_sp < SkImage > { SkImage_makeWithFilter (self , context , filter , subset , clipBounds , outSubset , offset) } # [inline] pub unsafe fn MakeBackendTextureFromSkImage (context : * mut GrDirectContext , image : sk_sp < SkImage > , backendTexture : * mut GrBackendTexture , backendTextureReleaseProc : * mut SkImage_BackendTextureReleaseProc) -> bool { SkImage_MakeBackendTextureFromSkImage (context , image , backendTexture , backendTextureReleaseProc) } # [inline] pub unsafe fn asLegacyBitmap (& self , bitmap : * mut SkBitmap , legacyBitmapMode : SkImage_LegacyBitmapMode) -> bool { SkImage_asLegacyBitmap (self , bitmap , legacyBitmapMode) } # [inline] pub unsafe fn isLazyGenerated (& self) -> bool { SkImage_isLazyGenerated (self) } # [inline] pub unsafe fn makeColorSpace (& self , target : sk_sp < SkColorSpace > , direct : * mut GrDirectContext) -> sk_sp < SkImage > { SkImage_makeColorSpace (self , target , direct) } # [inline] pub unsafe fn makeColorTypeAndColorSpace (& self , targetColorType : SkColorType , targetColorSpace : sk_sp < SkColorSpace > , direct : * mut GrDirectContext) -> sk_sp < SkImage > { SkImage_makeColorTypeAndColorSpace (self , targetColorType , targetColorSpace , direct) } # [inline] pub unsafe fn reinterpretColorSpace (& self , newColorSpace : sk_sp < SkColorSpace >) -> sk_sp < SkImage > { SkImage_reinterpretColorSpace (self , newColorSpace) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrCaps { _unused : [u8 ; 0] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrTextureType { kNone = 0 , k2D = 1 , kRectangle = 2 , kExternal = 3 , } impl GrColorType { pub const kLast : GrColorType = GrColorType :: kARGB_4444 ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrColorType { kUnknown = 0 , kAlpha_8 = 1 , kBGR_565 = 2 , kABGR_4444 = 3 , kRGBA_8888 = 4 , kRGBA_8888_SRGB = 5 , kRGB_888x = 6 , kRG_88 = 7 , kBGRA_8888 = 8 , kRGBA_1010102 = 9 , kBGRA_1010102 = 10 , kGray_8 = 11 , kGrayAlpha_88 = 12 , kAlpha_F16 = 13 , kRGBA_F16 = 14 , kRGBA_F16_Clamped = 15 , kRGBA_F32 = 16 , kAlpha_16 = 17 , kRG_1616 = 18 , kRG_F16 = 19 , kRGBA_16161616 = 20 , kAlpha_8xxx = 21 , kAlpha_F32xxx = 22 , kGray_8xxx = 23 , kR_8xxx = 24 , kRGB_888 = 25 , kR_8 = 26 , kR_16 = 27 , kR_F16 = 28 , kGray_F16 = 29 , kBGRA_4444 = 30 , kARGB_4444 = 31 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrColorTypeEncoding { kUnorm = 0 , kSRGBUnorm = 1 , kFloat = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrColorFormatDesc { pub fRBits : :: std :: os :: raw :: c_int , pub fGBits : :: std :: os :: raw :: c_int , pub fBBits : :: std :: os :: raw :: c_int , pub fABits : :: std :: os :: raw :: c_int , pub fGrayBits : :: std :: os :: raw :: c_int , pub fEncoding : GrColorTypeEncoding , } # [test] fn bindgen_test_layout_GrColorFormatDesc () { assert_eq ! (:: core :: mem :: size_of :: < GrColorFormatDesc > () , 24usize , concat ! ("Size of: " , stringify ! (GrColorFormatDesc))) ; assert_eq ! (:: core :: mem :: align_of :: < GrColorFormatDesc > () , 4usize , concat ! ("Alignment of " , stringify ! (GrColorFormatDesc))) ; fn test_field_fRBits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRBits) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fRBits))) ; } test_field_fRBits () ; fn test_field_fGBits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGBits) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fGBits))) ; } test_field_fGBits () ; fn test_field_fBBits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBBits) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fBBits))) ; } test_field_fBBits () ; fn test_field_fABits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fABits) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fABits))) ; } test_field_fABits () ; fn test_field_fGrayBits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGrayBits) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fGrayBits))) ; } test_field_fGrayBits () ; fn test_field_fEncoding () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrColorFormatDesc > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEncoding) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (GrColorFormatDesc) , "::" , stringify ! (fEncoding))) ; } test_field_fEncoding () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrMockTextureInfo { pub fColorType : GrColorType , pub fCompressionType : SkImage_CompressionType , pub fID : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_GrMockTextureInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrMockTextureInfo > () , 12usize , concat ! ("Size of: " , stringify ! (GrMockTextureInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrMockTextureInfo > () , 4usize , concat ! ("Alignment of " , stringify ! (GrMockTextureInfo))) ; fn test_field_fColorType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorType) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrMockTextureInfo) , "::" , stringify ! (fColorType))) ; } test_field_fColorType () ; fn test_field_fCompressionType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCompressionType) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrMockTextureInfo) , "::" , stringify ! (fCompressionType))) ; } test_field_fCompressionType () ; fn test_field_fID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fID) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrMockTextureInfo) , "::" , stringify ! (fID))) ; } test_field_fID () ; } extern "C" { # [link_name = "\u{1}?getBackendFormat@GrMockTextureInfo@@QEBA?AVGrBackendFormat@@XZ"] pub fn GrMockTextureInfo_getBackendFormat (this : * const GrMockTextureInfo) -> GrBackendFormat ; } impl GrMockTextureInfo { # [inline] pub unsafe fn getBackendFormat (& self) -> GrBackendFormat { GrMockTextureInfo_getBackendFormat (self) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrMockRenderTargetInfo { pub fColorType : GrColorType , pub fID : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_GrMockRenderTargetInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrMockRenderTargetInfo > () , 8usize , concat ! ("Size of: " , stringify ! (GrMockRenderTargetInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrMockRenderTargetInfo > () , 4usize , concat ! ("Alignment of " , stringify ! (GrMockRenderTargetInfo))) ; fn test_field_fColorType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockRenderTargetInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorType) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrMockRenderTargetInfo) , "::" , stringify ! (fColorType))) ; } test_field_fColorType () ; fn test_field_fID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockRenderTargetInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fID) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrMockRenderTargetInfo) , "::" , stringify ! (fID))) ; } test_field_fID () ; } extern "C" { # [link_name = "\u{1}?getBackendFormat@GrMockRenderTargetInfo@@QEBA?AVGrBackendFormat@@XZ"] pub fn GrMockRenderTargetInfo_getBackendFormat (this : * const GrMockRenderTargetInfo) -> GrBackendFormat ; } impl GrMockRenderTargetInfo { # [inline] pub unsafe fn getBackendFormat (& self) -> GrBackendFormat { GrMockRenderTargetInfo_getBackendFormat (self) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrMockOptions { pub fMipmapSupport : bool , pub fDrawInstancedSupport : bool , pub fHalfFloatVertexAttributeSupport : bool , pub fMapBufferFlags : u32 , pub fMaxTextureSize : :: std :: os :: raw :: c_int , pub fMaxRenderTargetSize : :: std :: os :: raw :: c_int , pub fMaxWindowRectangles : :: std :: os :: raw :: c_int , pub fMaxVertexAttributes : :: std :: os :: raw :: c_int , pub fConfigOptions : [GrMockOptions_ConfigOptions ; 32usize] , pub fCompressedOptions : [GrMockOptions_ConfigOptions ; 4usize] , pub fIntegerSupport : bool , pub fFlatInterpolationSupport : bool , pub fMaxVertexSamplers : :: std :: os :: raw :: c_int , pub fMaxFragmentSamplers : :: std :: os :: raw :: c_int , pub fShaderDerivativeSupport : bool , pub fDualSourceBlendingSupport : bool , pub fFailTextureAllocations : bool , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrMockOptions_ConfigOptions { pub fRenderability : GrMockOptions_ConfigOptions_Renderability , pub fTexturable : bool , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrMockOptions_ConfigOptions_Renderability { kNo = 0 , kNonMSAA = 1 , kMSAA = 2 , } # [test] fn bindgen_test_layout_GrMockOptions_ConfigOptions () { assert_eq ! (:: core :: mem :: size_of :: < GrMockOptions_ConfigOptions > () , 8usize , concat ! ("Size of: " , stringify ! (GrMockOptions_ConfigOptions))) ; assert_eq ! (:: core :: mem :: align_of :: < GrMockOptions_ConfigOptions > () , 4usize , concat ! ("Alignment of " , stringify ! (GrMockOptions_ConfigOptions))) ; fn test_field_fRenderability () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions_ConfigOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRenderability) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions_ConfigOptions) , "::" , stringify ! (fRenderability))) ; } test_field_fRenderability () ; fn test_field_fTexturable () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions_ConfigOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTexturable) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions_ConfigOptions) , "::" , stringify ! (fTexturable))) ; } test_field_fTexturable () ; } # [test] fn bindgen_test_layout_GrMockOptions () { assert_eq ! (:: core :: mem :: size_of :: < GrMockOptions > () , 328usize , concat ! ("Size of: " , stringify ! (GrMockOptions))) ; assert_eq ! (:: core :: mem :: align_of :: < GrMockOptions > () , 4usize , concat ! ("Alignment of " , stringify ! (GrMockOptions))) ; fn test_field_fMipmapSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMipmapSupport) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMipmapSupport))) ; } test_field_fMipmapSupport () ; fn test_field_fDrawInstancedSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDrawInstancedSupport) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fDrawInstancedSupport))) ; } test_field_fDrawInstancedSupport () ; fn test_field_fHalfFloatVertexAttributeSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHalfFloatVertexAttributeSupport) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fHalfFloatVertexAttributeSupport))) ; } test_field_fHalfFloatVertexAttributeSupport () ; fn test_field_fMapBufferFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMapBufferFlags) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMapBufferFlags))) ; } test_field_fMapBufferFlags () ; fn test_field_fMaxTextureSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxTextureSize) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxTextureSize))) ; } test_field_fMaxTextureSize () ; fn test_field_fMaxRenderTargetSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxRenderTargetSize) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxRenderTargetSize))) ; } test_field_fMaxRenderTargetSize () ; fn test_field_fMaxWindowRectangles () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxWindowRectangles) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxWindowRectangles))) ; } test_field_fMaxWindowRectangles () ; fn test_field_fMaxVertexAttributes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxVertexAttributes) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxVertexAttributes))) ; } test_field_fMaxVertexAttributes () ; fn test_field_fConfigOptions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fConfigOptions) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fConfigOptions))) ; } test_field_fConfigOptions () ; fn test_field_fCompressedOptions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCompressedOptions) as usize - ptr as usize } , 280usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fCompressedOptions))) ; } test_field_fCompressedOptions () ; fn test_field_fIntegerSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIntegerSupport) as usize - ptr as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fIntegerSupport))) ; } test_field_fIntegerSupport () ; fn test_field_fFlatInterpolationSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFlatInterpolationSupport) as usize - ptr as usize } , 313usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fFlatInterpolationSupport))) ; } test_field_fFlatInterpolationSupport () ; fn test_field_fMaxVertexSamplers () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxVertexSamplers) as usize - ptr as usize } , 316usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxVertexSamplers))) ; } test_field_fMaxVertexSamplers () ; fn test_field_fMaxFragmentSamplers () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxFragmentSamplers) as usize - ptr as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fMaxFragmentSamplers))) ; } test_field_fMaxFragmentSamplers () ; fn test_field_fShaderDerivativeSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fShaderDerivativeSupport) as usize - ptr as usize } , 324usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fShaderDerivativeSupport))) ; } test_field_fShaderDerivativeSupport () ; fn test_field_fDualSourceBlendingSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDualSourceBlendingSupport) as usize - ptr as usize } , 325usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fDualSourceBlendingSupport))) ; } test_field_fDualSourceBlendingSupport () ; fn test_field_fFailTextureAllocations () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrMockOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFailTextureAllocations) as usize - ptr as usize } , 326usize , concat ! ("Offset of field: " , stringify ! (GrMockOptions) , "::" , stringify ! (fFailTextureAllocations))) ; } test_field_fFailTextureAllocations () ; } # [repr (C)] # [derive (Copy , Clone)] pub struct GrBackendFormat { pub fBackend : GrBackendApi , pub fValid : bool , pub __bindgen_anon_1 : GrBackendFormat__bindgen_ty_1 , pub fTextureType : GrTextureType , } # [repr (C)] # [derive (Copy , Clone)] pub union GrBackendFormat__bindgen_ty_1 { pub fVk : GrBackendFormat__bindgen_ty_1__bindgen_ty_1 , pub fMock : GrBackendFormat__bindgen_ty_1__bindgen_ty_2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBackendFormat__bindgen_ty_1__bindgen_ty_1 { pub fFormat : VkFormat , pub fYcbcrConversionInfo : GrVkYcbcrConversionInfo , } # [test] fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > () , 56usize , concat ! ("Size of: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_1))) ; fn test_field_fFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFormat) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (fFormat))) ; } test_field_fFormat () ; fn test_field_fYcbcrConversionInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYcbcrConversionInfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (fYcbcrConversionInfo))) ; } test_field_fYcbcrConversionInfo () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBackendFormat__bindgen_ty_1__bindgen_ty_2 { pub fColorType : GrColorType , pub fCompressionType : SkImage_CompressionType , pub fIsStencilFormat : bool , } # [test] fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1__bindgen_ty_2 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_2 > () , 12usize , concat ! ("Size of: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_2))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_2 > () , 4usize , concat ! ("Alignment of " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_2))) ; fn test_field_fColorType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColorType) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (fColorType))) ; } test_field_fColorType () ; fn test_field_fCompressionType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCompressionType) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (fCompressionType))) ; } test_field_fCompressionType () ; fn test_field_fIsStencilFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1__bindgen_ty_2 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsStencilFormat) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1__bindgen_ty_2) , "::" , stringify ! (fIsStencilFormat))) ; } test_field_fIsStencilFormat () ; } # [test] fn bindgen_test_layout_GrBackendFormat__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendFormat__bindgen_ty_1 > () , 56usize , concat ! ("Size of: " , stringify ! (GrBackendFormat__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendFormat__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendFormat__bindgen_ty_1))) ; fn test_field_fVk () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVk) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1) , "::" , stringify ! (fVk))) ; } test_field_fVk () ; fn test_field_fMock () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMock) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat__bindgen_ty_1) , "::" , stringify ! (fMock))) ; } test_field_fMock () ; } # [test] fn bindgen_test_layout_GrBackendFormat () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendFormat > () , 72usize , concat ! ("Size of: " , stringify ! (GrBackendFormat))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendFormat > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendFormat))) ; fn test_field_fBackend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackend) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat) , "::" , stringify ! (fBackend))) ; } test_field_fBackend () ; fn test_field_fValid () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fValid) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat) , "::" , stringify ! (fValid))) ; } test_field_fValid () ; fn test_field_fTextureType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendFormat > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextureType) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (GrBackendFormat) , "::" , stringify ! (fTextureType))) ; } test_field_fTextureType () ; } extern "C" { # [link_name = "\u{1}?MakeVk@GrBackendFormat@@SA?AV1@AEBUGrVkYcbcrConversionInfo@@_N@Z"] pub fn GrBackendFormat_MakeVk (ycbcrInfo : * const GrVkYcbcrConversionInfo , willUseDRMFormatModifiers : bool) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?MakeMock@GrBackendFormat@@SA?AV1@W4GrColorType@@W4CompressionType@SkImage@@_N@Z"] pub fn GrBackendFormat_MakeMock (colorType : GrColorType , compression : SkImage_CompressionType , isStencilFormat : bool) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?channelMask@GrBackendFormat@@QEBAIXZ"] pub fn GrBackendFormat_channelMask (this : * const GrBackendFormat) -> u32 ; } extern "C" { # [link_name = "\u{1}?desc@GrBackendFormat@@QEBA?AVGrColorFormatDesc@@XZ"] pub fn GrBackendFormat_desc (this : * const GrBackendFormat) -> GrColorFormatDesc ; } extern "C" { # [link_name = "\u{1}?asVkFormat@GrBackendFormat@@QEBA_NPEAW4VkFormat@@@Z"] pub fn GrBackendFormat_asVkFormat (this : * const GrBackendFormat , arg1 : * mut VkFormat) -> bool ; } extern "C" { # [link_name = "\u{1}?getVkYcbcrConversionInfo@GrBackendFormat@@QEBAPEBUGrVkYcbcrConversionInfo@@XZ"] pub fn GrBackendFormat_getVkYcbcrConversionInfo (this : * const GrBackendFormat) -> * const GrVkYcbcrConversionInfo ; } extern "C" { # [link_name = "\u{1}?asMockColorType@GrBackendFormat@@QEBA?AW4GrColorType@@XZ"] pub fn GrBackendFormat_asMockColorType (this : * const GrBackendFormat) -> GrColorType ; } extern "C" { # [link_name = "\u{1}?asMockCompressionType@GrBackendFormat@@QEBA?AW4CompressionType@SkImage@@XZ"] pub fn GrBackendFormat_asMockCompressionType (this : * const GrBackendFormat) -> SkImage_CompressionType ; } extern "C" { # [link_name = "\u{1}?isMockStencilFormat@GrBackendFormat@@QEBA_NXZ"] pub fn GrBackendFormat_isMockStencilFormat (this : * const GrBackendFormat) -> bool ; } extern "C" { # [link_name = "\u{1}?makeTexture2D@GrBackendFormat@@QEBA?AV1@XZ"] pub fn GrBackendFormat_makeTexture2D (this : * const GrBackendFormat) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}??0GrBackendFormat@@QEAA@AEBV0@@Z"] pub fn GrBackendFormat_GrBackendFormat (this : * mut GrBackendFormat , arg1 : * const GrBackendFormat) ; } impl GrBackendFormat { # [inline] pub unsafe fn MakeVk (ycbcrInfo : * const GrVkYcbcrConversionInfo , willUseDRMFormatModifiers : bool) -> GrBackendFormat { GrBackendFormat_MakeVk (ycbcrInfo , willUseDRMFormatModifiers) } # [inline] pub unsafe fn MakeMock (colorType : GrColorType , compression : SkImage_CompressionType , isStencilFormat : bool) -> GrBackendFormat { GrBackendFormat_MakeMock (colorType , compression , isStencilFormat) } # [inline] pub unsafe fn channelMask (& self) -> u32 { GrBackendFormat_channelMask (self) } # [inline] pub unsafe fn desc (& self) -> GrColorFormatDesc { GrBackendFormat_desc (self) } # [inline] pub unsafe fn asVkFormat (& self , arg1 : * mut VkFormat) -> bool { GrBackendFormat_asVkFormat (self , arg1) } # [inline] pub unsafe fn getVkYcbcrConversionInfo (& self) -> * const GrVkYcbcrConversionInfo { GrBackendFormat_getVkYcbcrConversionInfo (self) } # [inline] pub unsafe fn asMockColorType (& self) -> GrColorType { GrBackendFormat_asMockColorType (self) } # [inline] pub unsafe fn asMockCompressionType (& self) -> SkImage_CompressionType { GrBackendFormat_asMockCompressionType (self) } # [inline] pub unsafe fn isMockStencilFormat (& self) -> bool { GrBackendFormat_isMockStencilFormat (self) } # [inline] pub unsafe fn makeTexture2D (& self) -> GrBackendFormat { GrBackendFormat_makeTexture2D (self) } # [inline] pub unsafe fn new (arg1 : * const GrBackendFormat) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendFormat_GrBackendFormat (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct GrBackendTexture { pub fIsValid : bool , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fLabel : std_string , pub fMipmapped : GrMipmapped , pub fBackend : GrBackendApi , pub fTextureType : GrTextureType , pub __bindgen_anon_1 : GrBackendTexture__bindgen_ty_1 , pub fMutableState : sk_sp < GrBackendSurfaceMutableStateImpl > , } # [repr (C)] # [derive (Copy , Clone)] pub union GrBackendTexture__bindgen_ty_1 { pub fVkInfo : GrVkBackendSurfaceInfo , pub fMockInfo : GrMockTextureInfo , } # [test] fn bindgen_test_layout_GrBackendTexture__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendTexture__bindgen_ty_1 > () , 144usize , concat ! ("Size of: " , stringify ! (GrBackendTexture__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendTexture__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendTexture__bindgen_ty_1))) ; fn test_field_fVkInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture__bindgen_ty_1) , "::" , stringify ! (fVkInfo))) ; } test_field_fVkInfo () ; fn test_field_fMockInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMockInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture__bindgen_ty_1) , "::" , stringify ! (fMockInfo))) ; } test_field_fMockInfo () ; } # [test] fn bindgen_test_layout_GrBackendTexture () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendTexture > () , 216usize , concat ! ("Size of: " , stringify ! (GrBackendTexture))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendTexture > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendTexture))) ; fn test_field_fIsValid () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsValid) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fIsValid))) ; } test_field_fIsValid () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fLabel () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLabel) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fLabel))) ; } test_field_fLabel () ; fn test_field_fMipmapped () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMipmapped) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fMipmapped))) ; } test_field_fMipmapped () ; fn test_field_fBackend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackend) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fBackend))) ; } test_field_fBackend () ; fn test_field_fTextureType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextureType) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fTextureType))) ; } test_field_fTextureType () ; fn test_field_fMutableState () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendTexture > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMutableState) as usize - ptr as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (GrBackendTexture) , "::" , stringify ! (fMutableState))) ; } test_field_fMutableState () ; } extern "C" { # [link_name = "\u{1}?getVkImageInfo@GrBackendTexture@@QEBA_NPEAUGrVkImageInfo@@@Z"] pub fn GrBackendTexture_getVkImageInfo (this : * const GrBackendTexture , arg1 : * mut GrVkImageInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?setVkImageLayout@GrBackendTexture@@QEAAXW4VkImageLayout@@@Z"] pub fn GrBackendTexture_setVkImageLayout (this : * mut GrBackendTexture , arg1 : VkImageLayout) ; } extern "C" { # [link_name = "\u{1}?getBackendFormat@GrBackendTexture@@QEBA?AVGrBackendFormat@@XZ"] pub fn GrBackendTexture_getBackendFormat (this : * const GrBackendTexture) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?getMockTextureInfo@GrBackendTexture@@QEBA_NPEAUGrMockTextureInfo@@@Z"] pub fn GrBackendTexture_getMockTextureInfo (this : * const GrBackendTexture , arg1 : * mut GrMockTextureInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?setMutableState@GrBackendTexture@@QEAAXAEBVGrBackendSurfaceMutableState@@@Z"] pub fn GrBackendTexture_setMutableState (this : * mut GrBackendTexture , arg1 : * const GrBackendSurfaceMutableState) ; } extern "C" { # [link_name = "\u{1}?isProtected@GrBackendTexture@@QEBA_NXZ"] pub fn GrBackendTexture_isProtected (this : * const GrBackendTexture) -> bool ; } extern "C" { # [link_name = "\u{1}?isSameTexture@GrBackendTexture@@QEAA_NAEBV1@@Z"] pub fn GrBackendTexture_isSameTexture (this : * mut GrBackendTexture , arg1 : * const GrBackendTexture) -> bool ; } extern "C" { # [link_name = "\u{1}??0GrBackendTexture@@QEAA@XZ"] pub fn GrBackendTexture_GrBackendTexture (this : * mut GrBackendTexture) ; } extern "C" { # [link_name = "\u{1}??0GrBackendTexture@@QEAA@HHAEBUGrVkImageInfo@@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z"] pub fn GrBackendTexture_GrBackendTexture1 (this : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo , label : std_string_view) ; } extern "C" { # [link_name = "\u{1}??0GrBackendTexture@@QEAA@HHW4GrMipmapped@@AEBUGrMockTextureInfo@@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z"] pub fn GrBackendTexture_GrBackendTexture2 (this : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipmapped , mockInfo : * const GrMockTextureInfo , label : std_string_view) ; } extern "C" { # [link_name = "\u{1}??0GrBackendTexture@@QEAA@AEBV0@@Z"] pub fn GrBackendTexture_GrBackendTexture3 (this : * mut GrBackendTexture , that : * const GrBackendTexture) ; } impl GrBackendTexture { # [inline] pub unsafe fn getVkImageInfo (& self , arg1 : * mut GrVkImageInfo) -> bool { GrBackendTexture_getVkImageInfo (self , arg1) } # [inline] pub unsafe fn setVkImageLayout (& mut self , arg1 : VkImageLayout) { GrBackendTexture_setVkImageLayout (self , arg1) } # [inline] pub unsafe fn getBackendFormat (& self) -> GrBackendFormat { GrBackendTexture_getBackendFormat (self) } # [inline] pub unsafe fn getMockTextureInfo (& self , arg1 : * mut GrMockTextureInfo) -> bool { GrBackendTexture_getMockTextureInfo (self , arg1) } # [inline] pub unsafe fn setMutableState (& mut self , arg1 : * const GrBackendSurfaceMutableState) { GrBackendTexture_setMutableState (self , arg1) } # [inline] pub unsafe fn isProtected (& self) -> bool { GrBackendTexture_isProtected (self) } # [inline] pub unsafe fn isSameTexture (& mut self , arg1 : * const GrBackendTexture) -> bool { GrBackendTexture_isSameTexture (self , arg1) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendTexture_GrBackendTexture (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo , label : std_string_view) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendTexture_GrBackendTexture1 (__bindgen_tmp . as_mut_ptr () , width , height , vkInfo , label) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : GrMipmapped , mockInfo : * const GrMockTextureInfo , label : std_string_view) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendTexture_GrBackendTexture2 (__bindgen_tmp . as_mut_ptr () , width , height , arg1 , mockInfo , label) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (that : * const GrBackendTexture) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendTexture_GrBackendTexture3 (__bindgen_tmp . as_mut_ptr () , that) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct GrBackendRenderTarget { pub fIsValid : bool , pub fFramebufferOnly : bool , pub fWidth : :: std :: os :: raw :: c_int , pub fHeight : :: std :: os :: raw :: c_int , pub fSampleCnt : :: std :: os :: raw :: c_int , pub fStencilBits : :: std :: os :: raw :: c_int , pub fBackend : GrBackendApi , pub __bindgen_anon_1 : GrBackendRenderTarget__bindgen_ty_1 , pub fMutableState : sk_sp < GrBackendSurfaceMutableStateImpl > , } # [repr (C)] # [derive (Copy , Clone)] pub union GrBackendRenderTarget__bindgen_ty_1 { pub fVkInfo : GrVkBackendSurfaceInfo , pub fMockInfo : GrMockRenderTargetInfo , } # [test] fn bindgen_test_layout_GrBackendRenderTarget__bindgen_ty_1 () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendRenderTarget__bindgen_ty_1 > () , 144usize , concat ! ("Size of: " , stringify ! (GrBackendRenderTarget__bindgen_ty_1))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendRenderTarget__bindgen_ty_1 > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendRenderTarget__bindgen_ty_1))) ; fn test_field_fVkInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget__bindgen_ty_1) , "::" , stringify ! (fVkInfo))) ; } test_field_fVkInfo () ; fn test_field_fMockInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget__bindgen_ty_1 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMockInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget__bindgen_ty_1) , "::" , stringify ! (fMockInfo))) ; } test_field_fMockInfo () ; } # [test] fn bindgen_test_layout_GrBackendRenderTarget () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendRenderTarget > () , 176usize , concat ! ("Size of: " , stringify ! (GrBackendRenderTarget))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendRenderTarget > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendRenderTarget))) ; fn test_field_fIsValid () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsValid) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fIsValid))) ; } test_field_fIsValid () ; fn test_field_fFramebufferOnly () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFramebufferOnly) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fFramebufferOnly))) ; } test_field_fFramebufferOnly () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fSampleCnt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSampleCnt) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fSampleCnt))) ; } test_field_fSampleCnt () ; fn test_field_fStencilBits () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStencilBits) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fStencilBits))) ; } test_field_fStencilBits () ; fn test_field_fBackend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackend) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fBackend))) ; } test_field_fBackend () ; fn test_field_fMutableState () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendRenderTarget > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMutableState) as usize - ptr as usize } , 168usize , concat ! ("Offset of field: " , stringify ! (GrBackendRenderTarget) , "::" , stringify ! (fMutableState))) ; } test_field_fMutableState () ; } extern "C" { # [link_name = "\u{1}?getVkImageInfo@GrBackendRenderTarget@@QEBA_NPEAUGrVkImageInfo@@@Z"] pub fn GrBackendRenderTarget_getVkImageInfo (this : * const GrBackendRenderTarget , arg1 : * mut GrVkImageInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?setVkImageLayout@GrBackendRenderTarget@@QEAAXW4VkImageLayout@@@Z"] pub fn GrBackendRenderTarget_setVkImageLayout (this : * mut GrBackendRenderTarget , arg1 : VkImageLayout) ; } extern "C" { # [link_name = "\u{1}?getBackendFormat@GrBackendRenderTarget@@QEBA?AVGrBackendFormat@@XZ"] pub fn GrBackendRenderTarget_getBackendFormat (this : * const GrBackendRenderTarget) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?getMockRenderTargetInfo@GrBackendRenderTarget@@QEBA_NPEAUGrMockRenderTargetInfo@@@Z"] pub fn GrBackendRenderTarget_getMockRenderTargetInfo (this : * const GrBackendRenderTarget , arg1 : * mut GrMockRenderTargetInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?setMutableState@GrBackendRenderTarget@@QEAAXAEBVGrBackendSurfaceMutableState@@@Z"] pub fn GrBackendRenderTarget_setMutableState (this : * mut GrBackendRenderTarget , arg1 : * const GrBackendSurfaceMutableState) ; } extern "C" { # [link_name = "\u{1}?isProtected@GrBackendRenderTarget@@QEBA_NXZ"] pub fn GrBackendRenderTarget_isProtected (this : * const GrBackendRenderTarget) -> bool ; } extern "C" { # [link_name = "\u{1}??0GrBackendRenderTarget@@QEAA@XZ"] pub fn GrBackendRenderTarget_GrBackendRenderTarget (this : * mut GrBackendRenderTarget) ; } extern "C" { # [link_name = "\u{1}??0GrBackendRenderTarget@@QEAA@HHHAEBUGrVkImageInfo@@@Z"] pub fn GrBackendRenderTarget_GrBackendRenderTarget1 (this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo) ; } extern "C" { # [link_name = "\u{1}??0GrBackendRenderTarget@@QEAA@HHAEBUGrVkImageInfo@@@Z"] pub fn GrBackendRenderTarget_GrBackendRenderTarget2 (this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo) ; } extern "C" { # [link_name = "\u{1}??0GrBackendRenderTarget@@QEAA@HHHHAEBUGrMockRenderTargetInfo@@@Z"] pub fn GrBackendRenderTarget_GrBackendRenderTarget3 (this : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , mockInfo : * const GrMockRenderTargetInfo) ; } extern "C" { # [link_name = "\u{1}??0GrBackendRenderTarget@@QEAA@AEBV0@@Z"] pub fn GrBackendRenderTarget_GrBackendRenderTarget4 (this : * mut GrBackendRenderTarget , that : * const GrBackendRenderTarget) ; } impl GrBackendRenderTarget { # [inline] pub unsafe fn getVkImageInfo (& self , arg1 : * mut GrVkImageInfo) -> bool { GrBackendRenderTarget_getVkImageInfo (self , arg1) } # [inline] pub unsafe fn setVkImageLayout (& mut self , arg1 : VkImageLayout) { GrBackendRenderTarget_setVkImageLayout (self , arg1) } # [inline] pub unsafe fn getBackendFormat (& self) -> GrBackendFormat { GrBackendRenderTarget_getBackendFormat (self) } # [inline] pub unsafe fn getMockRenderTargetInfo (& self , arg1 : * mut GrMockRenderTargetInfo) -> bool { GrBackendRenderTarget_getMockRenderTargetInfo (self , arg1) } # [inline] pub unsafe fn setMutableState (& mut self , arg1 : * const GrBackendSurfaceMutableState) { GrBackendRenderTarget_setMutableState (self , arg1) } # [inline] pub unsafe fn isProtected (& self) -> bool { GrBackendRenderTarget_isProtected (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendRenderTarget_GrBackendRenderTarget (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendRenderTarget_GrBackendRenderTarget1 (__bindgen_tmp . as_mut_ptr () , width , height , sampleCnt , vkInfo) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendRenderTarget_GrBackendRenderTarget2 (__bindgen_tmp . as_mut_ptr () , width , height , vkInfo) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , stencilBits : :: std :: os :: raw :: c_int , mockInfo : * const GrMockRenderTargetInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendRenderTarget_GrBackendRenderTarget3 (__bindgen_tmp . as_mut_ptr () , width , height , sampleCnt , stencilBits , mockInfo) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new4 (that : * const GrBackendRenderTarget) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrBackendRenderTarget_GrBackendRenderTarget4 (__bindgen_tmp . as_mut_ptr () , that) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct GrDriverBugWorkarounds { pub add_and_true_to_loop_condition : bool , pub disable_blend_equation_advanced : bool , pub disable_discard_framebuffer : bool , pub disable_dual_source_blending_support : bool , pub disable_texture_storage : bool , pub disallow_large_instanced_draw : bool , pub emulate_abs_int_function : bool , pub flush_on_framebuffer_change : bool , pub force_update_scissor_state_when_binding_fbo0 : bool , pub gl_clear_broken : bool , pub max_fragment_uniform_vectors_32 : bool , pub max_msaa_sample_count_4 : bool , pub pack_parameters_workaround_with_pack_buffer : bool , pub remove_pow_with_constant_exponent : bool , pub rewrite_do_while_loops : bool , pub unbind_attachments_on_bound_render_fbo_delete : bool , pub unfold_short_circuit_as_ternary_operation : bool , } # [test] fn bindgen_test_layout_GrDriverBugWorkarounds () { assert_eq ! (:: core :: mem :: size_of :: < GrDriverBugWorkarounds > () , 17usize , concat ! ("Size of: " , stringify ! (GrDriverBugWorkarounds))) ; assert_eq ! (:: core :: mem :: align_of :: < GrDriverBugWorkarounds > () , 1usize , concat ! ("Alignment of " , stringify ! (GrDriverBugWorkarounds))) ; fn test_field_add_and_true_to_loop_condition () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . add_and_true_to_loop_condition) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (add_and_true_to_loop_condition))) ; } test_field_add_and_true_to_loop_condition () ; fn test_field_disable_blend_equation_advanced () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . disable_blend_equation_advanced) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (disable_blend_equation_advanced))) ; } test_field_disable_blend_equation_advanced () ; fn test_field_disable_discard_framebuffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . disable_discard_framebuffer) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (disable_discard_framebuffer))) ; } test_field_disable_discard_framebuffer () ; fn test_field_disable_dual_source_blending_support () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . disable_dual_source_blending_support) as usize - ptr as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (disable_dual_source_blending_support))) ; } test_field_disable_dual_source_blending_support () ; fn test_field_disable_texture_storage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . disable_texture_storage) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (disable_texture_storage))) ; } test_field_disable_texture_storage () ; fn test_field_disallow_large_instanced_draw () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . disallow_large_instanced_draw) as usize - ptr as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (disallow_large_instanced_draw))) ; } test_field_disallow_large_instanced_draw () ; fn test_field_emulate_abs_int_function () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . emulate_abs_int_function) as usize - ptr as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (emulate_abs_int_function))) ; } test_field_emulate_abs_int_function () ; fn test_field_flush_on_framebuffer_change () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . flush_on_framebuffer_change) as usize - ptr as usize } , 7usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (flush_on_framebuffer_change))) ; } test_field_flush_on_framebuffer_change () ; fn test_field_force_update_scissor_state_when_binding_fbo0 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . force_update_scissor_state_when_binding_fbo0) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (force_update_scissor_state_when_binding_fbo0))) ; } test_field_force_update_scissor_state_when_binding_fbo0 () ; fn test_field_gl_clear_broken () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . gl_clear_broken) as usize - ptr as usize } , 9usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (gl_clear_broken))) ; } test_field_gl_clear_broken () ; fn test_field_max_fragment_uniform_vectors_32 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . max_fragment_uniform_vectors_32) as usize - ptr as usize } , 10usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (max_fragment_uniform_vectors_32))) ; } test_field_max_fragment_uniform_vectors_32 () ; fn test_field_max_msaa_sample_count_4 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . max_msaa_sample_count_4) as usize - ptr as usize } , 11usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (max_msaa_sample_count_4))) ; } test_field_max_msaa_sample_count_4 () ; fn test_field_pack_parameters_workaround_with_pack_buffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . pack_parameters_workaround_with_pack_buffer) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (pack_parameters_workaround_with_pack_buffer))) ; } test_field_pack_parameters_workaround_with_pack_buffer () ; fn test_field_remove_pow_with_constant_exponent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . remove_pow_with_constant_exponent) as usize - ptr as usize } , 13usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (remove_pow_with_constant_exponent))) ; } test_field_remove_pow_with_constant_exponent () ; fn test_field_rewrite_do_while_loops () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . rewrite_do_while_loops) as usize - ptr as usize } , 14usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (rewrite_do_while_loops))) ; } test_field_rewrite_do_while_loops () ; fn test_field_unbind_attachments_on_bound_render_fbo_delete () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . unbind_attachments_on_bound_render_fbo_delete) as usize - ptr as usize } , 15usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (unbind_attachments_on_bound_render_fbo_delete))) ; } test_field_unbind_attachments_on_bound_render_fbo_delete () ; fn test_field_unfold_short_circuit_as_ternary_operation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDriverBugWorkarounds > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . unfold_short_circuit_as_ternary_operation) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrDriverBugWorkarounds) , "::" , stringify ! (unfold_short_circuit_as_ternary_operation))) ; } test_field_unfold_short_circuit_as_ternary_operation () ; } extern "C" { # [link_name = "\u{1}?applyOverrides@GrDriverBugWorkarounds@@QEAAXAEBV1@@Z"] pub fn GrDriverBugWorkarounds_applyOverrides (this : * mut GrDriverBugWorkarounds , workarounds : * const GrDriverBugWorkarounds) ; } extern "C" { # [link_name = "\u{1}??0GrDriverBugWorkarounds@@QEAA@XZ"] pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds (this : * mut GrDriverBugWorkarounds) ; } extern "C" { # [link_name = "\u{1}??0GrDriverBugWorkarounds@@QEAA@AEBV?$vector@HV?$allocator@H@std@@@std@@@Z"] pub fn GrDriverBugWorkarounds_GrDriverBugWorkarounds1 (this : * mut GrDriverBugWorkarounds , workarounds : * const [u64 ; 3usize]) ; } impl GrDriverBugWorkarounds { # [inline] pub unsafe fn applyOverrides (& mut self , workarounds : * const GrDriverBugWorkarounds) { GrDriverBugWorkarounds_applyOverrides (self , workarounds) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrDriverBugWorkarounds_GrDriverBugWorkarounds (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (workarounds : * const [u64 ; 3usize]) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrDriverBugWorkarounds_GrDriverBugWorkarounds1 (__bindgen_tmp . as_mut_ptr () , workarounds) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkExecutor { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct GrContextOptions { pub fSuppressPrints : bool , pub fSkipGLErrorChecks : GrContextOptions_Enable , pub fMaxTextureSizeOverride : :: std :: os :: raw :: c_int , pub fBufferMapThreshold : :: std :: os :: raw :: c_int , pub fExecutor : * mut SkExecutor , pub fDoManualMipmapping : bool , pub fDisableCoverageCountingPaths : bool , pub fDisableDistanceFieldPaths : bool , pub fAllowPathMaskCaching : bool , pub fDisableGpuYUVConversion : bool , pub fGlyphCacheTextureMaximumBytes : usize , pub fMinDistanceFieldFontSize : f32 , pub fGlyphsAsPathsFontSize : f32 , pub fAllowMultipleGlyphCacheTextures : GrContextOptions_Enable , pub fAvoidStencilBuffers : bool , pub fUseDrawInsteadOfClear : GrContextOptions_Enable , pub fReduceOpsTaskSplitting : GrContextOptions_Enable , pub fPreferExternalImagesOverES3 : bool , pub fDisableDriverCorrectnessWorkarounds : bool , pub fRuntimeProgramCacheSize : :: std :: os :: raw :: c_int , pub fPersistentCache : * mut GrContextOptions_PersistentCache , pub fShaderCacheStrategy : GrContextOptions_ShaderCacheStrategy , pub fShaderErrorHandler : * mut GrContextOptions_ShaderErrorHandler , pub fInternalMultisampleCount : :: std :: os :: raw :: c_int , pub fMaxCachedVulkanSecondaryCommandBuffers : :: std :: os :: raw :: c_int , pub fSuppressMipmapSupport : bool , pub fEnableExperimentalHardwareTessellation : bool , pub fSupportBilerpFromGlyphAtlas : bool , pub fReducedShaderVariations : bool , pub fAllowMSAAOnNewIntel : bool , pub fDriverBugWorkarounds : GrDriverBugWorkarounds , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrContextOptions_Enable { No = 0 , Yes = 1 , Default = 2 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrContextOptions_ShaderCacheStrategy { SkSL = 0 , BackendSource = 1 , BackendBinary = 2 , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct GrContextOptions_PersistentCache { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_GrContextOptions_PersistentCache () { assert_eq ! (:: core :: mem :: size_of :: < GrContextOptions_PersistentCache > () , 8usize , concat ! ("Size of: " , stringify ! (GrContextOptions_PersistentCache))) ; assert_eq ! (:: core :: mem :: align_of :: < GrContextOptions_PersistentCache > () , 8usize , concat ! ("Alignment of " , stringify ! (GrContextOptions_PersistentCache))) ; } pub type GrContextOptions_ShaderErrorHandler = u64 ; # [test] fn bindgen_test_layout_GrContextOptions () { assert_eq ! (:: core :: mem :: size_of :: < GrContextOptions > () , 128usize , concat ! ("Size of: " , stringify ! (GrContextOptions))) ; assert_eq ! (:: core :: mem :: align_of :: < GrContextOptions > () , 8usize , concat ! ("Alignment of " , stringify ! (GrContextOptions))) ; fn test_field_fSuppressPrints () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSuppressPrints) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fSuppressPrints))) ; } test_field_fSuppressPrints () ; fn test_field_fSkipGLErrorChecks () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSkipGLErrorChecks) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fSkipGLErrorChecks))) ; } test_field_fSkipGLErrorChecks () ; fn test_field_fMaxTextureSizeOverride () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxTextureSizeOverride) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fMaxTextureSizeOverride))) ; } test_field_fMaxTextureSizeOverride () ; fn test_field_fBufferMapThreshold () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBufferMapThreshold) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fBufferMapThreshold))) ; } test_field_fBufferMapThreshold () ; fn test_field_fExecutor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExecutor) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fExecutor))) ; } test_field_fExecutor () ; fn test_field_fDoManualMipmapping () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDoManualMipmapping) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDoManualMipmapping))) ; } test_field_fDoManualMipmapping () ; fn test_field_fDisableCoverageCountingPaths () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDisableCoverageCountingPaths) as usize - ptr as usize } , 25usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDisableCoverageCountingPaths))) ; } test_field_fDisableCoverageCountingPaths () ; fn test_field_fDisableDistanceFieldPaths () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDisableDistanceFieldPaths) as usize - ptr as usize } , 26usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDisableDistanceFieldPaths))) ; } test_field_fDisableDistanceFieldPaths () ; fn test_field_fAllowPathMaskCaching () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAllowPathMaskCaching) as usize - ptr as usize } , 27usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fAllowPathMaskCaching))) ; } test_field_fAllowPathMaskCaching () ; fn test_field_fDisableGpuYUVConversion () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDisableGpuYUVConversion) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDisableGpuYUVConversion))) ; } test_field_fDisableGpuYUVConversion () ; fn test_field_fGlyphCacheTextureMaximumBytes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphCacheTextureMaximumBytes) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fGlyphCacheTextureMaximumBytes))) ; } test_field_fGlyphCacheTextureMaximumBytes () ; fn test_field_fMinDistanceFieldFontSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMinDistanceFieldFontSize) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fMinDistanceFieldFontSize))) ; } test_field_fMinDistanceFieldFontSize () ; fn test_field_fGlyphsAsPathsFontSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphsAsPathsFontSize) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fGlyphsAsPathsFontSize))) ; } test_field_fGlyphsAsPathsFontSize () ; fn test_field_fAllowMultipleGlyphCacheTextures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAllowMultipleGlyphCacheTextures) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fAllowMultipleGlyphCacheTextures))) ; } test_field_fAllowMultipleGlyphCacheTextures () ; fn test_field_fAvoidStencilBuffers () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAvoidStencilBuffers) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fAvoidStencilBuffers))) ; } test_field_fAvoidStencilBuffers () ; fn test_field_fUseDrawInsteadOfClear () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUseDrawInsteadOfClear) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fUseDrawInsteadOfClear))) ; } test_field_fUseDrawInsteadOfClear () ; fn test_field_fReduceOpsTaskSplitting () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReduceOpsTaskSplitting) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fReduceOpsTaskSplitting))) ; } test_field_fReduceOpsTaskSplitting () ; fn test_field_fPreferExternalImagesOverES3 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPreferExternalImagesOverES3) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fPreferExternalImagesOverES3))) ; } test_field_fPreferExternalImagesOverES3 () ; fn test_field_fDisableDriverCorrectnessWorkarounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDisableDriverCorrectnessWorkarounds) as usize - ptr as usize } , 65usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDisableDriverCorrectnessWorkarounds))) ; } test_field_fDisableDriverCorrectnessWorkarounds () ; fn test_field_fRuntimeProgramCacheSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRuntimeProgramCacheSize) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fRuntimeProgramCacheSize))) ; } test_field_fRuntimeProgramCacheSize () ; fn test_field_fPersistentCache () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPersistentCache) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fPersistentCache))) ; } test_field_fPersistentCache () ; fn test_field_fShaderCacheStrategy () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fShaderCacheStrategy) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fShaderCacheStrategy))) ; } test_field_fShaderCacheStrategy () ; fn test_field_fShaderErrorHandler () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fShaderErrorHandler) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fShaderErrorHandler))) ; } test_field_fShaderErrorHandler () ; fn test_field_fInternalMultisampleCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInternalMultisampleCount) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fInternalMultisampleCount))) ; } test_field_fInternalMultisampleCount () ; fn test_field_fMaxCachedVulkanSecondaryCommandBuffers () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxCachedVulkanSecondaryCommandBuffers) as usize - ptr as usize } , 100usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fMaxCachedVulkanSecondaryCommandBuffers))) ; } test_field_fMaxCachedVulkanSecondaryCommandBuffers () ; fn test_field_fSuppressMipmapSupport () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSuppressMipmapSupport) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fSuppressMipmapSupport))) ; } test_field_fSuppressMipmapSupport () ; fn test_field_fEnableExperimentalHardwareTessellation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEnableExperimentalHardwareTessellation) as usize - ptr as usize } , 105usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fEnableExperimentalHardwareTessellation))) ; } test_field_fEnableExperimentalHardwareTessellation () ; fn test_field_fSupportBilerpFromGlyphAtlas () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSupportBilerpFromGlyphAtlas) as usize - ptr as usize } , 106usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fSupportBilerpFromGlyphAtlas))) ; } test_field_fSupportBilerpFromGlyphAtlas () ; fn test_field_fReducedShaderVariations () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReducedShaderVariations) as usize - ptr as usize } , 107usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fReducedShaderVariations))) ; } test_field_fReducedShaderVariations () ; fn test_field_fAllowMSAAOnNewIntel () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAllowMSAAOnNewIntel) as usize - ptr as usize } , 108usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fAllowMSAAOnNewIntel))) ; } test_field_fAllowMSAAOnNewIntel () ; fn test_field_fDriverBugWorkarounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrContextOptions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDriverBugWorkarounds) as usize - ptr as usize } , 109usize , concat ! ("Offset of field: " , stringify ! (GrContextOptions) , "::" , stringify ! (fDriverBugWorkarounds))) ; } test_field_fDriverBugWorkarounds () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrThreadSafeCache { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrThreadSafePipelineBuilder { _unused : [u8 ; 0] , } extern "C" { # [link_name = "\u{1}?createCharacterization@GrContextThreadSafeProxy@@QEAA?AVSkSurfaceCharacterization@@_KAEBUSkImageInfo@@AEBVGrBackendFormat@@HW4GrSurfaceOrigin@@AEBVSkSurfaceProps@@_N55W4GrProtected@@55@Z"] pub fn GrContextThreadSafeProxy_createCharacterization (this : * mut GrContextThreadSafeProxy , cacheMaxResourceBytes : usize , ii : * const SkImageInfo , backendFormat : * const GrBackendFormat , sampleCount : :: std :: os :: raw :: c_int , origin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , isMipMapped : bool , willUseGLFBO0 : bool , isTextureable : bool , isProtected : GrProtected , vkRTSupportsInputAttachment : bool , forVulkanSecondaryCommandBuffer : bool) -> SkSurfaceCharacterization ; } extern "C" { # [link_name = "\u{1}?defaultBackendFormat@GrContextThreadSafeProxy@@QEBA?AVGrBackendFormat@@W4SkColorType@@W4GrRenderable@@@Z"] pub fn GrContextThreadSafeProxy_defaultBackendFormat (this : * const GrContextThreadSafeProxy , ct : SkColorType , renderable : GrRenderable) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?compressedBackendFormat@GrContextThreadSafeProxy@@QEBA?AVGrBackendFormat@@W4CompressionType@SkImage@@@Z"] pub fn GrContextThreadSafeProxy_compressedBackendFormat (this : * const GrContextThreadSafeProxy , c : SkImage_CompressionType) -> GrBackendFormat ; } extern "C" { # [link_name = "\u{1}?maxSurfaceSampleCountForColorType@GrContextThreadSafeProxy@@QEBAHW4SkColorType@@@Z"] pub fn GrContextThreadSafeProxy_maxSurfaceSampleCountForColorType (this : * const GrContextThreadSafeProxy , colorType : SkColorType) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?priv@GrContextThreadSafeProxy@@QEAA?AVGrContextThreadSafeProxyPriv@@XZ"] pub fn GrContextThreadSafeProxy_priv (this : * mut GrContextThreadSafeProxy) -> GrContextThreadSafeProxyPriv ; } extern "C" { # [link_name = "\u{1}?priv@GrContextThreadSafeProxy@@QEBA?BVGrContextThreadSafeProxyPriv@@XZ"] pub fn GrContextThreadSafeProxy_priv1 (this : * const GrContextThreadSafeProxy) -> GrContextThreadSafeProxyPriv ; } # [repr (C)] pub struct SkSurfaceCharacterization { pub fContextInfo : sk_sp < GrContextThreadSafeProxy > , pub fCacheMaxResourceBytes : usize , pub fImageInfo : SkImageInfo , pub fBackendFormat : GrBackendFormat , pub fOrigin : GrSurfaceOrigin , pub fSampleCnt : :: std :: os :: raw :: c_int , pub fIsTextureable : SkSurfaceCharacterization_Textureable , pub fIsMipMapped : SkSurfaceCharacterization_MipMapped , pub fUsesGLFBO0 : SkSurfaceCharacterization_UsesGLFBO0 , pub fVkRTSupportsInputAttachment : SkSurfaceCharacterization_VkRTSupportsInputAttachment , pub fVulkanSecondaryCBCompatible : SkSurfaceCharacterization_VulkanSecondaryCBCompatible , pub fIsProtected : GrProtected , pub fSurfaceProps : SkSurfaceProps , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurfaceCharacterization_Textureable { kNo = 0 , kYes = 1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurfaceCharacterization_MipMapped { kNo = 0 , kYes = 1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurfaceCharacterization_UsesGLFBO0 { kNo = 0 , kYes = 1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurfaceCharacterization_VkRTSupportsInputAttachment { kNo = 0 , kYes = 1 , } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurfaceCharacterization_VulkanSecondaryCBCompatible { kNo = 0 , kYes = 1 , } # [test] fn bindgen_test_layout_SkSurfaceCharacterization () { assert_eq ! (:: core :: mem :: size_of :: < SkSurfaceCharacterization > () , 136usize , concat ! ("Size of: " , stringify ! (SkSurfaceCharacterization))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSurfaceCharacterization > () , 8usize , concat ! ("Alignment of " , stringify ! (SkSurfaceCharacterization))) ; fn test_field_fContextInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fContextInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fContextInfo))) ; } test_field_fContextInfo () ; fn test_field_fCacheMaxResourceBytes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCacheMaxResourceBytes) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fCacheMaxResourceBytes))) ; } test_field_fCacheMaxResourceBytes () ; fn test_field_fImageInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fImageInfo) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fImageInfo))) ; } test_field_fImageInfo () ; fn test_field_fBackendFormat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackendFormat) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fBackendFormat))) ; } test_field_fBackendFormat () ; fn test_field_fOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOrigin) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fOrigin))) ; } test_field_fOrigin () ; fn test_field_fSampleCnt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSampleCnt) as usize - ptr as usize } , 116usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fSampleCnt))) ; } test_field_fSampleCnt () ; fn test_field_fIsTextureable () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsTextureable) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fIsTextureable))) ; } test_field_fIsTextureable () ; fn test_field_fIsMipMapped () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsMipMapped) as usize - ptr as usize } , 121usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fIsMipMapped))) ; } test_field_fIsMipMapped () ; fn test_field_fUsesGLFBO0 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUsesGLFBO0) as usize - ptr as usize } , 122usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fUsesGLFBO0))) ; } test_field_fUsesGLFBO0 () ; fn test_field_fVkRTSupportsInputAttachment () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkRTSupportsInputAttachment) as usize - ptr as usize } , 123usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fVkRTSupportsInputAttachment))) ; } test_field_fVkRTSupportsInputAttachment () ; fn test_field_fVulkanSecondaryCBCompatible () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVulkanSecondaryCBCompatible) as usize - ptr as usize } , 124usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fVulkanSecondaryCBCompatible))) ; } test_field_fVulkanSecondaryCBCompatible () ; fn test_field_fIsProtected () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsProtected) as usize - ptr as usize } , 125usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fIsProtected))) ; } test_field_fIsProtected () ; fn test_field_fSurfaceProps () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkSurfaceCharacterization > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSurfaceProps) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (SkSurfaceCharacterization) , "::" , stringify ! (fSurfaceProps))) ; } test_field_fSurfaceProps () ; } extern "C" { # [link_name = "\u{1}?createResized@SkSurfaceCharacterization@@QEBA?AV1@HH@Z"] pub fn SkSurfaceCharacterization_createResized (this : * const SkSurfaceCharacterization , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkSurfaceCharacterization ; } extern "C" { # [link_name = "\u{1}?createColorSpace@SkSurfaceCharacterization@@QEBA?AV1@V?$sk_sp@VSkColorSpace@@@@@Z"] pub fn SkSurfaceCharacterization_createColorSpace (this : * const SkSurfaceCharacterization , arg1 : sk_sp < SkColorSpace >) -> SkSurfaceCharacterization ; } extern "C" { # [link_name = "\u{1}?createBackendFormat@SkSurfaceCharacterization@@QEBA?AV1@W4SkColorType@@AEBVGrBackendFormat@@@Z"] pub fn SkSurfaceCharacterization_createBackendFormat (this : * const SkSurfaceCharacterization , colorType : SkColorType , backendFormat : * const GrBackendFormat) -> SkSurfaceCharacterization ; } extern "C" { # [link_name = "\u{1}?createFBO0@SkSurfaceCharacterization@@QEBA?AV1@_N@Z"] pub fn SkSurfaceCharacterization_createFBO0 (this : * const SkSurfaceCharacterization , usesGLFBO0 : bool) -> SkSurfaceCharacterization ; } extern "C" { # [link_name = "\u{1}?isCompatible@SkSurfaceCharacterization@@QEBA_NAEBVGrBackendTexture@@@Z"] pub fn SkSurfaceCharacterization_isCompatible (this : * const SkSurfaceCharacterization , arg1 : * const GrBackendTexture) -> bool ; } impl SkSurfaceCharacterization { # [inline] pub unsafe fn createResized (& self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> SkSurfaceCharacterization { SkSurfaceCharacterization_createResized (self , width , height) } # [inline] pub unsafe fn createColorSpace (& self , arg1 : sk_sp < SkColorSpace >) -> SkSurfaceCharacterization { SkSurfaceCharacterization_createColorSpace (self , arg1) } # [inline] pub unsafe fn createBackendFormat (& self , colorType : SkColorType , backendFormat : * const GrBackendFormat) -> SkSurfaceCharacterization { SkSurfaceCharacterization_createBackendFormat (self , colorType , backendFormat) } # [inline] pub unsafe fn createFBO0 (& self , usesGLFBO0 : bool) -> SkSurfaceCharacterization { SkSurfaceCharacterization_createFBO0 (self , usesGLFBO0) } # [inline] pub unsafe fn isCompatible (& self , arg1 : * const GrBackendTexture) -> bool { SkSurfaceCharacterization_isCompatible (self , arg1) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDeferredDisplayListPriv { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBaseContextPriv { _unused : [u8 ; 0] , } pub type GrContext_Base_INHERITED = SkRefCnt ; extern "C" { # [link_name = "\u{1}?priv@GrImageContext@@QEAA?AVGrImageContextPriv@@XZ"] pub fn GrImageContext_priv (this : * mut GrImageContext) -> GrImageContextPriv ; } extern "C" { # [link_name = "\u{1}?priv@GrImageContext@@QEBA?BVGrImageContextPriv@@XZ"] pub fn GrImageContext_priv1 (this : * const GrImageContext) -> GrImageContextPriv ; } extern "C" { # [link_name = "\u{1}??0GrImageContext@@IEAA@V?$sk_sp@VGrContextThreadSafeProxy@@@@@Z"] pub fn GrImageContext_GrImageContext (this : * mut GrImageContext , arg1 : sk_sp < GrContextThreadSafeProxy >) ; } extern "C" { # [link_name = "\u{1}?abandonContext@GrImageContext@@MEAAXXZ"] pub fn GrImageContext_abandonContext (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?abandoned@GrImageContext@@MEAA_NXZ"] pub fn GrImageContext_abandoned (this : * mut :: core :: ffi :: c_void) -> bool ; } pub type GrImageContext_INHERITED = GrContext_Base ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrDrawingManager { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrOnFlushCallbackObject { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrProgramDesc { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrProgramInfo { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCapabilities { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkJSONWriter { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct GrRecordingContext { pub _bindgen_opaque_blob : [u64 ; 11usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrRecordingContext_Arenas { pub fRecordTimeAllocator : * mut SkArenaAlloc , pub fRecordTimeSubRunAllocator : * mut sktext_gpu_SubRunAllocator , } # [test] fn bindgen_test_layout_GrRecordingContext_Arenas () { assert_eq ! (:: core :: mem :: size_of :: < GrRecordingContext_Arenas > () , 16usize , concat ! ("Size of: " , stringify ! (GrRecordingContext_Arenas))) ; assert_eq ! (:: core :: mem :: align_of :: < GrRecordingContext_Arenas > () , 8usize , concat ! ("Alignment of " , stringify ! (GrRecordingContext_Arenas))) ; fn test_field_fRecordTimeAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_Arenas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecordTimeAllocator) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_Arenas) , "::" , stringify ! (fRecordTimeAllocator))) ; } test_field_fRecordTimeAllocator () ; fn test_field_fRecordTimeSubRunAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_Arenas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecordTimeSubRunAllocator) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_Arenas) , "::" , stringify ! (fRecordTimeSubRunAllocator))) ; } test_field_fRecordTimeSubRunAllocator () ; } extern "C" { # [link_name = "\u{1}??0Arenas@GrRecordingContext@@QEAA@PEAVSkArenaAlloc@@PEAVSubRunAllocator@gpu@sktext@@@Z"] pub fn GrRecordingContext_Arenas_Arenas (this : * mut GrRecordingContext_Arenas , arg1 : * mut SkArenaAlloc , arg2 : * mut sktext_gpu_SubRunAllocator) ; } impl GrRecordingContext_Arenas { # [inline] pub unsafe fn new (arg1 : * mut SkArenaAlloc , arg2 : * mut sktext_gpu_SubRunAllocator) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrRecordingContext_Arenas_Arenas (__bindgen_tmp . as_mut_ptr () , arg1 , arg2) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct GrRecordingContext_OwnedArenas { pub fDDLRecording : bool , pub fRecordTimeAllocator : u64 , pub fRecordTimeSubRunAllocator : u64 , } # [test] fn bindgen_test_layout_GrRecordingContext_OwnedArenas () { assert_eq ! (:: core :: mem :: size_of :: < GrRecordingContext_OwnedArenas > () , 24usize , concat ! ("Size of: " , stringify ! (GrRecordingContext_OwnedArenas))) ; assert_eq ! (:: core :: mem :: align_of :: < GrRecordingContext_OwnedArenas > () , 8usize , concat ! ("Alignment of " , stringify ! (GrRecordingContext_OwnedArenas))) ; fn test_field_fDDLRecording () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_OwnedArenas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDDLRecording) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_OwnedArenas) , "::" , stringify ! (fDDLRecording))) ; } test_field_fDDLRecording () ; fn test_field_fRecordTimeAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_OwnedArenas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecordTimeAllocator) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_OwnedArenas) , "::" , stringify ! (fRecordTimeAllocator))) ; } test_field_fRecordTimeAllocator () ; fn test_field_fRecordTimeSubRunAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_OwnedArenas > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecordTimeSubRunAllocator) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_OwnedArenas) , "::" , stringify ! (fRecordTimeSubRunAllocator))) ; } test_field_fRecordTimeSubRunAllocator () ; } extern "C" { # [link_name = "\u{1}?get@OwnedArenas@GrRecordingContext@@QEAA?AVArenas@2@XZ"] pub fn GrRecordingContext_OwnedArenas_get (this : * mut GrRecordingContext_OwnedArenas) -> GrRecordingContext_Arenas ; } extern "C" { # [link_name = "\u{1}??0OwnedArenas@GrRecordingContext@@QEAA@_N@Z"] pub fn GrRecordingContext_OwnedArenas_OwnedArenas (this : * mut GrRecordingContext_OwnedArenas , ddlRecording : bool) ; } impl GrRecordingContext_OwnedArenas { # [inline] pub unsafe fn get (& mut self) -> GrRecordingContext_Arenas { GrRecordingContext_OwnedArenas_get (self) } # [inline] pub unsafe fn new (ddlRecording : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrRecordingContext_OwnedArenas_OwnedArenas (__bindgen_tmp . as_mut_ptr () , ddlRecording) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct GrRecordingContext_ProgramData { pub fDesc : u64 , pub fInfo : * const GrProgramInfo , } # [test] fn bindgen_test_layout_GrRecordingContext_ProgramData () { assert_eq ! (:: core :: mem :: size_of :: < GrRecordingContext_ProgramData > () , 16usize , concat ! ("Size of: " , stringify ! (GrRecordingContext_ProgramData))) ; assert_eq ! (:: core :: mem :: align_of :: < GrRecordingContext_ProgramData > () , 8usize , concat ! ("Alignment of " , stringify ! (GrRecordingContext_ProgramData))) ; fn test_field_fDesc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_ProgramData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDesc) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_ProgramData) , "::" , stringify ! (fDesc))) ; } test_field_fDesc () ; fn test_field_fInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrRecordingContext_ProgramData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrRecordingContext_ProgramData) , "::" , stringify ! (fInfo))) ; } test_field_fInfo () ; } extern "C" { # [link_name = "\u{1}??0ProgramData@GrRecordingContext@@QEAA@V?$unique_ptr@$$CBVGrProgramDesc@@U?$default_delete@$$CBVGrProgramDesc@@@std@@@std@@PEBVGrProgramInfo@@@Z"] pub fn GrRecordingContext_ProgramData_ProgramData (this : * mut GrRecordingContext_ProgramData , arg1 : u64 , arg2 : * const GrProgramInfo) ; } extern "C" { # [link_name = "\u{1}??0ProgramData@GrRecordingContext@@QEAA@$$QEAU01@@Z"] pub fn GrRecordingContext_ProgramData_ProgramData1 (this : * mut GrRecordingContext_ProgramData , arg1 : * mut GrRecordingContext_ProgramData) ; } impl GrRecordingContext_ProgramData { # [inline] pub unsafe fn new (arg1 : u64 , arg2 : * const GrProgramInfo) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrRecordingContext_ProgramData_ProgramData (__bindgen_tmp . as_mut_ptr () , arg1 , arg2) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (arg1 : * mut GrRecordingContext_ProgramData) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrRecordingContext_ProgramData_ProgramData1 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrRecordingContext_Stats { pub _address : u8 , } # [test] fn bindgen_test_layout_GrRecordingContext_Stats () { assert_eq ! (:: core :: mem :: size_of :: < GrRecordingContext_Stats > () , 1usize , concat ! ("Size of: " , stringify ! (GrRecordingContext_Stats))) ; assert_eq ! (:: core :: mem :: align_of :: < GrRecordingContext_Stats > () , 1usize , concat ! ("Alignment of " , stringify ! (GrRecordingContext_Stats))) ; } pub type GrRecordingContext_INHERITED = GrImageContext ; # [test] fn bindgen_test_layout_GrRecordingContext () { assert_eq ! (:: core :: mem :: size_of :: < GrRecordingContext > () , 88usize , concat ! ("Size of: " , stringify ! (GrRecordingContext))) ; assert_eq ! (:: core :: mem :: align_of :: < GrRecordingContext > () , 8usize , concat ! ("Alignment of " , stringify ! (GrRecordingContext))) ; } extern "C" { # [link_name = "\u{1}?maxTextureSize@GrRecordingContext@@QEBAHXZ"] pub fn GrRecordingContext_maxTextureSize (this : * const GrRecordingContext) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?maxRenderTargetSize@GrRecordingContext@@QEBAHXZ"] pub fn GrRecordingContext_maxRenderTargetSize (this : * const GrRecordingContext) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?colorTypeSupportedAsImage@GrRecordingContext@@QEBA_NW4SkColorType@@@Z"] pub fn GrRecordingContext_colorTypeSupportedAsImage (this : * const GrRecordingContext , arg1 : SkColorType) -> bool ; } extern "C" { # [link_name = "\u{1}?skCapabilities@GrRecordingContext@@QEBA?AV?$sk_sp@$$CBVSkCapabilities@@@@XZ"] pub fn GrRecordingContext_skCapabilities (this : * const GrRecordingContext) -> sk_sp < SkCapabilities > ; } extern "C" { # [link_name = "\u{1}?drawingManager@GrRecordingContext@@IEAAPEAVGrDrawingManager@@XZ"] pub fn GrRecordingContext_drawingManager (this : * mut GrRecordingContext) -> * mut GrDrawingManager ; } extern "C" { # [link_name = "\u{1}?destroyDrawingManager@GrRecordingContext@@IEAAXXZ"] pub fn GrRecordingContext_destroyDrawingManager (this : * mut GrRecordingContext) ; } extern "C" { # [link_name = "\u{1}?detachArenas@GrRecordingContext@@IEAA$$QEAVOwnedArenas@1@XZ"] pub fn GrRecordingContext_detachArenas (this : * mut GrRecordingContext) -> * mut GrRecordingContext_OwnedArenas ; } extern "C" { # [link_name = "\u{1}?getTextBlobRedrawCoordinator@GrRecordingContext@@IEAAPEAVTextBlobRedrawCoordinator@gpu@sktext@@XZ"] pub fn GrRecordingContext_getTextBlobRedrawCoordinator (this : * mut GrRecordingContext) -> * mut sktext_gpu_TextBlobRedrawCoordinator ; } extern "C" { # [link_name = "\u{1}?getTextBlobRedrawCoordinator@GrRecordingContext@@IEBAPEBVTextBlobRedrawCoordinator@gpu@sktext@@XZ"] pub fn GrRecordingContext_getTextBlobRedrawCoordinator1 (this : * const GrRecordingContext) -> * const sktext_gpu_TextBlobRedrawCoordinator ; } extern "C" { # [link_name = "\u{1}?threadSafeCache@GrRecordingContext@@IEAAPEAVGrThreadSafeCache@@XZ"] pub fn GrRecordingContext_threadSafeCache (this : * mut GrRecordingContext) -> * mut GrThreadSafeCache ; } extern "C" { # [link_name = "\u{1}?threadSafeCache@GrRecordingContext@@IEBAPEBVGrThreadSafeCache@@XZ"] pub fn GrRecordingContext_threadSafeCache1 (this : * const GrRecordingContext) -> * const GrThreadSafeCache ; } extern "C" { # [link_name = "\u{1}?addOnFlushCallbackObject@GrRecordingContext@@IEAAXPEAVGrOnFlushCallbackObject@@@Z"] pub fn GrRecordingContext_addOnFlushCallbackObject (this : * mut GrRecordingContext , arg1 : * mut GrOnFlushCallbackObject) ; } extern "C" { # [link_name = "\u{1}?dumpJSON@GrRecordingContext@@IEBAXPEAVSkJSONWriter@@@Z"] pub fn GrRecordingContext_dumpJSON (this : * const GrRecordingContext , arg1 : * mut SkJSONWriter) ; } extern "C" { # [link_name = "\u{1}??0GrRecordingContext@@IEAA@V?$sk_sp@VGrContextThreadSafeProxy@@@@_N@Z"] pub fn GrRecordingContext_GrRecordingContext (this : * mut GrRecordingContext , arg1 : sk_sp < GrContextThreadSafeProxy > , ddlRecording : bool) ; } impl GrRecordingContext { # [inline] pub unsafe fn maxTextureSize (& self) -> :: std :: os :: raw :: c_int { GrRecordingContext_maxTextureSize (self) } # [inline] pub unsafe fn maxRenderTargetSize (& self) -> :: std :: os :: raw :: c_int { GrRecordingContext_maxRenderTargetSize (self) } # [inline] pub unsafe fn colorTypeSupportedAsImage (& self , arg1 : SkColorType) -> bool { GrRecordingContext_colorTypeSupportedAsImage (self , arg1) } # [inline] pub unsafe fn skCapabilities (& self) -> sk_sp < SkCapabilities > { GrRecordingContext_skCapabilities (self) } # [inline] pub unsafe fn drawingManager (& mut self) -> * mut GrDrawingManager { GrRecordingContext_drawingManager (self) } # [inline] pub unsafe fn destroyDrawingManager (& mut self) { GrRecordingContext_destroyDrawingManager (self) } # [inline] pub unsafe fn detachArenas (& mut self) -> * mut GrRecordingContext_OwnedArenas { GrRecordingContext_detachArenas (self) } # [inline] pub unsafe fn getTextBlobRedrawCoordinator (& mut self) -> * mut sktext_gpu_TextBlobRedrawCoordinator { GrRecordingContext_getTextBlobRedrawCoordinator (self) } # [inline] pub unsafe fn getTextBlobRedrawCoordinator1 (& self) -> * const sktext_gpu_TextBlobRedrawCoordinator { GrRecordingContext_getTextBlobRedrawCoordinator1 (self) } # [inline] pub unsafe fn threadSafeCache (& mut self) -> * mut GrThreadSafeCache { GrRecordingContext_threadSafeCache (self) } # [inline] pub unsafe fn threadSafeCache1 (& self) -> * const GrThreadSafeCache { GrRecordingContext_threadSafeCache1 (self) } # [inline] pub unsafe fn addOnFlushCallbackObject (& mut self , arg1 : * mut GrOnFlushCallbackObject) { GrRecordingContext_addOnFlushCallbackObject (self , arg1) } # [inline] pub unsafe fn dumpJSON (& self , arg1 : * mut SkJSONWriter) { GrRecordingContext_dumpJSON (self , arg1) } # [inline] pub unsafe fn new (arg1 : sk_sp < GrContextThreadSafeProxy > , ddlRecording : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrRecordingContext_GrRecordingContext (__bindgen_tmp . as_mut_ptr () , arg1 , ddlRecording) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?init@GrRecordingContext@@MEAA_NXZ"] pub fn GrRecordingContext_init (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?abandonContext@GrRecordingContext@@MEAAXXZ"] pub fn GrRecordingContext_abandonContext (this : * mut :: core :: ffi :: c_void) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrRenderTargetProxy { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDeferredDisplayList { pub _bindgen_opaque_blob : [u64 ; 27usize] , } # [repr (C)] # [derive (Debug)] pub struct SkDeferredDisplayList_ProgramIterator { pub fDContext : * mut GrDirectContext , pub fProgramData : * const [u64 ; 2usize] , pub fIndex : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_SkDeferredDisplayList_ProgramIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkDeferredDisplayList_ProgramIterator > () , 24usize , concat ! ("Size of: " , stringify ! (SkDeferredDisplayList_ProgramIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeferredDisplayList_ProgramIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeferredDisplayList_ProgramIterator))) ; fn test_field_fDContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayList_ProgramIterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDContext) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayList_ProgramIterator) , "::" , stringify ! (fDContext))) ; } test_field_fDContext () ; fn test_field_fProgramData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayList_ProgramIterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProgramData) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayList_ProgramIterator) , "::" , stringify ! (fProgramData))) ; } test_field_fProgramData () ; fn test_field_fIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayList_ProgramIterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIndex) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayList_ProgramIterator) , "::" , stringify ! (fIndex))) ; } test_field_fIndex () ; } extern "C" { # [link_name = "\u{1}?compile@ProgramIterator@SkDeferredDisplayList@@QEAA_NXZ"] pub fn SkDeferredDisplayList_ProgramIterator_compile (this : * mut SkDeferredDisplayList_ProgramIterator) -> bool ; } extern "C" { # [link_name = "\u{1}?done@ProgramIterator@SkDeferredDisplayList@@QEBA_NXZ"] pub fn SkDeferredDisplayList_ProgramIterator_done (this : * const SkDeferredDisplayList_ProgramIterator) -> bool ; } extern "C" { # [link_name = "\u{1}?next@ProgramIterator@SkDeferredDisplayList@@QEAAXXZ"] pub fn SkDeferredDisplayList_ProgramIterator_next (this : * mut SkDeferredDisplayList_ProgramIterator) ; } extern "C" { # [link_name = "\u{1}??0ProgramIterator@SkDeferredDisplayList@@QEAA@PEAVGrDirectContext@@PEAV1@@Z"] pub fn SkDeferredDisplayList_ProgramIterator_ProgramIterator (this : * mut SkDeferredDisplayList_ProgramIterator , arg1 : * mut GrDirectContext , arg2 : * mut SkDeferredDisplayList) ; } impl SkDeferredDisplayList_ProgramIterator { # [inline] pub unsafe fn compile (& mut self) -> bool { SkDeferredDisplayList_ProgramIterator_compile (self) } # [inline] pub unsafe fn done (& self) -> bool { SkDeferredDisplayList_ProgramIterator_done (self) } # [inline] pub unsafe fn next (& mut self) { SkDeferredDisplayList_ProgramIterator_next (self) } # [inline] pub unsafe fn new (arg1 : * mut GrDirectContext , arg2 : * mut SkDeferredDisplayList) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeferredDisplayList_ProgramIterator_ProgramIterator (__bindgen_tmp . as_mut_ptr () , arg1 , arg2) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDeferredDisplayList_LazyProxyData { pub _base : SkRefCnt , pub fReplayDest : * mut GrRenderTargetProxy , } # [test] fn bindgen_test_layout_SkDeferredDisplayList_LazyProxyData () { assert_eq ! (:: core :: mem :: size_of :: < SkDeferredDisplayList_LazyProxyData > () , 24usize , concat ! ("Size of: " , stringify ! (SkDeferredDisplayList_LazyProxyData))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeferredDisplayList_LazyProxyData > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeferredDisplayList_LazyProxyData))) ; fn test_field_fReplayDest () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayList_LazyProxyData > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReplayDest) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayList_LazyProxyData) , "::" , stringify ! (fReplayDest))) ; } test_field_fReplayDest () ; } # [test] fn bindgen_test_layout_SkDeferredDisplayList () { assert_eq ! (:: core :: mem :: size_of :: < SkDeferredDisplayList > () , 216usize , concat ! ("Size of: " , stringify ! (SkDeferredDisplayList))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeferredDisplayList > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeferredDisplayList))) ; } # [repr (C)] pub struct SkDeferredDisplayListRecorder { pub fCharacterization : SkSurfaceCharacterization , pub fContext : sk_sp < GrRecordingContext > , pub fTargetProxy : sk_sp < GrRenderTargetProxy > , pub fLazyProxyData : sk_sp < SkDeferredDisplayList_LazyProxyData > , pub fSurface : sk_sp < SkSurface > , } pub type SkDeferredDisplayListRecorder_PromiseImageTextureContext = SkImage_PromiseImageTextureContext ; pub type SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc = SkImage_PromiseImageTextureFulfillProc ; pub type SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc = SkImage_PromiseImageTextureReleaseProc ; # [test] fn bindgen_test_layout_SkDeferredDisplayListRecorder () { assert_eq ! (:: core :: mem :: size_of :: < SkDeferredDisplayListRecorder > () , 168usize , concat ! ("Size of: " , stringify ! (SkDeferredDisplayListRecorder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDeferredDisplayListRecorder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDeferredDisplayListRecorder))) ; fn test_field_fCharacterization () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayListRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCharacterization) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayListRecorder) , "::" , stringify ! (fCharacterization))) ; } test_field_fCharacterization () ; fn test_field_fContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayListRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fContext) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayListRecorder) , "::" , stringify ! (fContext))) ; } test_field_fContext () ; fn test_field_fTargetProxy () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayListRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTargetProxy) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayListRecorder) , "::" , stringify ! (fTargetProxy))) ; } test_field_fTargetProxy () ; fn test_field_fLazyProxyData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayListRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLazyProxyData) as usize - ptr as usize } , 152usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayListRecorder) , "::" , stringify ! (fLazyProxyData))) ; } test_field_fLazyProxyData () ; fn test_field_fSurface () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDeferredDisplayListRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSurface) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (SkDeferredDisplayListRecorder) , "::" , stringify ! (fSurface))) ; } test_field_fSurface () ; } extern "C" { # [link_name = "\u{1}?getCanvas@SkDeferredDisplayListRecorder@@QEAAPEAVSkCanvas@@XZ"] pub fn SkDeferredDisplayListRecorder_getCanvas (this : * mut SkDeferredDisplayListRecorder) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?detach@SkDeferredDisplayListRecorder@@QEAA?AV?$sk_sp@VSkDeferredDisplayList@@@@XZ"] pub fn SkDeferredDisplayListRecorder_detach (this : * mut SkDeferredDisplayListRecorder) -> sk_sp < SkDeferredDisplayList > ; } extern "C" { # [link_name = "\u{1}?makePromiseTexture@SkDeferredDisplayListRecorder@@QEAA?AV?$sk_sp@VSkImage@@@@AEBVGrBackendFormat@@HHW4GrMipmapped@@W4GrSurfaceOrigin@@W4SkColorType@@W4SkAlphaType@@V?$sk_sp@VSkColorSpace@@@@P6A?AV?$sk_sp@VSkPromiseImageTexture@@@@PEAX@ZP6AX6@Z6@Z"] pub fn SkDeferredDisplayListRecorder_makePromiseTexture (this : * mut SkDeferredDisplayListRecorder , backendFormat : * const GrBackendFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , mipmapped : GrMipmapped , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc , textureReleaseProc : SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc , textureContext : SkDeferredDisplayListRecorder_PromiseImageTextureContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeYUVAPromiseTexture@SkDeferredDisplayListRecorder@@QEAA?AV?$sk_sp@VSkImage@@@@AEBVGrYUVABackendTextureInfo@@V?$sk_sp@VSkColorSpace@@@@P6A?AV?$sk_sp@VSkPromiseImageTexture@@@@PEAX@ZP6AX2@ZQEAPEAX@Z"] pub fn SkDeferredDisplayListRecorder_makeYUVAPromiseTexture (this : * mut SkDeferredDisplayListRecorder , yuvaBackendTextureInfo : * const GrYUVABackendTextureInfo , imageColorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc , textureReleaseProc : SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc , textureContexts : * mut SkDeferredDisplayListRecorder_PromiseImageTextureContext) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}??0SkDeferredDisplayListRecorder@@QEAA@AEBVSkSurfaceCharacterization@@@Z"] pub fn SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder (this : * mut SkDeferredDisplayListRecorder , arg1 : * const SkSurfaceCharacterization) ; } impl SkDeferredDisplayListRecorder { # [inline] pub unsafe fn getCanvas (& mut self) -> * mut SkCanvas { SkDeferredDisplayListRecorder_getCanvas (self) } # [inline] pub unsafe fn detach (& mut self) -> sk_sp < SkDeferredDisplayList > { SkDeferredDisplayListRecorder_detach (self) } # [inline] pub unsafe fn makePromiseTexture (& mut self , backendFormat : * const GrBackendFormat , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , mipmapped : GrMipmapped , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc , textureReleaseProc : SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc , textureContext : SkDeferredDisplayListRecorder_PromiseImageTextureContext) -> sk_sp < SkImage > { SkDeferredDisplayListRecorder_makePromiseTexture (self , backendFormat , width , height , mipmapped , origin , colorType , alphaType , colorSpace , textureFulfillProc , textureReleaseProc , textureContext) } # [inline] pub unsafe fn makeYUVAPromiseTexture (& mut self , yuvaBackendTextureInfo : * const GrYUVABackendTextureInfo , imageColorSpace : sk_sp < SkColorSpace > , textureFulfillProc : SkDeferredDisplayListRecorder_PromiseImageTextureFulfillProc , textureReleaseProc : SkDeferredDisplayListRecorder_PromiseImageTextureReleaseProc , textureContexts : * mut SkDeferredDisplayListRecorder_PromiseImageTextureContext) -> sk_sp < SkImage > { SkDeferredDisplayListRecorder_makeYUVAPromiseTexture (self , yuvaBackendTextureInfo , imageColorSpace , textureFulfillProc , textureReleaseProc , textureContexts) } # [inline] pub unsafe fn new (arg1 : * const SkSurfaceCharacterization) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDeferredDisplayListRecorder_SkDeferredDisplayListRecorder (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDrawable { pub _bindgen_opaque_blob : [u64 ; 3usize] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDrawable_GpuDrawHandler { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkDrawable_GpuDrawHandler () { assert_eq ! (:: core :: mem :: size_of :: < SkDrawable_GpuDrawHandler > () , 8usize , concat ! ("Size of: " , stringify ! (SkDrawable_GpuDrawHandler))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDrawable_GpuDrawHandler > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDrawable_GpuDrawHandler))) ; } # [test] fn bindgen_test_layout_SkDrawable () { assert_eq ! (:: core :: mem :: size_of :: < SkDrawable > () , 24usize , concat ! ("Size of: " , stringify ! (SkDrawable))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDrawable > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDrawable))) ; } extern "C" { # [link_name = "\u{1}?draw@SkDrawable@@QEAAXPEAVSkCanvas@@PEBVSkMatrix@@@Z"] pub fn SkDrawable_draw (this : * mut SkDrawable , arg1 : * mut SkCanvas , arg2 : * const SkMatrix) ; } extern "C" { # [link_name = "\u{1}?draw@SkDrawable@@QEAAXPEAVSkCanvas@@MM@Z"] pub fn SkDrawable_draw1 (this : * mut SkDrawable , arg1 : * mut SkCanvas , x : SkScalar , y : SkScalar) ; } extern "C" { # [link_name = "\u{1}?newPictureSnapshot@SkDrawable@@QEAAPEAVSkPicture@@XZ"] pub fn SkDrawable_newPictureSnapshot (this : * mut SkDrawable) -> * mut SkPicture ; } extern "C" { # [link_name = "\u{1}?getGenerationID@SkDrawable@@QEAAIXZ"] pub fn SkDrawable_getGenerationID (this : * mut SkDrawable) -> u32 ; } extern "C" { # [link_name = "\u{1}?getBounds@SkDrawable@@QEAA?AUSkRect@@XZ"] pub fn SkDrawable_getBounds (this : * mut SkDrawable) -> SkRect ; } extern "C" { # [link_name = "\u{1}?approximateBytesUsed@SkDrawable@@QEAA_KXZ"] pub fn SkDrawable_approximateBytesUsed (this : * mut SkDrawable) -> usize ; } extern "C" { # [link_name = "\u{1}?notifyDrawingChanged@SkDrawable@@QEAAXXZ"] pub fn SkDrawable_notifyDrawingChanged (this : * mut SkDrawable) ; } extern "C" { # [link_name = "\u{1}??0SkDrawable@@IEAA@XZ"] pub fn SkDrawable_SkDrawable (this : * mut SkDrawable) ; } impl SkDrawable { # [inline] pub unsafe fn draw (& mut self , arg1 : * mut SkCanvas , arg2 : * const SkMatrix) { SkDrawable_draw (self , arg1 , arg2) } # [inline] pub unsafe fn draw1 (& mut self , arg1 : * mut SkCanvas , x : SkScalar , y : SkScalar) { SkDrawable_draw1 (self , arg1 , x , y) } # [inline] pub unsafe fn newPictureSnapshot (& mut self) -> * mut SkPicture { SkDrawable_newPictureSnapshot (self) } # [inline] pub unsafe fn getGenerationID (& mut self) -> u32 { SkDrawable_getGenerationID (self) } # [inline] pub unsafe fn getBounds (& mut self) -> SkRect { SkDrawable_getBounds (self) } # [inline] pub unsafe fn approximateBytesUsed (& mut self) -> usize { SkDrawable_approximateBytesUsed (self) } # [inline] pub unsafe fn notifyDrawingChanged (& mut self) { SkDrawable_notifyDrawingChanged (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDrawable_SkDrawable (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?onApproximateBytesUsed@SkDrawable@@MEAA_KXZ"] pub fn SkDrawable_onApproximateBytesUsed (this : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?onNewPictureSnapshot@SkDrawable@@MEAAPEAVSkPicture@@XZ"] pub fn SkDrawable_onNewPictureSnapshot (this : * mut :: core :: ffi :: c_void) -> * mut SkPicture ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkDocument { pub _bindgen_opaque_blob : [u64 ; 4usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkDocument_State { kBetweenPages_State = 0 , kInPage_State = 1 , kClosed_State = 2 , } pub type SkDocument_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkDocument () { assert_eq ! (:: core :: mem :: size_of :: < SkDocument > () , 32usize , concat ! ("Size of: " , stringify ! (SkDocument))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDocument > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDocument))) ; } extern "C" { # [link_name = "\u{1}?beginPage@SkDocument@@QEAAPEAVSkCanvas@@MMPEBUSkRect@@@Z"] pub fn SkDocument_beginPage (this : * mut SkDocument , width : SkScalar , height : SkScalar , content : * const SkRect) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?endPage@SkDocument@@QEAAXXZ"] pub fn SkDocument_endPage (this : * mut SkDocument) ; } extern "C" { # [link_name = "\u{1}?close@SkDocument@@QEAAXXZ"] pub fn SkDocument_close (this : * mut SkDocument) ; } extern "C" { # [link_name = "\u{1}?abort@SkDocument@@QEAAXXZ"] pub fn SkDocument_abort (this : * mut SkDocument) ; } extern "C" { # [link_name = "\u{1}??0SkDocument@@IEAA@PEAVSkWStream@@@Z"] pub fn SkDocument_SkDocument (this : * mut SkDocument , arg1 : * mut SkWStream) ; } impl SkDocument { # [inline] pub unsafe fn beginPage (& mut self , width : SkScalar , height : SkScalar , content : * const SkRect) -> * mut SkCanvas { SkDocument_beginPage (self , width , height , content) } # [inline] pub unsafe fn endPage (& mut self) { SkDocument_endPage (self) } # [inline] pub unsafe fn close (& mut self) { SkDocument_close (self) } # [inline] pub unsafe fn abort (& mut self) { SkDocument_abort (self) } # [inline] pub unsafe fn new (arg1 : * mut SkWStream) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDocument_SkDocument (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontArguments { pub fCollectionIndex : :: std :: os :: raw :: c_int , pub fVariationDesignPosition : SkFontArguments_VariationPosition , pub fPalette : SkFontArguments_Palette , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontArguments_VariationPosition { pub coordinates : * const SkFontArguments_VariationPosition_Coordinate , pub coordinateCount : :: std :: os :: raw :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontArguments_VariationPosition_Coordinate { pub axis : SkFourByteTag , pub value : f32 , } # [test] fn bindgen_test_layout_SkFontArguments_VariationPosition_Coordinate () { assert_eq ! (:: core :: mem :: size_of :: < SkFontArguments_VariationPosition_Coordinate > () , 8usize , concat ! ("Size of: " , stringify ! (SkFontArguments_VariationPosition_Coordinate))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontArguments_VariationPosition_Coordinate > () , 4usize , concat ! ("Alignment of " , stringify ! (SkFontArguments_VariationPosition_Coordinate))) ; fn test_field_axis () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition_Coordinate > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . axis) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_VariationPosition_Coordinate) , "::" , stringify ! (axis))) ; } test_field_axis () ; fn test_field_value () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition_Coordinate > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . value) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_VariationPosition_Coordinate) , "::" , stringify ! (value))) ; } test_field_value () ; } # [test] fn bindgen_test_layout_SkFontArguments_VariationPosition () { assert_eq ! (:: core :: mem :: size_of :: < SkFontArguments_VariationPosition > () , 16usize , concat ! ("Size of: " , stringify ! (SkFontArguments_VariationPosition))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontArguments_VariationPosition > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontArguments_VariationPosition))) ; fn test_field_coordinates () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . coordinates) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_VariationPosition) , "::" , stringify ! (coordinates))) ; } test_field_coordinates () ; fn test_field_coordinateCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_VariationPosition > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . coordinateCount) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_VariationPosition) , "::" , stringify ! (coordinateCount))) ; } test_field_coordinateCount () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontArguments_Palette { pub index : :: std :: os :: raw :: c_int , pub overrides : * const SkFontArguments_Palette_Override , pub overrideCount : :: std :: os :: raw :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontArguments_Palette_Override { pub index : :: std :: os :: raw :: c_int , pub color : SkColor , } # [test] fn bindgen_test_layout_SkFontArguments_Palette_Override () { assert_eq ! (:: core :: mem :: size_of :: < SkFontArguments_Palette_Override > () , 8usize , concat ! ("Size of: " , stringify ! (SkFontArguments_Palette_Override))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontArguments_Palette_Override > () , 4usize , concat ! ("Alignment of " , stringify ! (SkFontArguments_Palette_Override))) ; fn test_field_index () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_Palette_Override > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . index) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_Palette_Override) , "::" , stringify ! (index))) ; } test_field_index () ; fn test_field_color () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_Palette_Override > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . color) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_Palette_Override) , "::" , stringify ! (color))) ; } test_field_color () ; } # [test] fn bindgen_test_layout_SkFontArguments_Palette () { assert_eq ! (:: core :: mem :: size_of :: < SkFontArguments_Palette > () , 24usize , concat ! ("Size of: " , stringify ! (SkFontArguments_Palette))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontArguments_Palette > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontArguments_Palette))) ; fn test_field_index () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_Palette > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . index) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_Palette) , "::" , stringify ! (index))) ; } test_field_index () ; fn test_field_overrides () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_Palette > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . overrides) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_Palette) , "::" , stringify ! (overrides))) ; } test_field_overrides () ; fn test_field_overrideCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments_Palette > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . overrideCount) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments_Palette) , "::" , stringify ! (overrideCount))) ; } test_field_overrideCount () ; } # [test] fn bindgen_test_layout_SkFontArguments () { assert_eq ! (:: core :: mem :: size_of :: < SkFontArguments > () , 48usize , concat ! ("Size of: " , stringify ! (SkFontArguments))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontArguments > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontArguments))) ; fn test_field_fCollectionIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCollectionIndex) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments) , "::" , stringify ! (fCollectionIndex))) ; } test_field_fCollectionIndex () ; fn test_field_fVariationDesignPosition () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVariationDesignPosition) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments) , "::" , stringify ! (fVariationDesignPosition))) ; } test_field_fVariationDesignPosition () ; fn test_field_fPalette () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPalette) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkFontArguments) , "::" , stringify ! (fPalette))) ; } test_field_fPalette () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontParameters_Variation_Axis { pub tag : SkFourByteTag , pub min : f32 , pub def : f32 , pub max : f32 , pub flags : u16 , } pub const SkFontParameters_Variation_Axis_HIDDEN : u16 = 1 ; # [test] fn bindgen_test_layout_SkFontParameters_Variation_Axis () { assert_eq ! (:: core :: mem :: size_of :: < SkFontParameters_Variation_Axis > () , 20usize , concat ! ("Size of: " , stringify ! (SkFontParameters_Variation_Axis))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontParameters_Variation_Axis > () , 4usize , concat ! ("Alignment of " , stringify ! (SkFontParameters_Variation_Axis))) ; fn test_field_tag () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontParameters_Variation_Axis > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . tag) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontParameters_Variation_Axis) , "::" , stringify ! (tag))) ; } test_field_tag () ; fn test_field_min () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontParameters_Variation_Axis > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . min) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkFontParameters_Variation_Axis) , "::" , stringify ! (min))) ; } test_field_min () ; fn test_field_def () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontParameters_Variation_Axis > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . def) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontParameters_Variation_Axis) , "::" , stringify ! (def))) ; } test_field_def () ; fn test_field_max () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontParameters_Variation_Axis > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . max) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkFontParameters_Variation_Axis) , "::" , stringify ! (max))) ; } test_field_max () ; fn test_field_flags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontParameters_Variation_Axis > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkFontParameters_Variation_Axis) , "::" , stringify ! (flags))) ; } test_field_flags () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontStyle { pub fValue : i32 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFontStyle_Weight { kInvisible_Weight = 0 , kThin_Weight = 100 , kExtraLight_Weight = 200 , kLight_Weight = 300 , kNormal_Weight = 400 , kMedium_Weight = 500 , kSemiBold_Weight = 600 , kBold_Weight = 700 , kExtraBold_Weight = 800 , kBlack_Weight = 900 , kExtraBlack_Weight = 1000 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFontStyle_Width { kUltraCondensed_Width = 1 , kExtraCondensed_Width = 2 , kCondensed_Width = 3 , kSemiCondensed_Width = 4 , kNormal_Width = 5 , kSemiExpanded_Width = 6 , kExpanded_Width = 7 , kExtraExpanded_Width = 8 , kUltraExpanded_Width = 9 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFontStyle_Slant { Upright = 0 , Italic = 1 , Oblique = 2 , } # [test] fn bindgen_test_layout_SkFontStyle () { assert_eq ! (:: core :: mem :: size_of :: < SkFontStyle > () , 4usize , concat ! ("Size of: " , stringify ! (SkFontStyle))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontStyle > () , 4usize , concat ! ("Alignment of " , stringify ! (SkFontStyle))) ; fn test_field_fValue () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fValue) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontStyle) , "::" , stringify ! (fValue))) ; } test_field_fValue () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkWeakRefCnt { pub _bindgen_opaque_blob : [u64 ; 3usize] , } pub type SkWeakRefCnt_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkWeakRefCnt () { assert_eq ! (:: core :: mem :: size_of :: < SkWeakRefCnt > () , 24usize , concat ! ("Size of: " , stringify ! (SkWeakRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkWeakRefCnt > () , 8usize , concat ! ("Alignment of " , stringify ! (SkWeakRefCnt))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDescriptor { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkScalerContext { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkAdvancedTypefaceMetrics { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkScalerContextEffects { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkScalerContextRec { _unused : [u8 ; 0] , } pub type SkTypefaceID = u32 ; pub type SkFontTableTag = u32 ; # [repr (C)] # [derive (Debug)] pub struct SkTypeface { pub _base : SkWeakRefCnt , pub fUniqueID : SkTypefaceID , pub fStyle : SkFontStyle , pub fBounds : SkRect , pub fBoundsOnce : SkOnce , pub fIsFixedPitch : bool , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTypeface_SerializeBehavior { DoIncludeData = 0 , DontIncludeData = 1 , IncludeDataIfLocal = 2 , } # [repr (C)] # [derive (Debug)] pub struct SkTypeface_LocalizedString { pub fString : SkString , pub fLanguage : SkString , } # [test] fn bindgen_test_layout_SkTypeface_LocalizedString () { assert_eq ! (:: core :: mem :: size_of :: < SkTypeface_LocalizedString > () , 16usize , concat ! ("Size of: " , stringify ! (SkTypeface_LocalizedString))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTypeface_LocalizedString > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTypeface_LocalizedString))) ; fn test_field_fString () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface_LocalizedString > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fString) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTypeface_LocalizedString) , "::" , stringify ! (fString))) ; } test_field_fString () ; fn test_field_fLanguage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface_LocalizedString > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLanguage) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTypeface_LocalizedString) , "::" , stringify ! (fLanguage))) ; } test_field_fLanguage () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkTypeface_LocalizedStrings { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkTypeface_LocalizedStrings () { assert_eq ! (:: core :: mem :: size_of :: < SkTypeface_LocalizedStrings > () , 8usize , concat ! ("Size of: " , stringify ! (SkTypeface_LocalizedStrings))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTypeface_LocalizedStrings > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTypeface_LocalizedStrings))) ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTypeface_Style { Normal = 0 , Bold = 1 , Italic = 2 , BoldItalic = 3 , } pub type SkTypeface_INHERITED = SkWeakRefCnt ; # [test] fn bindgen_test_layout_SkTypeface () { assert_eq ! (:: core :: mem :: size_of :: < SkTypeface > () , 56usize , concat ! ("Size of: " , stringify ! (SkTypeface))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTypeface > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTypeface))) ; fn test_field_fUniqueID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUniqueID) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkTypeface) , "::" , stringify ! (fUniqueID))) ; } test_field_fUniqueID () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkTypeface) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkTypeface) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fBoundsOnce () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBoundsOnce) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkTypeface) , "::" , stringify ! (fBoundsOnce))) ; } test_field_fBoundsOnce () ; fn test_field_fIsFixedPitch () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTypeface > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsFixedPitch) as usize - ptr as usize } , 49usize , concat ! ("Offset of field: " , stringify ! (SkTypeface) , "::" , stringify ! (fIsFixedPitch))) ; } test_field_fIsFixedPitch () ; } extern "C" { # [link_name = "\u{1}?getVariationDesignPosition@SkTypeface@@QEBAHQEAUCoordinate@VariationPosition@SkFontArguments@@H@Z"] pub fn SkTypeface_getVariationDesignPosition (this : * const SkTypeface , coordinates : * mut SkFontArguments_VariationPosition_Coordinate , coordinateCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getVariationDesignParameters@SkTypeface@@QEBAHQEAUAxis@Variation@SkFontParameters@@H@Z"] pub fn SkTypeface_getVariationDesignParameters (this : * const SkTypeface , parameters : * mut SkFontParameters_Variation_Axis , parameterCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?UniqueID@SkTypeface@@SAIPEBV1@@Z"] pub fn SkTypeface_UniqueID (face : * const SkTypeface) -> SkTypefaceID ; } extern "C" { # [link_name = "\u{1}?Equal@SkTypeface@@SA_NPEBV1@0@Z"] pub fn SkTypeface_Equal (facea : * const SkTypeface , faceb : * const SkTypeface) -> bool ; } extern "C" { # [link_name = "\u{1}?MakeDefault@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@XZ"] pub fn SkTypeface_MakeDefault () -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?MakeFromName@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDVSkFontStyle@@@Z"] pub fn SkTypeface_MakeFromName (familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?MakeFromFile@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@QEBDH@Z"] pub fn SkTypeface_MakeFromFile (path : * const :: std :: os :: raw :: c_char , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?MakeFromStream@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@H@Z"] pub fn SkTypeface_MakeFromStream (stream : u64 , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?MakeFromData@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@V?$sk_sp@VSkData@@@@H@Z"] pub fn SkTypeface_MakeFromData (arg1 : sk_sp < SkData > , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?makeClone@SkTypeface@@QEBA?AV?$sk_sp@VSkTypeface@@@@AEBUSkFontArguments@@@Z"] pub fn SkTypeface_makeClone (this : * const SkTypeface , arg1 : * const SkFontArguments) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?serialize@SkTypeface@@QEBAXPEAVSkWStream@@W4SerializeBehavior@1@@Z"] pub fn SkTypeface_serialize (this : * const SkTypeface , arg1 : * mut SkWStream , arg2 : SkTypeface_SerializeBehavior) ; } extern "C" { # [link_name = "\u{1}?serialize@SkTypeface@@QEBA?AV?$sk_sp@VSkData@@@@W4SerializeBehavior@1@@Z"] pub fn SkTypeface_serialize1 (this : * const SkTypeface , arg1 : SkTypeface_SerializeBehavior) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?MakeDeserialize@SkTypeface@@SA?AV?$sk_sp@VSkTypeface@@@@PEAVSkStream@@@Z"] pub fn SkTypeface_MakeDeserialize (arg1 : * mut SkStream) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?unicharsToGlyphs@SkTypeface@@QEBAXQEBHHQEAG@Z"] pub fn SkTypeface_unicharsToGlyphs (this : * const SkTypeface , uni : * const SkUnichar , count : :: std :: os :: raw :: c_int , glyphs : * mut SkGlyphID) ; } extern "C" { # [link_name = "\u{1}?textToGlyphs@SkTypeface@@QEBAHPEBX_KW4SkTextEncoding@@QEAGH@Z"] pub fn SkTypeface_textToGlyphs (this : * const SkTypeface , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?unicharToGlyph@SkTypeface@@QEBAGH@Z"] pub fn SkTypeface_unicharToGlyph (this : * const SkTypeface , unichar : SkUnichar) -> SkGlyphID ; } extern "C" { # [link_name = "\u{1}?countGlyphs@SkTypeface@@QEBAHXZ"] pub fn SkTypeface_countGlyphs (this : * const SkTypeface) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?countTables@SkTypeface@@QEBAHXZ"] pub fn SkTypeface_countTables (this : * const SkTypeface) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getTableTags@SkTypeface@@QEBAHQEAI@Z"] pub fn SkTypeface_getTableTags (this : * const SkTypeface , tags : * mut SkFontTableTag) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getTableSize@SkTypeface@@QEBA_KI@Z"] pub fn SkTypeface_getTableSize (this : * const SkTypeface , arg1 : SkFontTableTag) -> usize ; } extern "C" { # [link_name = "\u{1}?getTableData@SkTypeface@@QEBA_KI_K0PEAX@Z"] pub fn SkTypeface_getTableData (this : * const SkTypeface , tag : SkFontTableTag , offset : usize , length : usize , data : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?copyTableData@SkTypeface@@QEBA?AV?$sk_sp@VSkData@@@@I@Z"] pub fn SkTypeface_copyTableData (this : * const SkTypeface , tag : SkFontTableTag) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?getUnitsPerEm@SkTypeface@@QEBAHXZ"] pub fn SkTypeface_getUnitsPerEm (this : * const SkTypeface) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getKerningPairAdjustments@SkTypeface@@QEBA_NQEBGHQEAH@Z"] pub fn SkTypeface_getKerningPairAdjustments (this : * const SkTypeface , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32) -> bool ; } extern "C" { # [link_name = "\u{1}?createFamilyNameIterator@SkTypeface@@QEBAPEAVLocalizedStrings@1@XZ"] pub fn SkTypeface_createFamilyNameIterator (this : * const SkTypeface) -> * mut SkTypeface_LocalizedStrings ; } extern "C" { # [link_name = "\u{1}?getFamilyName@SkTypeface@@QEBAXPEAVSkString@@@Z"] pub fn SkTypeface_getFamilyName (this : * const SkTypeface , name : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?getPostScriptName@SkTypeface@@QEBA_NPEAVSkString@@@Z"] pub fn SkTypeface_getPostScriptName (this : * const SkTypeface , name : * mut SkString) -> bool ; } extern "C" { # [link_name = "\u{1}?openStream@SkTypeface@@QEBA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@PEAH@Z"] pub fn SkTypeface_openStream (this : * const SkTypeface , ttcIndex : * mut :: std :: os :: raw :: c_int) -> u64 ; } extern "C" { # [link_name = "\u{1}?openExistingStream@SkTypeface@@QEBA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@PEAH@Z"] pub fn SkTypeface_openExistingStream (this : * const SkTypeface , ttcIndex : * mut :: std :: os :: raw :: c_int) -> u64 ; } extern "C" { # [link_name = "\u{1}?createScalerContext@SkTypeface@@QEBA?AV?$unique_ptr@VSkScalerContext@@U?$default_delete@VSkScalerContext@@@std@@@std@@AEBUSkScalerContextEffects@@PEBVSkDescriptor@@@Z"] pub fn SkTypeface_createScalerContext (this : * const SkTypeface , arg1 : * const SkScalerContextEffects , arg2 : * const SkDescriptor) -> u8 ; } extern "C" { # [link_name = "\u{1}?getBounds@SkTypeface@@QEBA?AUSkRect@@XZ"] pub fn SkTypeface_getBounds (this : * const SkTypeface) -> SkRect ; } extern "C" { # [link_name = "\u{1}??0SkTypeface@@IEAA@AEBVSkFontStyle@@_N@Z"] pub fn SkTypeface_SkTypeface (this : * mut SkTypeface , style : * const SkFontStyle , isFixedPitch : bool) ; } impl SkTypeface { # [inline] pub unsafe fn getVariationDesignPosition (& self , coordinates : * mut SkFontArguments_VariationPosition_Coordinate , coordinateCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkTypeface_getVariationDesignPosition (self , coordinates , coordinateCount) } # [inline] pub unsafe fn getVariationDesignParameters (& self , parameters : * mut SkFontParameters_Variation_Axis , parameterCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkTypeface_getVariationDesignParameters (self , parameters , parameterCount) } # [inline] pub unsafe fn UniqueID (face : * const SkTypeface) -> SkTypefaceID { SkTypeface_UniqueID (face) } # [inline] pub unsafe fn Equal (facea : * const SkTypeface , faceb : * const SkTypeface) -> bool { SkTypeface_Equal (facea , faceb) } # [inline] pub unsafe fn MakeDefault () -> sk_sp < SkTypeface > { SkTypeface_MakeDefault () } # [inline] pub unsafe fn MakeFromName (familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle) -> sk_sp < SkTypeface > { SkTypeface_MakeFromName (familyName , fontStyle) } # [inline] pub unsafe fn MakeFromFile (path : * const :: std :: os :: raw :: c_char , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkTypeface_MakeFromFile (path , index) } # [inline] pub unsafe fn MakeFromStream (stream : u64 , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkTypeface_MakeFromStream (stream , index) } # [inline] pub unsafe fn MakeFromData (arg1 : sk_sp < SkData > , index : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkTypeface_MakeFromData (arg1 , index) } # [inline] pub unsafe fn makeClone (& self , arg1 : * const SkFontArguments) -> sk_sp < SkTypeface > { SkTypeface_makeClone (self , arg1) } # [inline] pub unsafe fn serialize (& self , arg1 : * mut SkWStream , arg2 : SkTypeface_SerializeBehavior) { SkTypeface_serialize (self , arg1 , arg2) } # [inline] pub unsafe fn serialize1 (& self , arg1 : SkTypeface_SerializeBehavior) -> sk_sp < SkData > { SkTypeface_serialize1 (self , arg1) } # [inline] pub unsafe fn MakeDeserialize (arg1 : * mut SkStream) -> sk_sp < SkTypeface > { SkTypeface_MakeDeserialize (arg1) } # [inline] pub unsafe fn unicharsToGlyphs (& self , uni : * const SkUnichar , count : :: std :: os :: raw :: c_int , glyphs : * mut SkGlyphID) { SkTypeface_unicharsToGlyphs (self , uni , count , glyphs) } # [inline] pub unsafe fn textToGlyphs (& self , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkTypeface_textToGlyphs (self , text , byteLength , encoding , glyphs , maxGlyphCount) } # [inline] pub unsafe fn unicharToGlyph (& self , unichar : SkUnichar) -> SkGlyphID { SkTypeface_unicharToGlyph (self , unichar) } # [inline] pub unsafe fn countGlyphs (& self) -> :: std :: os :: raw :: c_int { SkTypeface_countGlyphs (self) } # [inline] pub unsafe fn countTables (& self) -> :: std :: os :: raw :: c_int { SkTypeface_countTables (self) } # [inline] pub unsafe fn getTableTags (& self , tags : * mut SkFontTableTag) -> :: std :: os :: raw :: c_int { SkTypeface_getTableTags (self , tags) } # [inline] pub unsafe fn getTableSize (& self , arg1 : SkFontTableTag) -> usize { SkTypeface_getTableSize (self , arg1) } # [inline] pub unsafe fn getTableData (& self , tag : SkFontTableTag , offset : usize , length : usize , data : * mut :: core :: ffi :: c_void) -> usize { SkTypeface_getTableData (self , tag , offset , length , data) } # [inline] pub unsafe fn copyTableData (& self , tag : SkFontTableTag) -> sk_sp < SkData > { SkTypeface_copyTableData (self , tag) } # [inline] pub unsafe fn getUnitsPerEm (& self) -> :: std :: os :: raw :: c_int { SkTypeface_getUnitsPerEm (self) } # [inline] pub unsafe fn getKerningPairAdjustments (& self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32) -> bool { SkTypeface_getKerningPairAdjustments (self , glyphs , count , adjustments) } # [inline] pub unsafe fn createFamilyNameIterator (& self) -> * mut SkTypeface_LocalizedStrings { SkTypeface_createFamilyNameIterator (self) } # [inline] pub unsafe fn getFamilyName (& self , name : * mut SkString) { SkTypeface_getFamilyName (self , name) } # [inline] pub unsafe fn getPostScriptName (& self , name : * mut SkString) -> bool { SkTypeface_getPostScriptName (self , name) } # [inline] pub unsafe fn openStream (& self , ttcIndex : * mut :: std :: os :: raw :: c_int) -> u64 { SkTypeface_openStream (self , ttcIndex) } # [inline] pub unsafe fn openExistingStream (& self , ttcIndex : * mut :: std :: os :: raw :: c_int) -> u64 { SkTypeface_openExistingStream (self , ttcIndex) } # [inline] pub unsafe fn createScalerContext (& self , arg1 : * const SkScalerContextEffects , arg2 : * const SkDescriptor) -> u8 { SkTypeface_createScalerContext (self , arg1 , arg2) } # [inline] pub unsafe fn getBounds (& self) -> SkRect { SkTypeface_getBounds (self) } # [inline] pub unsafe fn new (style : * const SkFontStyle , isFixedPitch : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkTypeface_SkTypeface (__bindgen_tmp . as_mut_ptr () , style , isFixedPitch) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?onOpenExistingStream@SkTypeface@@MEBA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@PEAH@Z"] pub fn SkTypeface_onOpenExistingStream (this : * mut :: core :: ffi :: c_void , ttcIndex : * mut :: std :: os :: raw :: c_int) -> u64 ; } extern "C" { # [link_name = "\u{1}?onGetKerningPairAdjustments@SkTypeface@@MEBA_NQEBGHQEAH@Z"] pub fn SkTypeface_onGetKerningPairAdjustments (this : * mut :: core :: ffi :: c_void , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , adjustments : * mut i32) -> bool ; } extern "C" { # [link_name = "\u{1}?onCopyTableData@SkTypeface@@MEBA?AV?$sk_sp@VSkData@@@@I@Z"] pub fn SkTypeface_onCopyTableData (this : * mut :: core :: ffi :: c_void , arg1 : SkFontTableTag) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?onComputeBounds@SkTypeface@@MEBA_NPEAUSkRect@@@Z"] pub fn SkTypeface_onComputeBounds (this : * mut :: core :: ffi :: c_void , arg1 : * mut SkRect) -> bool ; } # [repr (C)] # [derive (Debug)] pub struct SkFont { pub fTypeface : sk_sp < SkTypeface > , pub fSize : SkScalar , pub fScaleX : SkScalar , pub fSkewX : SkScalar , pub fFlags : u8 , pub fEdging : u8 , pub fHinting : u8 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkFont_Edging { Alias = 0 , AntiAlias = 1 , SubpixelAntiAlias = 2 , } pub const SkFont_PrivFlags_kForceAutoHinting_PrivFlag : SkFont_PrivFlags = 1 ; pub const SkFont_PrivFlags_kEmbeddedBitmaps_PrivFlag : SkFont_PrivFlags = 2 ; pub const SkFont_PrivFlags_kSubpixel_PrivFlag : SkFont_PrivFlags = 4 ; pub const SkFont_PrivFlags_kLinearMetrics_PrivFlag : SkFont_PrivFlags = 8 ; pub const SkFont_PrivFlags_kEmbolden_PrivFlag : SkFont_PrivFlags = 16 ; pub const SkFont_PrivFlags_kBaselineSnap_PrivFlag : SkFont_PrivFlags = 32 ; pub type SkFont_PrivFlags = :: std :: os :: raw :: c_int ; pub const SkFont_kAllFlags : :: std :: os :: raw :: c_uint = 63 ; # [test] fn bindgen_test_layout_SkFont () { assert_eq ! (:: core :: mem :: size_of :: < SkFont > () , 24usize , concat ! ("Size of: " , stringify ! (SkFont))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFont > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFont))) ; fn test_field_fTypeface () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTypeface) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fTypeface))) ; } test_field_fTypeface () ; fn test_field_fSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSize) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fSize))) ; } test_field_fSize () ; fn test_field_fScaleX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fScaleX) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fScaleX))) ; } test_field_fScaleX () ; fn test_field_fSkewX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSkewX) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fSkewX))) ; } test_field_fSkewX () ; fn test_field_fFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFlags) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fFlags))) ; } test_field_fFlags () ; fn test_field_fEdging () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEdging) as usize - ptr as usize } , 21usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fEdging))) ; } test_field_fEdging () ; fn test_field_fHinting () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFont > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHinting) as usize - ptr as usize } , 22usize , concat ! ("Offset of field: " , stringify ! (SkFont) , "::" , stringify ! (fHinting))) ; } test_field_fHinting () ; } extern "C" { # [link_name = "\u{1}?setForceAutoHinting@SkFont@@QEAAX_N@Z"] pub fn SkFont_setForceAutoHinting (this : * mut SkFont , forceAutoHinting : bool) ; } extern "C" { # [link_name = "\u{1}?setEmbeddedBitmaps@SkFont@@QEAAX_N@Z"] pub fn SkFont_setEmbeddedBitmaps (this : * mut SkFont , embeddedBitmaps : bool) ; } extern "C" { # [link_name = "\u{1}?setSubpixel@SkFont@@QEAAX_N@Z"] pub fn SkFont_setSubpixel (this : * mut SkFont , subpixel : bool) ; } extern "C" { # [link_name = "\u{1}?setLinearMetrics@SkFont@@QEAAX_N@Z"] pub fn SkFont_setLinearMetrics (this : * mut SkFont , linearMetrics : bool) ; } extern "C" { # [link_name = "\u{1}?setEmbolden@SkFont@@QEAAX_N@Z"] pub fn SkFont_setEmbolden (this : * mut SkFont , embolden : bool) ; } extern "C" { # [link_name = "\u{1}?setBaselineSnap@SkFont@@QEAAX_N@Z"] pub fn SkFont_setBaselineSnap (this : * mut SkFont , baselineSnap : bool) ; } extern "C" { # [link_name = "\u{1}?setEdging@SkFont@@QEAAXW4Edging@1@@Z"] pub fn SkFont_setEdging (this : * mut SkFont , edging : SkFont_Edging) ; } extern "C" { # [link_name = "\u{1}?setHinting@SkFont@@QEAAXW4SkFontHinting@@@Z"] pub fn SkFont_setHinting (this : * mut SkFont , hintingLevel : SkFontHinting) ; } extern "C" { # [link_name = "\u{1}?makeWithSize@SkFont@@QEBA?AV1@M@Z"] pub fn SkFont_makeWithSize (this : * const SkFont , size : SkScalar) -> SkFont ; } extern "C" { # [link_name = "\u{1}?getTypefaceOrDefault@SkFont@@QEBAPEAVSkTypeface@@XZ"] pub fn SkFont_getTypefaceOrDefault (this : * const SkFont) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?refTypefaceOrDefault@SkFont@@QEBA?AV?$sk_sp@VSkTypeface@@@@XZ"] pub fn SkFont_refTypefaceOrDefault (this : * const SkFont) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?setSize@SkFont@@QEAAXM@Z"] pub fn SkFont_setSize (this : * mut SkFont , textSize : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setScaleX@SkFont@@QEAAXM@Z"] pub fn SkFont_setScaleX (this : * mut SkFont , scaleX : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setSkewX@SkFont@@QEAAXM@Z"] pub fn SkFont_setSkewX (this : * mut SkFont , skewX : SkScalar) ; } extern "C" { # [link_name = "\u{1}?textToGlyphs@SkFont@@QEBAHPEBX_KW4SkTextEncoding@@QEAGH@Z"] pub fn SkFont_textToGlyphs (this : * const SkFont , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?unicharToGlyph@SkFont@@QEBAGH@Z"] pub fn SkFont_unicharToGlyph (this : * const SkFont , uni : SkUnichar) -> SkGlyphID ; } extern "C" { # [link_name = "\u{1}?unicharsToGlyphs@SkFont@@QEBAXQEBHHQEAG@Z"] pub fn SkFont_unicharsToGlyphs (this : * const SkFont , uni : * const SkUnichar , count : :: std :: os :: raw :: c_int , glyphs : * mut SkGlyphID) ; } extern "C" { # [link_name = "\u{1}?measureText@SkFont@@QEBAMPEBX_KW4SkTextEncoding@@PEAUSkRect@@PEBVSkPaint@@@Z"] pub fn SkFont_measureText (this : * const SkFont , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect , paint : * const SkPaint) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?getWidthsBounds@SkFont@@QEBAXQEBGHQEAMQEAUSkRect@@PEBVSkPaint@@@Z"] pub fn SkFont_getWidthsBounds (this : * const SkFont , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?getPos@SkFont@@QEBAXQEBGHQEAUSkPoint@@U2@@Z"] pub fn SkFont_getPos (this : * const SkFont , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , pos : * mut SkPoint , origin : SkPoint) ; } extern "C" { # [link_name = "\u{1}?getXPos@SkFont@@QEBAXQEBGHQEAMM@Z"] pub fn SkFont_getXPos (this : * const SkFont , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , xpos : * mut SkScalar , origin : SkScalar) ; } extern "C" { # [link_name = "\u{1}?getIntercepts@SkFont@@QEBA?AV?$vector@MV?$allocator@M@std@@@std@@QEBGHQEBUSkPoint@@MMPEBVSkPaint@@@Z"] pub fn SkFont_getIntercepts (this : * const SkFont , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , pos : * const SkPoint , top : SkScalar , bottom : SkScalar , arg1 : * const SkPaint) -> [u64 ; 3usize] ; } extern "C" { # [link_name = "\u{1}?getPath@SkFont@@QEBA_NGPEAVSkPath@@@Z"] pub fn SkFont_getPath (this : * const SkFont , glyphID : SkGlyphID , path : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?getPaths@SkFont@@QEBAXQEBGHP6AXPEBVSkPath@@AEBVSkMatrix@@PEAX@Z3@Z"] pub fn SkFont_getPaths (this : * const SkFont , glyphIDs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , glyphPathProc : :: core :: option :: Option < unsafe extern "C" fn (pathOrNull : * const SkPath , mx : * const SkMatrix , ctx : * mut :: core :: ffi :: c_void) > , ctx : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?getMetrics@SkFont@@QEBAMPEAUSkFontMetrics@@@Z"] pub fn SkFont_getMetrics (this : * const SkFont , metrics : * mut SkFontMetrics) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?dump@SkFont@@QEBAXXZ"] pub fn SkFont_dump (this : * const SkFont) ; } extern "C" { # [link_name = "\u{1}??0SkFont@@QEAA@XZ"] pub fn SkFont_SkFont (this : * mut SkFont) ; } extern "C" { # [link_name = "\u{1}??0SkFont@@QEAA@V?$sk_sp@VSkTypeface@@@@M@Z"] pub fn SkFont_SkFont1 (this : * mut SkFont , typeface : sk_sp < SkTypeface > , size : SkScalar) ; } extern "C" { # [link_name = "\u{1}??0SkFont@@QEAA@V?$sk_sp@VSkTypeface@@@@@Z"] pub fn SkFont_SkFont2 (this : * mut SkFont , typeface : sk_sp < SkTypeface >) ; } extern "C" { # [link_name = "\u{1}??0SkFont@@QEAA@V?$sk_sp@VSkTypeface@@@@MMM@Z"] pub fn SkFont_SkFont3 (this : * mut SkFont , typeface : sk_sp < SkTypeface > , size : SkScalar , scaleX : SkScalar , skewX : SkScalar) ; } impl SkFont { # [inline] pub unsafe fn setForceAutoHinting (& mut self , forceAutoHinting : bool) { SkFont_setForceAutoHinting (self , forceAutoHinting) } # [inline] pub unsafe fn setEmbeddedBitmaps (& mut self , embeddedBitmaps : bool) { SkFont_setEmbeddedBitmaps (self , embeddedBitmaps) } # [inline] pub unsafe fn setSubpixel (& mut self , subpixel : bool) { SkFont_setSubpixel (self , subpixel) } # [inline] pub unsafe fn setLinearMetrics (& mut self , linearMetrics : bool) { SkFont_setLinearMetrics (self , linearMetrics) } # [inline] pub unsafe fn setEmbolden (& mut self , embolden : bool) { SkFont_setEmbolden (self , embolden) } # [inline] pub unsafe fn setBaselineSnap (& mut self , baselineSnap : bool) { SkFont_setBaselineSnap (self , baselineSnap) } # [inline] pub unsafe fn setEdging (& mut self , edging : SkFont_Edging) { SkFont_setEdging (self , edging) } # [inline] pub unsafe fn setHinting (& mut self , hintingLevel : SkFontHinting) { SkFont_setHinting (self , hintingLevel) } # [inline] pub unsafe fn makeWithSize (& self , size : SkScalar) -> SkFont { SkFont_makeWithSize (self , size) } # [inline] pub unsafe fn getTypefaceOrDefault (& self) -> * mut SkTypeface { SkFont_getTypefaceOrDefault (self) } # [inline] pub unsafe fn refTypefaceOrDefault (& self) -> sk_sp < SkTypeface > { SkFont_refTypefaceOrDefault (self) } # [inline] pub unsafe fn setSize (& mut self , textSize : SkScalar) { SkFont_setSize (self , textSize) } # [inline] pub unsafe fn setScaleX (& mut self , scaleX : SkScalar) { SkFont_setScaleX (self , scaleX) } # [inline] pub unsafe fn setSkewX (& mut self , skewX : SkScalar) { SkFont_setSkewX (self , skewX) } # [inline] pub unsafe fn textToGlyphs (& self , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , glyphs : * mut SkGlyphID , maxGlyphCount : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkFont_textToGlyphs (self , text , byteLength , encoding , glyphs , maxGlyphCount) } # [inline] pub unsafe fn unicharToGlyph (& self , uni : SkUnichar) -> SkGlyphID { SkFont_unicharToGlyph (self , uni) } # [inline] pub unsafe fn unicharsToGlyphs (& self , uni : * const SkUnichar , count : :: std :: os :: raw :: c_int , glyphs : * mut SkGlyphID) { SkFont_unicharsToGlyphs (self , uni , count , glyphs) } # [inline] pub unsafe fn measureText (& self , text : * const :: core :: ffi :: c_void , byteLength : usize , encoding : SkTextEncoding , bounds : * mut SkRect , paint : * const SkPaint) -> SkScalar { SkFont_measureText (self , text , byteLength , encoding , bounds , paint) } # [inline] pub unsafe fn getWidthsBounds (& self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , widths : * mut SkScalar , bounds : * mut SkRect , paint : * const SkPaint) { SkFont_getWidthsBounds (self , glyphs , count , widths , bounds , paint) } # [inline] pub unsafe fn getPos (& self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , pos : * mut SkPoint , origin : SkPoint) { SkFont_getPos (self , glyphs , count , pos , origin) } # [inline] pub unsafe fn getXPos (& self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , xpos : * mut SkScalar , origin : SkScalar) { SkFont_getXPos (self , glyphs , count , xpos , origin) } # [inline] pub unsafe fn getIntercepts (& self , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , pos : * const SkPoint , top : SkScalar , bottom : SkScalar , arg1 : * const SkPaint) -> [u64 ; 3usize] { SkFont_getIntercepts (self , glyphs , count , pos , top , bottom , arg1) } # [inline] pub unsafe fn getPath (& self , glyphID : SkGlyphID , path : * mut SkPath) -> bool { SkFont_getPath (self , glyphID , path) } # [inline] pub unsafe fn getPaths (& self , glyphIDs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , glyphPathProc : :: core :: option :: Option < unsafe extern "C" fn (pathOrNull : * const SkPath , mx : * const SkMatrix , ctx : * mut :: core :: ffi :: c_void) > , ctx : * mut :: core :: ffi :: c_void) { SkFont_getPaths (self , glyphIDs , count , glyphPathProc , ctx) } # [inline] pub unsafe fn getMetrics (& self , metrics : * mut SkFontMetrics) -> SkScalar { SkFont_getMetrics (self , metrics) } # [inline] pub unsafe fn dump (& self) { SkFont_dump (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkFont_SkFont (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (typeface : sk_sp < SkTypeface > , size : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkFont_SkFont1 (__bindgen_tmp . as_mut_ptr () , typeface , size) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (typeface : sk_sp < SkTypeface >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkFont_SkFont2 (__bindgen_tmp . as_mut_ptr () , typeface) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (typeface : sk_sp < SkTypeface > , size : SkScalar , scaleX : SkScalar , skewX : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkFont_SkFont3 (__bindgen_tmp . as_mut_ptr () , typeface , size , scaleX , skewX) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkFontMetrics { pub fFlags : u32 , pub fTop : SkScalar , pub fAscent : SkScalar , pub fDescent : SkScalar , pub fBottom : SkScalar , pub fLeading : SkScalar , pub fAvgCharWidth : SkScalar , pub fMaxCharWidth : SkScalar , pub fXMin : SkScalar , pub fXMax : SkScalar , pub fXHeight : SkScalar , pub fCapHeight : SkScalar , pub fUnderlineThickness : SkScalar , pub fUnderlinePosition : SkScalar , pub fStrikeoutThickness : SkScalar , pub fStrikeoutPosition : SkScalar , } pub const SkFontMetrics_FontMetricsFlags_kUnderlineThicknessIsValid_Flag : SkFontMetrics_FontMetricsFlags = 1 ; pub const SkFontMetrics_FontMetricsFlags_kUnderlinePositionIsValid_Flag : SkFontMetrics_FontMetricsFlags = 2 ; pub const SkFontMetrics_FontMetricsFlags_kStrikeoutThicknessIsValid_Flag : SkFontMetrics_FontMetricsFlags = 4 ; pub const SkFontMetrics_FontMetricsFlags_kStrikeoutPositionIsValid_Flag : SkFontMetrics_FontMetricsFlags = 8 ; pub const SkFontMetrics_FontMetricsFlags_kBoundsInvalid_Flag : SkFontMetrics_FontMetricsFlags = 16 ; pub type SkFontMetrics_FontMetricsFlags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkFontMetrics () { assert_eq ! (:: core :: mem :: size_of :: < SkFontMetrics > () , 64usize , concat ! ("Size of: " , stringify ! (SkFontMetrics))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontMetrics > () , 4usize , concat ! ("Alignment of " , stringify ! (SkFontMetrics))) ; fn test_field_fFlags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFlags) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fFlags))) ; } test_field_fFlags () ; fn test_field_fTop () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTop) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fTop))) ; } test_field_fTop () ; fn test_field_fAscent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAscent) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fAscent))) ; } test_field_fAscent () ; fn test_field_fDescent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDescent) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fDescent))) ; } test_field_fDescent () ; fn test_field_fBottom () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBottom) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fBottom))) ; } test_field_fBottom () ; fn test_field_fLeading () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeading) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fLeading))) ; } test_field_fLeading () ; fn test_field_fAvgCharWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAvgCharWidth) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fAvgCharWidth))) ; } test_field_fAvgCharWidth () ; fn test_field_fMaxCharWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxCharWidth) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fMaxCharWidth))) ; } test_field_fMaxCharWidth () ; fn test_field_fXMin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXMin) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fXMin))) ; } test_field_fXMin () ; fn test_field_fXMax () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXMax) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fXMax))) ; } test_field_fXMax () ; fn test_field_fXHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fXHeight) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fXHeight))) ; } test_field_fXHeight () ; fn test_field_fCapHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCapHeight) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fCapHeight))) ; } test_field_fCapHeight () ; fn test_field_fUnderlineThickness () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUnderlineThickness) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fUnderlineThickness))) ; } test_field_fUnderlineThickness () ; fn test_field_fUnderlinePosition () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUnderlinePosition) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fUnderlinePosition))) ; } test_field_fUnderlinePosition () ; fn test_field_fStrikeoutThickness () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStrikeoutThickness) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fStrikeoutThickness))) ; } test_field_fStrikeoutThickness () ; fn test_field_fStrikeoutPosition () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStrikeoutPosition) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (SkFontMetrics) , "::" , stringify ! (fStrikeoutPosition))) ; } test_field_fStrikeoutPosition () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkFontStyleSet { pub _bindgen_opaque_blob : [u64 ; 2usize] , } pub type SkFontStyleSet_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkFontStyleSet () { assert_eq ! (:: core :: mem :: size_of :: < SkFontStyleSet > () , 16usize , concat ! ("Size of: " , stringify ! (SkFontStyleSet))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontStyleSet > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontStyleSet))) ; } extern "C" { # [link_name = "\u{1}?CreateEmpty@SkFontStyleSet@@SAPEAV1@XZ"] pub fn SkFontStyleSet_CreateEmpty () -> * mut SkFontStyleSet ; } extern "C" { # [link_name = "\u{1}?matchStyleCSS3@SkFontStyleSet@@IEAAPEAVSkTypeface@@AEBVSkFontStyle@@@Z"] pub fn SkFontStyleSet_matchStyleCSS3 (this : * mut SkFontStyleSet , pattern : * const SkFontStyle) -> * mut SkTypeface ; } impl SkFontStyleSet { # [inline] pub unsafe fn CreateEmpty () -> * mut SkFontStyleSet { SkFontStyleSet_CreateEmpty () } # [inline] pub unsafe fn matchStyleCSS3 (& mut self , pattern : * const SkFontStyle) -> * mut SkTypeface { SkFontStyleSet_matchStyleCSS3 (self , pattern) } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkFontMgr { pub _bindgen_opaque_blob : [u64 ; 2usize] , } pub type SkFontMgr_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkFontMgr () { assert_eq ! (:: core :: mem :: size_of :: < SkFontMgr > () , 16usize , concat ! ("Size of: " , stringify ! (SkFontMgr))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontMgr > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontMgr))) ; } extern "C" { # [link_name = "\u{1}?countFamilies@SkFontMgr@@QEBAHXZ"] pub fn SkFontMgr_countFamilies (this : * const SkFontMgr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getFamilyName@SkFontMgr@@QEBAXHPEAVSkString@@@Z"] pub fn SkFontMgr_getFamilyName (this : * const SkFontMgr , index : :: std :: os :: raw :: c_int , familyName : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?createStyleSet@SkFontMgr@@QEBAPEAVSkFontStyleSet@@H@Z"] pub fn SkFontMgr_createStyleSet (this : * const SkFontMgr , index : :: std :: os :: raw :: c_int) -> * mut SkFontStyleSet ; } extern "C" { # [link_name = "\u{1}?matchFamily@SkFontMgr@@QEBAPEAVSkFontStyleSet@@QEBD@Z"] pub fn SkFontMgr_matchFamily (this : * const SkFontMgr , familyName : * const :: std :: os :: raw :: c_char) -> * mut SkFontStyleSet ; } extern "C" { # [link_name = "\u{1}?matchFamilyStyle@SkFontMgr@@QEBAPEAVSkTypeface@@QEBDAEBVSkFontStyle@@@Z"] pub fn SkFontMgr_matchFamilyStyle (this : * const SkFontMgr , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?matchFamilyStyleCharacter@SkFontMgr@@QEBAPEAVSkTypeface@@QEBDAEBVSkFontStyle@@QEAPEBDHH@Z"] pub fn SkFontMgr_matchFamilyStyleCharacter (this : * const SkFontMgr , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle , bcp47 : * mut * const :: std :: os :: raw :: c_char , bcp47Count : :: std :: os :: raw :: c_int , character : SkUnichar) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?makeFromData@SkFontMgr@@QEBA?AV?$sk_sp@VSkTypeface@@@@V?$sk_sp@VSkData@@@@H@Z"] pub fn SkFontMgr_makeFromData (this : * const SkFontMgr , arg1 : sk_sp < SkData > , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?makeFromStream@SkFontMgr@@QEBA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@H@Z"] pub fn SkFontMgr_makeFromStream (this : * const SkFontMgr , arg1 : u64 , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?makeFromStream@SkFontMgr@@QEBA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@AEBUSkFontArguments@@@Z"] pub fn SkFontMgr_makeFromStream1 (this : * const SkFontMgr , arg1 : u64 , arg2 : * const SkFontArguments) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?makeFromFile@SkFontMgr@@QEBA?AV?$sk_sp@VSkTypeface@@@@QEBDH@Z"] pub fn SkFontMgr_makeFromFile (this : * const SkFontMgr , path : * const :: std :: os :: raw :: c_char , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?legacyMakeTypeface@SkFontMgr@@QEBA?AV?$sk_sp@VSkTypeface@@@@QEBDVSkFontStyle@@@Z"] pub fn SkFontMgr_legacyMakeTypeface (this : * const SkFontMgr , familyName : * const :: std :: os :: raw :: c_char , style : SkFontStyle) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?RefDefault@SkFontMgr@@SA?AV?$sk_sp@VSkFontMgr@@@@XZ"] pub fn SkFontMgr_RefDefault () -> sk_sp < SkFontMgr > ; } impl SkFontMgr { # [inline] pub unsafe fn countFamilies (& self) -> :: std :: os :: raw :: c_int { SkFontMgr_countFamilies (self) } # [inline] pub unsafe fn getFamilyName (& self , index : :: std :: os :: raw :: c_int , familyName : * mut SkString) { SkFontMgr_getFamilyName (self , index , familyName) } # [inline] pub unsafe fn createStyleSet (& self , index : :: std :: os :: raw :: c_int) -> * mut SkFontStyleSet { SkFontMgr_createStyleSet (self , index) } # [inline] pub unsafe fn matchFamily (& self , familyName : * const :: std :: os :: raw :: c_char) -> * mut SkFontStyleSet { SkFontMgr_matchFamily (self , familyName) } # [inline] pub unsafe fn matchFamilyStyle (& self , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle) -> * mut SkTypeface { SkFontMgr_matchFamilyStyle (self , familyName , arg1) } # [inline] pub unsafe fn matchFamilyStyleCharacter (& self , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle , bcp47 : * mut * const :: std :: os :: raw :: c_char , bcp47Count : :: std :: os :: raw :: c_int , character : SkUnichar) -> * mut SkTypeface { SkFontMgr_matchFamilyStyleCharacter (self , familyName , arg1 , bcp47 , bcp47Count , character) } # [inline] pub unsafe fn makeFromData (& self , arg1 : sk_sp < SkData > , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkFontMgr_makeFromData (self , arg1 , ttcIndex) } # [inline] pub unsafe fn makeFromStream (& self , arg1 : u64 , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkFontMgr_makeFromStream (self , arg1 , ttcIndex) } # [inline] pub unsafe fn makeFromStream1 (& self , arg1 : u64 , arg2 : * const SkFontArguments) -> sk_sp < SkTypeface > { SkFontMgr_makeFromStream1 (self , arg1 , arg2) } # [inline] pub unsafe fn makeFromFile (& self , path : * const :: std :: os :: raw :: c_char , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > { SkFontMgr_makeFromFile (self , path , ttcIndex) } # [inline] pub unsafe fn legacyMakeTypeface (& self , familyName : * const :: std :: os :: raw :: c_char , style : SkFontStyle) -> sk_sp < SkTypeface > { SkFontMgr_legacyMakeTypeface (self , familyName , style) } # [inline] pub unsafe fn RefDefault () -> sk_sp < SkFontMgr > { SkFontMgr_RefDefault () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkOpenTypeSVGDecoder { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTraceMemoryDump { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkGraphics { pub _address : u8 , } pub type SkGraphics_ImageGeneratorFromEncodedDataFactory = :: core :: option :: Option < unsafe extern "C" fn (arg1 : sk_sp < SkData >) -> u64 > ; pub type SkGraphics_OpenTypeSVGDecoderFactory = :: core :: option :: Option < unsafe extern "C" fn (svg : * const u8 , length : usize) -> u8 > ; pub type SkGraphics_VariableColrV1EnabledFunc = :: core :: option :: Option < unsafe extern "C" fn () -> bool > ; # [test] fn bindgen_test_layout_SkGraphics () { assert_eq ! (:: core :: mem :: size_of :: < SkGraphics > () , 1usize , concat ! ("Size of: " , stringify ! (SkGraphics))) ; assert_eq ! (:: core :: mem :: align_of :: < SkGraphics > () , 1usize , concat ! ("Alignment of " , stringify ! (SkGraphics))) ; } extern "C" { # [link_name = "\u{1}?Init@SkGraphics@@SAXXZ"] pub fn SkGraphics_Init () ; } extern "C" { # [link_name = "\u{1}?GetFontCacheLimit@SkGraphics@@SA_KXZ"] pub fn SkGraphics_GetFontCacheLimit () -> usize ; } extern "C" { # [link_name = "\u{1}?SetFontCacheLimit@SkGraphics@@SA_K_K@Z"] pub fn SkGraphics_SetFontCacheLimit (bytes : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?GetFontCacheUsed@SkGraphics@@SA_KXZ"] pub fn SkGraphics_GetFontCacheUsed () -> usize ; } extern "C" { # [link_name = "\u{1}?GetFontCacheCountUsed@SkGraphics@@SAHXZ"] pub fn SkGraphics_GetFontCacheCountUsed () -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?GetFontCacheCountLimit@SkGraphics@@SAHXZ"] pub fn SkGraphics_GetFontCacheCountLimit () -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?SetFontCacheCountLimit@SkGraphics@@SAHH@Z"] pub fn SkGraphics_SetFontCacheCountLimit (count : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?PurgeFontCache@SkGraphics@@SAXXZ"] pub fn SkGraphics_PurgeFontCache () ; } extern "C" { # [link_name = "\u{1}?GetResourceCacheTotalBytesUsed@SkGraphics@@SA_KXZ"] pub fn SkGraphics_GetResourceCacheTotalBytesUsed () -> usize ; } extern "C" { # [link_name = "\u{1}?GetResourceCacheTotalByteLimit@SkGraphics@@SA_KXZ"] pub fn SkGraphics_GetResourceCacheTotalByteLimit () -> usize ; } extern "C" { # [link_name = "\u{1}?SetResourceCacheTotalByteLimit@SkGraphics@@SA_K_K@Z"] pub fn SkGraphics_SetResourceCacheTotalByteLimit (newLimit : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?PurgeResourceCache@SkGraphics@@SAXXZ"] pub fn SkGraphics_PurgeResourceCache () ; } extern "C" { # [link_name = "\u{1}?GetResourceCacheSingleAllocationByteLimit@SkGraphics@@SA_KXZ"] pub fn SkGraphics_GetResourceCacheSingleAllocationByteLimit () -> usize ; } extern "C" { # [link_name = "\u{1}?SetResourceCacheSingleAllocationByteLimit@SkGraphics@@SA_K_K@Z"] pub fn SkGraphics_SetResourceCacheSingleAllocationByteLimit (newLimit : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?DumpMemoryStatistics@SkGraphics@@SAXPEAVSkTraceMemoryDump@@@Z"] pub fn SkGraphics_DumpMemoryStatistics (dump : * mut SkTraceMemoryDump) ; } extern "C" { # [link_name = "\u{1}?PurgeAllCaches@SkGraphics@@SAXXZ"] pub fn SkGraphics_PurgeAllCaches () ; } extern "C" { # [link_name = "\u{1}?SetFlags@SkGraphics@@SAXPEBD@Z"] pub fn SkGraphics_SetFlags (flags : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?SetImageGeneratorFromEncodedDataFactory@SkGraphics@@SAP6A?AV?$unique_ptr@VSkImageGenerator@@U?$default_delete@VSkImageGenerator@@@std@@@std@@V?$sk_sp@VSkData@@@@@ZP6A?AV23@0@Z@Z"] pub fn SkGraphics_SetImageGeneratorFromEncodedDataFactory (arg1 : SkGraphics_ImageGeneratorFromEncodedDataFactory) -> SkGraphics_ImageGeneratorFromEncodedDataFactory ; } extern "C" { # [link_name = "\u{1}?SetOpenTypeSVGDecoderFactory@SkGraphics@@SAP6A?AV?$unique_ptr@VSkOpenTypeSVGDecoder@@U?$default_delete@VSkOpenTypeSVGDecoder@@@std@@@std@@PEBE_K@ZP6A?AV23@01@Z@Z"] pub fn SkGraphics_SetOpenTypeSVGDecoderFactory (arg1 : SkGraphics_OpenTypeSVGDecoderFactory) -> SkGraphics_OpenTypeSVGDecoderFactory ; } extern "C" { # [link_name = "\u{1}?GetOpenTypeSVGDecoderFactory@SkGraphics@@SAP6A?AV?$unique_ptr@VSkOpenTypeSVGDecoder@@U?$default_delete@VSkOpenTypeSVGDecoder@@@std@@@std@@PEBE_K@ZXZ"] pub fn SkGraphics_GetOpenTypeSVGDecoderFactory () -> SkGraphics_OpenTypeSVGDecoderFactory ; } extern "C" { # [link_name = "\u{1}?SetVariableColrV1EnabledFunc@SkGraphics@@SAP6A_NXZP6A_NXZ@Z"] pub fn SkGraphics_SetVariableColrV1EnabledFunc (arg1 : SkGraphics_VariableColrV1EnabledFunc) -> SkGraphics_VariableColrV1EnabledFunc ; } extern "C" { # [link_name = "\u{1}?GetVariableColrV1Enabled@SkGraphics@@SA_NXZ"] pub fn SkGraphics_GetVariableColrV1Enabled () -> bool ; } extern "C" { # [link_name = "\u{1}?AllowJIT@SkGraphics@@SAXXZ"] pub fn SkGraphics_AllowJIT () ; } impl SkGraphics { # [inline] pub unsafe fn Init () { SkGraphics_Init () } # [inline] pub unsafe fn GetFontCacheLimit () -> usize { SkGraphics_GetFontCacheLimit () } # [inline] pub unsafe fn SetFontCacheLimit (bytes : usize) -> usize { SkGraphics_SetFontCacheLimit (bytes) } # [inline] pub unsafe fn GetFontCacheUsed () -> usize { SkGraphics_GetFontCacheUsed () } # [inline] pub unsafe fn GetFontCacheCountUsed () -> :: std :: os :: raw :: c_int { SkGraphics_GetFontCacheCountUsed () } # [inline] pub unsafe fn GetFontCacheCountLimit () -> :: std :: os :: raw :: c_int { SkGraphics_GetFontCacheCountLimit () } # [inline] pub unsafe fn SetFontCacheCountLimit (count : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { SkGraphics_SetFontCacheCountLimit (count) } # [inline] pub unsafe fn PurgeFontCache () { SkGraphics_PurgeFontCache () } # [inline] pub unsafe fn GetResourceCacheTotalBytesUsed () -> usize { SkGraphics_GetResourceCacheTotalBytesUsed () } # [inline] pub unsafe fn GetResourceCacheTotalByteLimit () -> usize { SkGraphics_GetResourceCacheTotalByteLimit () } # [inline] pub unsafe fn SetResourceCacheTotalByteLimit (newLimit : usize) -> usize { SkGraphics_SetResourceCacheTotalByteLimit (newLimit) } # [inline] pub unsafe fn PurgeResourceCache () { SkGraphics_PurgeResourceCache () } # [inline] pub unsafe fn GetResourceCacheSingleAllocationByteLimit () -> usize { SkGraphics_GetResourceCacheSingleAllocationByteLimit () } # [inline] pub unsafe fn SetResourceCacheSingleAllocationByteLimit (newLimit : usize) -> usize { SkGraphics_SetResourceCacheSingleAllocationByteLimit (newLimit) } # [inline] pub unsafe fn DumpMemoryStatistics (dump : * mut SkTraceMemoryDump) { SkGraphics_DumpMemoryStatistics (dump) } # [inline] pub unsafe fn PurgeAllCaches () { SkGraphics_PurgeAllCaches () } # [inline] pub unsafe fn SetFlags (flags : * const :: std :: os :: raw :: c_char) { SkGraphics_SetFlags (flags) } # [inline] pub unsafe fn SetImageGeneratorFromEncodedDataFactory (arg1 : SkGraphics_ImageGeneratorFromEncodedDataFactory) -> SkGraphics_ImageGeneratorFromEncodedDataFactory { SkGraphics_SetImageGeneratorFromEncodedDataFactory (arg1) } # [inline] pub unsafe fn SetOpenTypeSVGDecoderFactory (arg1 : SkGraphics_OpenTypeSVGDecoderFactory) -> SkGraphics_OpenTypeSVGDecoderFactory { SkGraphics_SetOpenTypeSVGDecoderFactory (arg1) } # [inline] pub unsafe fn GetOpenTypeSVGDecoderFactory () -> SkGraphics_OpenTypeSVGDecoderFactory { SkGraphics_GetOpenTypeSVGDecoderFactory () } # [inline] pub unsafe fn SetVariableColrV1EnabledFunc (arg1 : SkGraphics_VariableColrV1EnabledFunc) -> SkGraphics_VariableColrV1EnabledFunc { SkGraphics_SetVariableColrV1EnabledFunc (arg1) } # [inline] pub unsafe fn GetVariableColrV1Enabled () -> bool { SkGraphics_GetVariableColrV1Enabled () } # [inline] pub unsafe fn AllowJIT () { SkGraphics_AllowJIT () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkImageFilter { pub _base : SkFlattenable , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImageFilter_MapDirection { Forward = 0 , Reverse = 1 , } pub type SkImageFilter_INHERITED = SkFlattenable ; # [test] fn bindgen_test_layout_SkImageFilter () { assert_eq ! (:: core :: mem :: size_of :: < SkImageFilter > () , 16usize , concat ! ("Size of: " , stringify ! (SkImageFilter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImageFilter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkImageFilter))) ; } extern "C" { # [link_name = "\u{1}?filterBounds@SkImageFilter@@QEBA?AUSkIRect@@AEBU2@AEBVSkMatrix@@W4MapDirection@1@PEBU2@@Z"] pub fn SkImageFilter_filterBounds (this : * const SkImageFilter , src : * const SkIRect , ctm : * const SkMatrix , arg1 : SkImageFilter_MapDirection , inputRect : * const SkIRect) -> SkIRect ; } extern "C" { # [link_name = "\u{1}?isColorFilterNode@SkImageFilter@@QEBA_NPEAPEAVSkColorFilter@@@Z"] pub fn SkImageFilter_isColorFilterNode (this : * const SkImageFilter , filterPtr : * mut * mut SkColorFilter) -> bool ; } extern "C" { # [link_name = "\u{1}?asAColorFilter@SkImageFilter@@QEBA_NPEAPEAVSkColorFilter@@@Z"] pub fn SkImageFilter_asAColorFilter (this : * const SkImageFilter , filterPtr : * mut * mut SkColorFilter) -> bool ; } extern "C" { # [link_name = "\u{1}?countInputs@SkImageFilter@@QEBAHXZ"] pub fn SkImageFilter_countInputs (this : * const SkImageFilter) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getInput@SkImageFilter@@QEBAPEBV1@H@Z"] pub fn SkImageFilter_getInput (this : * const SkImageFilter , i : :: std :: os :: raw :: c_int) -> * const SkImageFilter ; } extern "C" { # [link_name = "\u{1}?canComputeFastBounds@SkImageFilter@@QEBA_NXZ"] pub fn SkImageFilter_canComputeFastBounds (this : * const SkImageFilter) -> bool ; } extern "C" { # [link_name = "\u{1}?makeWithLocalMatrix@SkImageFilter@@QEBA?AV?$sk_sp@VSkImageFilter@@@@AEBVSkMatrix@@@Z"] pub fn SkImageFilter_makeWithLocalMatrix (this : * const SkImageFilter , matrix : * const SkMatrix) -> sk_sp < SkImageFilter > ; } impl SkImageFilter { # [inline] pub unsafe fn filterBounds (& self , src : * const SkIRect , ctm : * const SkMatrix , arg1 : SkImageFilter_MapDirection , inputRect : * const SkIRect) -> SkIRect { SkImageFilter_filterBounds (self , src , ctm , arg1 , inputRect) } # [inline] pub unsafe fn isColorFilterNode (& self , filterPtr : * mut * mut SkColorFilter) -> bool { SkImageFilter_isColorFilterNode (self , filterPtr) } # [inline] pub unsafe fn asAColorFilter (& self , filterPtr : * mut * mut SkColorFilter) -> bool { SkImageFilter_asAColorFilter (self , filterPtr) } # [inline] pub unsafe fn countInputs (& self) -> :: std :: os :: raw :: c_int { SkImageFilter_countInputs (self) } # [inline] pub unsafe fn getInput (& self , i : :: std :: os :: raw :: c_int) -> * const SkImageFilter { SkImageFilter_getInput (self , i) } # [inline] pub unsafe fn canComputeFastBounds (& self) -> bool { SkImageFilter_canComputeFastBounds (self) } # [inline] pub unsafe fn makeWithLocalMatrix (& self , matrix : * const SkMatrix) -> sk_sp < SkImageFilter > { SkImageFilter_makeWithLocalMatrix (self , matrix) } } extern "C" { # [link_name = "\u{1}?computeFastBounds@SkImageFilter@@UEBA?AUSkRect@@AEBU2@@Z"] pub fn SkImageFilter_computeFastBounds (this : * mut :: core :: ffi :: c_void , bounds : * const SkRect) -> SkRect ; } # [repr (C)] # [derive (Debug)] pub struct SkBitmap { pub fPixelRef : sk_sp < SkPixelRef > , pub fPixmap : SkPixmap , pub fMips : sk_sp < SkMipmap > , } pub const SkBitmap_AllocFlags_kZeroPixels_AllocFlag : SkBitmap_AllocFlags = 1 ; pub type SkBitmap_AllocFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkBitmap_Allocator { pub _bindgen_opaque_blob : [u64 ; 2usize] , } pub type SkBitmap_Allocator_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkBitmap_Allocator () { assert_eq ! (:: core :: mem :: size_of :: < SkBitmap_Allocator > () , 16usize , concat ! ("Size of: " , stringify ! (SkBitmap_Allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBitmap_Allocator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBitmap_Allocator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkBitmap_HeapAllocator { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_SkBitmap_HeapAllocator () { assert_eq ! (:: core :: mem :: size_of :: < SkBitmap_HeapAllocator > () , 16usize , concat ! ("Size of: " , stringify ! (SkBitmap_HeapAllocator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBitmap_HeapAllocator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBitmap_HeapAllocator))) ; } # [test] fn bindgen_test_layout_SkBitmap () { assert_eq ! (:: core :: mem :: size_of :: < SkBitmap > () , 56usize , concat ! ("Size of: " , stringify ! (SkBitmap))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBitmap > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBitmap))) ; fn test_field_fPixelRef () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkBitmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPixelRef) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkBitmap) , "::" , stringify ! (fPixelRef))) ; } test_field_fPixelRef () ; fn test_field_fPixmap () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkBitmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPixmap) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkBitmap) , "::" , stringify ! (fPixmap))) ; } test_field_fPixmap () ; fn test_field_fMips () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkBitmap > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMips) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkBitmap) , "::" , stringify ! (fMips))) ; } test_field_fMips () ; } extern "C" { # [link_name = "\u{1}?swap@SkBitmap@@QEAAXAEAV1@@Z"] pub fn SkBitmap_swap (this : * mut SkBitmap , other : * mut SkBitmap) ; } extern "C" { # [link_name = "\u{1}?colorSpace@SkBitmap@@QEBAPEAVSkColorSpace@@XZ"] pub fn SkBitmap_colorSpace (this : * const SkBitmap) -> * mut SkColorSpace ; } extern "C" { # [link_name = "\u{1}?refColorSpace@SkBitmap@@QEBA?AV?$sk_sp@VSkColorSpace@@@@XZ"] pub fn SkBitmap_refColorSpace (this : * const SkBitmap) -> sk_sp < SkColorSpace > ; } extern "C" { # [link_name = "\u{1}?setAlphaType@SkBitmap@@QEAA_NW4SkAlphaType@@@Z"] pub fn SkBitmap_setAlphaType (this : * mut SkBitmap , alphaType : SkAlphaType) -> bool ; } extern "C" { # [link_name = "\u{1}?isImmutable@SkBitmap@@QEBA_NXZ"] pub fn SkBitmap_isImmutable (this : * const SkBitmap) -> bool ; } extern "C" { # [link_name = "\u{1}?setImmutable@SkBitmap@@QEAAXXZ"] pub fn SkBitmap_setImmutable (this : * mut SkBitmap) ; } extern "C" { # [link_name = "\u{1}?reset@SkBitmap@@QEAAXXZ"] pub fn SkBitmap_reset (this : * mut SkBitmap) ; } extern "C" { # [link_name = "\u{1}?getBounds@SkBitmap@@QEBAXPEAUSkRect@@@Z"] pub fn SkBitmap_getBounds (this : * const SkBitmap , bounds : * mut SkRect) ; } extern "C" { # [link_name = "\u{1}?getBounds@SkBitmap@@QEBAXPEAUSkIRect@@@Z"] pub fn SkBitmap_getBounds1 (this : * const SkBitmap , bounds : * mut SkIRect) ; } extern "C" { # [link_name = "\u{1}?setInfo@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"] pub fn SkBitmap_setInfo (this : * mut SkBitmap , imageInfo : * const SkImageInfo , rowBytes : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?tryAllocPixelsFlags@SkBitmap@@QEAA_NAEBUSkImageInfo@@I@Z"] pub fn SkBitmap_tryAllocPixelsFlags (this : * mut SkBitmap , info : * const SkImageInfo , flags : u32) -> bool ; } extern "C" { # [link_name = "\u{1}?allocPixelsFlags@SkBitmap@@QEAAXAEBUSkImageInfo@@I@Z"] pub fn SkBitmap_allocPixelsFlags (this : * mut SkBitmap , info : * const SkImageInfo , flags : u32) ; } extern "C" { # [link_name = "\u{1}?tryAllocPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@_K@Z"] pub fn SkBitmap_tryAllocPixels (this : * mut SkBitmap , info : * const SkImageInfo , rowBytes : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?allocPixels@SkBitmap@@QEAAXAEBUSkImageInfo@@_K@Z"] pub fn SkBitmap_allocPixels (this : * mut SkBitmap , info : * const SkImageInfo , rowBytes : usize) ; } extern "C" { # [link_name = "\u{1}?allocPixels@SkBitmap@@QEAAXAEBUSkImageInfo@@@Z"] pub fn SkBitmap_allocPixels1 (this : * mut SkBitmap , info : * const SkImageInfo) ; } extern "C" { # [link_name = "\u{1}?tryAllocN32Pixels@SkBitmap@@QEAA_NHH_N@Z"] pub fn SkBitmap_tryAllocN32Pixels (this : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?allocN32Pixels@SkBitmap@@QEAAXHH_N@Z"] pub fn SkBitmap_allocN32Pixels (this : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool) ; } extern "C" { # [link_name = "\u{1}?installPixels@SkBitmap@@QEAA_NAEBUSkImageInfo@@PEAX_KP6AX11@Z1@Z"] pub fn SkBitmap_installPixels (this : * mut SkBitmap , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn (addr : * mut :: core :: ffi :: c_void , context : * mut :: core :: ffi :: c_void) > , context : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?installPixels@SkBitmap@@QEAA_NAEBVSkPixmap@@@Z"] pub fn SkBitmap_installPixels1 (this : * mut SkBitmap , pixmap : * const SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?installMaskPixels@SkBitmap@@QEAA_NAEBUSkMask@@@Z"] pub fn SkBitmap_installMaskPixels (this : * mut SkBitmap , mask : * const SkMask) -> bool ; } extern "C" { # [link_name = "\u{1}?setPixels@SkBitmap@@QEAAXPEAX@Z"] pub fn SkBitmap_setPixels (this : * mut SkBitmap , pixels : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?allocPixels@SkBitmap@@QEAAXXZ"] pub fn SkBitmap_allocPixels2 (this : * mut SkBitmap) ; } extern "C" { # [link_name = "\u{1}?tryAllocPixels@SkBitmap@@QEAA_NPEAVAllocator@1@@Z"] pub fn SkBitmap_tryAllocPixels1 (this : * mut SkBitmap , allocator : * mut SkBitmap_Allocator) -> bool ; } extern "C" { # [link_name = "\u{1}?allocPixels@SkBitmap@@QEAAXPEAVAllocator@1@@Z"] pub fn SkBitmap_allocPixels3 (this : * mut SkBitmap , allocator : * mut SkBitmap_Allocator) ; } extern "C" { # [link_name = "\u{1}?pixelRefOrigin@SkBitmap@@QEBA?AUSkIPoint@@XZ"] pub fn SkBitmap_pixelRefOrigin (this : * const SkBitmap) -> SkIPoint ; } extern "C" { # [link_name = "\u{1}?setPixelRef@SkBitmap@@QEAAXV?$sk_sp@VSkPixelRef@@@@HH@Z"] pub fn SkBitmap_setPixelRef (this : * mut SkBitmap , pixelRef : sk_sp < SkPixelRef > , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?getGenerationID@SkBitmap@@QEBAIXZ"] pub fn SkBitmap_getGenerationID (this : * const SkBitmap) -> u32 ; } extern "C" { # [link_name = "\u{1}?notifyPixelsChanged@SkBitmap@@QEBAXXZ"] pub fn SkBitmap_notifyPixelsChanged (this : * const SkBitmap) ; } extern "C" { # [link_name = "\u{1}?eraseColor@SkBitmap@@QEBAXU?$SkRGBA4f@$02@@PEAVSkColorSpace@@@Z"] pub fn SkBitmap_eraseColor (this : * const SkBitmap , c : SkColor4f , colorSpace : * mut SkColorSpace) ; } extern "C" { # [link_name = "\u{1}?eraseColor@SkBitmap@@QEBAXI@Z"] pub fn SkBitmap_eraseColor1 (this : * const SkBitmap , c : SkColor) ; } extern "C" { # [link_name = "\u{1}?erase@SkBitmap@@QEBAXU?$SkRGBA4f@$02@@PEAVSkColorSpace@@AEBUSkIRect@@@Z"] pub fn SkBitmap_erase (this : * const SkBitmap , c : SkColor4f , colorSpace : * mut SkColorSpace , area : * const SkIRect) ; } extern "C" { # [link_name = "\u{1}?erase@SkBitmap@@QEBAXU?$SkRGBA4f@$02@@AEBUSkIRect@@@Z"] pub fn SkBitmap_erase1 (this : * const SkBitmap , c : SkColor4f , area : * const SkIRect) ; } extern "C" { # [link_name = "\u{1}?erase@SkBitmap@@QEBAXIAEBUSkIRect@@@Z"] pub fn SkBitmap_erase2 (this : * const SkBitmap , c : SkColor , area : * const SkIRect) ; } extern "C" { # [link_name = "\u{1}?getAddr@SkBitmap@@QEBAPEAXHH@Z"] pub fn SkBitmap_getAddr (this : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> * mut :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}?extractSubset@SkBitmap@@QEBA_NPEAV1@AEBUSkIRect@@@Z"] pub fn SkBitmap_extractSubset (this : * const SkBitmap , dst : * mut SkBitmap , subset : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkBitmap@@QEBA_NAEBUSkImageInfo@@PEAX_KHH@Z"] pub fn SkBitmap_readPixels (this : * const SkBitmap , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkBitmap@@QEBA_NAEBVSkPixmap@@HH@Z"] pub fn SkBitmap_readPixels1 (this : * const SkBitmap , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?writePixels@SkBitmap@@QEAA_NAEBVSkPixmap@@HH@Z"] pub fn SkBitmap_writePixels (this : * mut SkBitmap , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?extractAlpha@SkBitmap@@QEBA_NPEAV1@PEBVSkPaint@@PEAVAllocator@1@PEAUSkIPoint@@@Z"] pub fn SkBitmap_extractAlpha (this : * const SkBitmap , dst : * mut SkBitmap , paint : * const SkPaint , allocator : * mut SkBitmap_Allocator , offset : * mut SkIPoint) -> bool ; } extern "C" { # [link_name = "\u{1}?peekPixels@SkBitmap@@QEBA_NPEAVSkPixmap@@@Z"] pub fn SkBitmap_peekPixels (this : * const SkBitmap , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?makeShader@SkBitmap@@QEBA?AV?$sk_sp@VSkShader@@@@W4SkTileMode@@0AEBUSkSamplingOptions@@PEBVSkMatrix@@@Z"] pub fn SkBitmap_makeShader (this : * const SkBitmap , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , arg2 : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?asImage@SkBitmap@@QEBA?AV?$sk_sp@VSkImage@@@@XZ"] pub fn SkBitmap_asImage (this : * const SkBitmap) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}??0SkBitmap@@QEAA@XZ"] pub fn SkBitmap_SkBitmap (this : * mut SkBitmap) ; } extern "C" { # [link_name = "\u{1}??0SkBitmap@@QEAA@AEBV0@@Z"] pub fn SkBitmap_SkBitmap1 (this : * mut SkBitmap , src : * const SkBitmap) ; } extern "C" { # [link_name = "\u{1}??0SkBitmap@@QEAA@$$QEAV0@@Z"] pub fn SkBitmap_SkBitmap2 (this : * mut SkBitmap , src : * mut SkBitmap) ; } impl SkBitmap { # [inline] pub unsafe fn swap (& mut self , other : * mut SkBitmap) { SkBitmap_swap (self , other) } # [inline] pub unsafe fn colorSpace (& self) -> * mut SkColorSpace { SkBitmap_colorSpace (self) } # [inline] pub unsafe fn refColorSpace (& self) -> sk_sp < SkColorSpace > { SkBitmap_refColorSpace (self) } # [inline] pub unsafe fn setAlphaType (& mut self , alphaType : SkAlphaType) -> bool { SkBitmap_setAlphaType (self , alphaType) } # [inline] pub unsafe fn isImmutable (& self) -> bool { SkBitmap_isImmutable (self) } # [inline] pub unsafe fn setImmutable (& mut self) { SkBitmap_setImmutable (self) } # [inline] pub unsafe fn reset (& mut self) { SkBitmap_reset (self) } # [inline] pub unsafe fn getBounds (& self , bounds : * mut SkRect) { SkBitmap_getBounds (self , bounds) } # [inline] pub unsafe fn getBounds1 (& self , bounds : * mut SkIRect) { SkBitmap_getBounds1 (self , bounds) } # [inline] pub unsafe fn setInfo (& mut self , imageInfo : * const SkImageInfo , rowBytes : usize) -> bool { SkBitmap_setInfo (self , imageInfo , rowBytes) } # [inline] pub unsafe fn tryAllocPixelsFlags (& mut self , info : * const SkImageInfo , flags : u32) -> bool { SkBitmap_tryAllocPixelsFlags (self , info , flags) } # [inline] pub unsafe fn allocPixelsFlags (& mut self , info : * const SkImageInfo , flags : u32) { SkBitmap_allocPixelsFlags (self , info , flags) } # [inline] pub unsafe fn tryAllocPixels (& mut self , info : * const SkImageInfo , rowBytes : usize) -> bool { SkBitmap_tryAllocPixels (self , info , rowBytes) } # [inline] pub unsafe fn allocPixels (& mut self , info : * const SkImageInfo , rowBytes : usize) { SkBitmap_allocPixels (self , info , rowBytes) } # [inline] pub unsafe fn allocPixels1 (& mut self , info : * const SkImageInfo) { SkBitmap_allocPixels1 (self , info) } # [inline] pub unsafe fn tryAllocN32Pixels (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool) -> bool { SkBitmap_tryAllocN32Pixels (self , width , height , isOpaque) } # [inline] pub unsafe fn allocN32Pixels (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool) { SkBitmap_allocN32Pixels (self , width , height , isOpaque) } # [inline] pub unsafe fn installPixels (& mut self , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn (addr : * mut :: core :: ffi :: c_void , context : * mut :: core :: ffi :: c_void) > , context : * mut :: core :: ffi :: c_void) -> bool { SkBitmap_installPixels (self , info , pixels , rowBytes , releaseProc , context) } # [inline] pub unsafe fn installPixels1 (& mut self , pixmap : * const SkPixmap) -> bool { SkBitmap_installPixels1 (self , pixmap) } # [inline] pub unsafe fn installMaskPixels (& mut self , mask : * const SkMask) -> bool { SkBitmap_installMaskPixels (self , mask) } # [inline] pub unsafe fn setPixels (& mut self , pixels : * mut :: core :: ffi :: c_void) { SkBitmap_setPixels (self , pixels) } # [inline] pub unsafe fn allocPixels2 (& mut self) { SkBitmap_allocPixels2 (self) } # [inline] pub unsafe fn tryAllocPixels1 (& mut self , allocator : * mut SkBitmap_Allocator) -> bool { SkBitmap_tryAllocPixels1 (self , allocator) } # [inline] pub unsafe fn allocPixels3 (& mut self , allocator : * mut SkBitmap_Allocator) { SkBitmap_allocPixels3 (self , allocator) } # [inline] pub unsafe fn pixelRefOrigin (& self) -> SkIPoint { SkBitmap_pixelRefOrigin (self) } # [inline] pub unsafe fn setPixelRef (& mut self , pixelRef : sk_sp < SkPixelRef > , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int) { SkBitmap_setPixelRef (self , pixelRef , dx , dy) } # [inline] pub unsafe fn getGenerationID (& self) -> u32 { SkBitmap_getGenerationID (self) } # [inline] pub unsafe fn notifyPixelsChanged (& self) { SkBitmap_notifyPixelsChanged (self) } # [inline] pub unsafe fn eraseColor (& self , c : SkColor4f , colorSpace : * mut SkColorSpace) { SkBitmap_eraseColor (self , c , colorSpace) } # [inline] pub unsafe fn eraseColor1 (& self , c : SkColor) { SkBitmap_eraseColor1 (self , c) } # [inline] pub unsafe fn erase (& self , c : SkColor4f , colorSpace : * mut SkColorSpace , area : * const SkIRect) { SkBitmap_erase (self , c , colorSpace , area) } # [inline] pub unsafe fn erase1 (& self , c : SkColor4f , area : * const SkIRect) { SkBitmap_erase1 (self , c , area) } # [inline] pub unsafe fn erase2 (& self , c : SkColor , area : * const SkIRect) { SkBitmap_erase2 (self , c , area) } # [inline] pub unsafe fn getAddr (& self , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> * mut :: core :: ffi :: c_void { SkBitmap_getAddr (self , x , y) } # [inline] pub unsafe fn extractSubset (& self , dst : * mut SkBitmap , subset : * const SkIRect) -> bool { SkBitmap_extractSubset (self , dst , subset) } # [inline] pub unsafe fn readPixels (& self , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkBitmap_readPixels (self , dstInfo , dstPixels , dstRowBytes , srcX , srcY) } # [inline] pub unsafe fn readPixels1 (& self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkBitmap_readPixels1 (self , dst , srcX , srcY) } # [inline] pub unsafe fn writePixels (& mut self , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) -> bool { SkBitmap_writePixels (self , src , dstX , dstY) } # [inline] pub unsafe fn extractAlpha (& self , dst : * mut SkBitmap , paint : * const SkPaint , allocator : * mut SkBitmap_Allocator , offset : * mut SkIPoint) -> bool { SkBitmap_extractAlpha (self , dst , paint , allocator , offset) } # [inline] pub unsafe fn peekPixels (& self , pixmap : * mut SkPixmap) -> bool { SkBitmap_peekPixels (self , pixmap) } # [inline] pub unsafe fn makeShader (& self , tmx : SkTileMode , tmy : SkTileMode , arg1 : * const SkSamplingOptions , arg2 : * const SkMatrix) -> sk_sp < SkShader > { SkBitmap_makeShader (self , tmx , tmy , arg1 , arg2) } # [inline] pub unsafe fn asImage (& self) -> sk_sp < SkImage > { SkBitmap_asImage (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkBitmap_SkBitmap (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (src : * const SkBitmap) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkBitmap_SkBitmap1 (__bindgen_tmp . as_mut_ptr () , src) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (src : * mut SkBitmap) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkBitmap_SkBitmap2 (__bindgen_tmp . as_mut_ptr () , src) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?allocPixelRef@HeapAllocator@SkBitmap@@UEAA_NPEAV2@@Z"] pub fn SkBitmap_HeapAllocator_allocPixelRef (this : * mut :: core :: ffi :: c_void , bitmap : * mut SkBitmap) -> bool ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrSurfaceProxyView { _unused : [u8 ; 0] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrImageTexGenPolicy { __bindgen_cannot_repr_c_on_empty_enum = 0 } # [repr (C)] pub struct SkImageGenerator__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] # [derive (Debug)] pub struct SkImageGenerator { pub vtable_ : * const SkImageGenerator__bindgen_vtable , pub fInfo : SkImageInfo , pub fUniqueID : u32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkImageGenerator_Options { pub _address : u8 , } # [test] fn bindgen_test_layout_SkImageGenerator_Options () { assert_eq ! (:: core :: mem :: size_of :: < SkImageGenerator_Options > () , 1usize , concat ! ("Size of: " , stringify ! (SkImageGenerator_Options))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImageGenerator_Options > () , 1usize , concat ! ("Alignment of " , stringify ! (SkImageGenerator_Options))) ; } pub const SkImageGenerator_kNeedNewImageUniqueID : :: std :: os :: raw :: c_int = 0 ; # [test] fn bindgen_test_layout_SkImageGenerator () { assert_eq ! (:: core :: mem :: size_of :: < SkImageGenerator > () , 40usize , concat ! ("Size of: " , stringify ! (SkImageGenerator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImageGenerator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkImageGenerator))) ; fn test_field_fInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImageGenerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkImageGenerator) , "::" , stringify ! (fInfo))) ; } test_field_fInfo () ; fn test_field_fUniqueID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImageGenerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUniqueID) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkImageGenerator) , "::" , stringify ! (fUniqueID))) ; } test_field_fUniqueID () ; } extern "C" { # [link_name = "\u{1}?getPixels@SkImageGenerator@@QEAA_NAEBUSkImageInfo@@PEAX_K@Z"] pub fn SkImageGenerator_getPixels (this : * mut SkImageGenerator , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?queryYUVAInfo@SkImageGenerator@@QEBA_NAEBVSupportedDataTypes@SkYUVAPixmapInfo@@PEAV3@@Z"] pub fn SkImageGenerator_queryYUVAInfo (this : * const SkImageGenerator , supportedDataTypes : * const SkYUVAPixmapInfo_SupportedDataTypes , yuvaPixmapInfo : * mut SkYUVAPixmapInfo) -> bool ; } extern "C" { # [link_name = "\u{1}?getYUVAPlanes@SkImageGenerator@@QEAA_NAEBVSkYUVAPixmaps@@@Z"] pub fn SkImageGenerator_getYUVAPlanes (this : * mut SkImageGenerator , yuvaPixmaps : * const SkYUVAPixmaps) -> bool ; } extern "C" { # [link_name = "\u{1}?generateTexture@SkImageGenerator@@QEAA?AVGrSurfaceProxyView@@PEAVGrRecordingContext@@AEBUSkImageInfo@@AEBUSkIPoint@@W4GrMipmapped@@W4GrImageTexGenPolicy@@@Z"] pub fn SkImageGenerator_generateTexture (this : * mut SkImageGenerator , arg1 : * mut GrRecordingContext , info : * const SkImageInfo , origin : * const SkIPoint , arg2 : GrMipmapped , arg3 : GrImageTexGenPolicy) -> GrSurfaceProxyView ; } extern "C" { # [link_name = "\u{1}?MakeFromEncoded@SkImageGenerator@@SA?AV?$unique_ptr@VSkImageGenerator@@U?$default_delete@VSkImageGenerator@@@std@@@std@@V?$sk_sp@VSkData@@@@V?$optional@W4SkAlphaType@@@3@@Z"] pub fn SkImageGenerator_MakeFromEncoded (arg1 : sk_sp < SkData > , arg2 : [u32 ; 2usize]) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeFromPicture@SkImageGenerator@@SA?AV?$unique_ptr@VSkImageGenerator@@U?$default_delete@VSkImageGenerator@@@std@@@std@@AEBUSkISize@@V?$sk_sp@VSkPicture@@@@PEBVSkMatrix@@PEBVSkPaint@@W4BitDepth@SkImage@@V?$sk_sp@VSkColorSpace@@@@VSkSurfaceProps@@@Z"] pub fn SkImageGenerator_MakeFromPicture (arg1 : * const SkISize , arg2 : sk_sp < SkPicture > , arg3 : * const SkMatrix , arg4 : * const SkPaint , arg5 : SkImage_BitDepth , arg6 : sk_sp < SkColorSpace > , props : SkSurfaceProps) -> u64 ; } extern "C" { # [link_name = "\u{1}??0SkImageGenerator@@IEAA@AEBUSkImageInfo@@I@Z"] pub fn SkImageGenerator_SkImageGenerator (this : * mut SkImageGenerator , info : * const SkImageInfo , uniqueId : u32) ; } impl SkImageGenerator { # [inline] pub unsafe fn getPixels (& mut self , info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize) -> bool { SkImageGenerator_getPixels (self , info , pixels , rowBytes) } # [inline] pub unsafe fn queryYUVAInfo (& self , supportedDataTypes : * const SkYUVAPixmapInfo_SupportedDataTypes , yuvaPixmapInfo : * mut SkYUVAPixmapInfo) -> bool { SkImageGenerator_queryYUVAInfo (self , supportedDataTypes , yuvaPixmapInfo) } # [inline] pub unsafe fn getYUVAPlanes (& mut self , yuvaPixmaps : * const SkYUVAPixmaps) -> bool { SkImageGenerator_getYUVAPlanes (self , yuvaPixmaps) } # [inline] pub unsafe fn generateTexture (& mut self , arg1 : * mut GrRecordingContext , info : * const SkImageInfo , origin : * const SkIPoint , arg2 : GrMipmapped , arg3 : GrImageTexGenPolicy) -> GrSurfaceProxyView { SkImageGenerator_generateTexture (self , arg1 , info , origin , arg2 , arg3) } # [inline] pub unsafe fn MakeFromEncoded (arg1 : sk_sp < SkData > , arg2 : [u32 ; 2usize]) -> u64 { SkImageGenerator_MakeFromEncoded (arg1 , arg2) } # [inline] pub unsafe fn MakeFromPicture (arg1 : * const SkISize , arg2 : sk_sp < SkPicture > , arg3 : * const SkMatrix , arg4 : * const SkPaint , arg5 : SkImage_BitDepth , arg6 : sk_sp < SkColorSpace > , props : SkSurfaceProps) -> u64 { SkImageGenerator_MakeFromPicture (arg1 , arg2 , arg3 , arg4 , arg5 , arg6 , props) } # [inline] pub unsafe fn new (info : * const SkImageInfo , uniqueId : u32) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkImageGenerator_SkImageGenerator (__bindgen_tmp . as_mut_ptr () , info , uniqueId) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?onGenerateTexture@SkImageGenerator@@MEAA?AVGrSurfaceProxyView@@PEAVGrRecordingContext@@AEBUSkImageInfo@@AEBUSkIPoint@@W4GrMipmapped@@W4GrImageTexGenPolicy@@@Z"] pub fn SkImageGenerator_onGenerateTexture (this : * mut :: core :: ffi :: c_void , arg1 : * mut GrRecordingContext , arg2 : * const SkImageInfo , arg3 : * const SkIPoint , arg4 : GrMipmapped , arg5 : GrImageTexGenPolicy) -> GrSurfaceProxyView ; } impl SkBlurStyle { pub const LastEnum : SkBlurStyle = SkBlurStyle :: Inner ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkBlurStyle { Normal = 0 , Solid = 1 , Outer = 2 , Inner = 3 , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkMaskFilter { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_SkMaskFilter () { assert_eq ! (:: core :: mem :: size_of :: < SkMaskFilter > () , 16usize , concat ! ("Size of: " , stringify ! (SkMaskFilter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkMaskFilter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkMaskFilter))) ; } extern "C" { # [link_name = "\u{1}?MakeBlur@SkMaskFilter@@SA?AV?$sk_sp@VSkMaskFilter@@@@W4SkBlurStyle@@M_N@Z"] pub fn SkMaskFilter_MakeBlur (style : SkBlurStyle , sigma : SkScalar , respectCTM : bool) -> sk_sp < SkMaskFilter > ; } extern "C" { # [link_name = "\u{1}?approximateFilteredBounds@SkMaskFilter@@QEBA?AUSkRect@@AEBU2@@Z"] pub fn SkMaskFilter_approximateFilteredBounds (this : * const SkMaskFilter , src : * const SkRect) -> SkRect ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkMaskFilter@@SA?AV?$sk_sp@VSkMaskFilter@@@@PEBX_KPEBUSkDeserialProcs@@@Z"] pub fn SkMaskFilter_Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkMaskFilter > ; } impl SkMaskFilter { # [inline] pub unsafe fn MakeBlur (style : SkBlurStyle , sigma : SkScalar , respectCTM : bool) -> sk_sp < SkMaskFilter > { SkMaskFilter_MakeBlur (style , sigma , respectCTM) } # [inline] pub unsafe fn approximateFilteredBounds (& self , src : * const SkRect) -> SkRect { SkMaskFilter_approximateFilteredBounds (self , src) } # [inline] pub unsafe fn Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkMaskFilter > { SkMaskFilter_Deserialize (data , size , procs) } } # [repr (C)] # [derive (Debug)] pub struct SkPathBuilder { pub fPts : SkTDArray < SkPoint > , pub fVerbs : SkTDArray < u8 > , pub fConicWeights : SkTDArray < SkScalar > , pub fFillType : SkPathFillType , pub fIsVolatile : bool , pub fSegmentMask : :: std :: os :: raw :: c_uint , pub fLastMovePoint : SkPoint , pub fLastMoveIndex : :: std :: os :: raw :: c_int , pub fNeedsMoveVerb : bool , pub fIsA : SkPathBuilder_IsA , pub fIsAStart : :: std :: os :: raw :: c_int , pub fIsACCW : bool , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathBuilder_ArcSize { Small = 0 , Large = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathBuilder_IsA { kIsA_JustMoves = 0 , kIsA_MoreThanMoves = 1 , kIsA_Oval = 2 , kIsA_RRect = 3 , } # [test] fn bindgen_test_layout_SkPathBuilder () { assert_eq ! (:: core :: mem :: size_of :: < SkPathBuilder > () , 88usize , concat ! ("Size of: " , stringify ! (SkPathBuilder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPathBuilder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPathBuilder))) ; fn test_field_fPts () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPts) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fPts))) ; } test_field_fPts () ; fn test_field_fVerbs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVerbs) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fVerbs))) ; } test_field_fVerbs () ; fn test_field_fConicWeights () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fConicWeights) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fConicWeights))) ; } test_field_fConicWeights () ; fn test_field_fFillType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFillType) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fFillType))) ; } test_field_fFillType () ; fn test_field_fIsVolatile () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsVolatile) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fIsVolatile))) ; } test_field_fIsVolatile () ; fn test_field_fSegmentMask () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSegmentMask) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fSegmentMask))) ; } test_field_fSegmentMask () ; fn test_field_fLastMovePoint () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastMovePoint) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fLastMovePoint))) ; } test_field_fLastMovePoint () ; fn test_field_fLastMoveIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastMoveIndex) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fLastMoveIndex))) ; } test_field_fLastMoveIndex () ; fn test_field_fNeedsMoveVerb () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNeedsMoveVerb) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fNeedsMoveVerb))) ; } test_field_fNeedsMoveVerb () ; fn test_field_fIsA () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsA) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fIsA))) ; } test_field_fIsA () ; fn test_field_fIsAStart () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsAStart) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fIsAStart))) ; } test_field_fIsAStart () ; fn test_field_fIsACCW () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsACCW) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (SkPathBuilder) , "::" , stringify ! (fIsACCW))) ; } test_field_fIsACCW () ; } extern "C" { # [link_name = "\u{1}?computeBounds@SkPathBuilder@@QEBA?AUSkRect@@XZ"] pub fn SkPathBuilder_computeBounds (this : * const SkPathBuilder) -> SkRect ; } extern "C" { # [link_name = "\u{1}?snapshot@SkPathBuilder@@QEBA?AVSkPath@@XZ"] pub fn SkPathBuilder_snapshot (this : * const SkPathBuilder) -> SkPath ; } extern "C" { # [link_name = "\u{1}?detach@SkPathBuilder@@QEAA?AVSkPath@@XZ"] pub fn SkPathBuilder_detach (this : * mut SkPathBuilder) -> SkPath ; } extern "C" { # [link_name = "\u{1}?reset@SkPathBuilder@@QEAAAEAV1@XZ"] pub fn SkPathBuilder_reset (this : * mut SkPathBuilder) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?moveTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@@Z"] pub fn SkPathBuilder_moveTo (this : * mut SkPathBuilder , pt : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?lineTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@@Z"] pub fn SkPathBuilder_lineTo (this : * mut SkPathBuilder , pt : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?quadTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@0@Z"] pub fn SkPathBuilder_quadTo (this : * mut SkPathBuilder , pt1 : SkPoint , pt2 : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?conicTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@0M@Z"] pub fn SkPathBuilder_conicTo (this : * mut SkPathBuilder , pt1 : SkPoint , pt2 : SkPoint , w : SkScalar) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?cubicTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@00@Z"] pub fn SkPathBuilder_cubicTo (this : * mut SkPathBuilder , pt1 : SkPoint , pt2 : SkPoint , pt3 : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?close@SkPathBuilder@@QEAAAEAV1@XZ"] pub fn SkPathBuilder_close (this : * mut SkPathBuilder) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?polylineTo@SkPathBuilder@@QEAAAEAV1@QEBUSkPoint@@H@Z"] pub fn SkPathBuilder_polylineTo (this : * mut SkPathBuilder , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?rLineTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@@Z"] pub fn SkPathBuilder_rLineTo (this : * mut SkPathBuilder , pt : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?rQuadTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@0@Z"] pub fn SkPathBuilder_rQuadTo (this : * mut SkPathBuilder , pt1 : SkPoint , pt2 : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?rConicTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@0M@Z"] pub fn SkPathBuilder_rConicTo (this : * mut SkPathBuilder , p1 : SkPoint , p2 : SkPoint , w : SkScalar) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?rCubicTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@00@Z"] pub fn SkPathBuilder_rCubicTo (this : * mut SkPathBuilder , pt1 : SkPoint , pt2 : SkPoint , pt3 : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPathBuilder@@QEAAAEAV1@AEBUSkRect@@MM_N@Z"] pub fn SkPathBuilder_arcTo (this : * mut SkPathBuilder , oval : * const SkRect , startAngleDeg : SkScalar , sweepAngleDeg : SkScalar , forceMoveTo : bool) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@0M@Z"] pub fn SkPathBuilder_arcTo1 (this : * mut SkPathBuilder , p1 : SkPoint , p2 : SkPoint , radius : SkScalar) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?arcTo@SkPathBuilder@@QEAAAEAV1@USkPoint@@MW4ArcSize@1@W4SkPathDirection@@0@Z"] pub fn SkPathBuilder_arcTo2 (this : * mut SkPathBuilder , r : SkPoint , xAxisRotate : SkScalar , largeArc : SkPathBuilder_ArcSize , sweep : SkPathDirection , xy : SkPoint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addArc@SkPathBuilder@@QEAAAEAV1@AEBUSkRect@@MM@Z"] pub fn SkPathBuilder_addArc (this : * mut SkPathBuilder , oval : * const SkRect , startAngleDeg : SkScalar , sweepAngleDeg : SkScalar) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addRect@SkPathBuilder@@QEAAAEAV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPathBuilder_addRect (this : * mut SkPathBuilder , arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addOval@SkPathBuilder@@QEAAAEAV1@AEBUSkRect@@W4SkPathDirection@@I@Z"] pub fn SkPathBuilder_addOval (this : * mut SkPathBuilder , arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addRRect@SkPathBuilder@@QEAAAEAV1@AEBVSkRRect@@W4SkPathDirection@@I@Z"] pub fn SkPathBuilder_addRRect (this : * mut SkPathBuilder , arg1 : * const SkRRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addCircle@SkPathBuilder@@QEAAAEAV1@MMMW4SkPathDirection@@@Z"] pub fn SkPathBuilder_addCircle (this : * mut SkPathBuilder , center_x : SkScalar , center_y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addPolygon@SkPathBuilder@@QEAAAEAV1@QEBUSkPoint@@H_N@Z"] pub fn SkPathBuilder_addPolygon (this : * mut SkPathBuilder , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , isClosed : bool) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?addPath@SkPathBuilder@@QEAAAEAV1@AEBVSkPath@@@Z"] pub fn SkPathBuilder_addPath (this : * mut SkPathBuilder , arg1 : * const SkPath) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}?incReserve@SkPathBuilder@@QEAAXHH@Z"] pub fn SkPathBuilder_incReserve (this : * mut SkPathBuilder , extraPtCount : :: std :: os :: raw :: c_int , extraVerbCount : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?offset@SkPathBuilder@@QEAAAEAV1@MM@Z"] pub fn SkPathBuilder_offset (this : * mut SkPathBuilder , dx : SkScalar , dy : SkScalar) -> * mut SkPathBuilder ; } extern "C" { # [link_name = "\u{1}??0SkPathBuilder@@QEAA@XZ"] pub fn SkPathBuilder_SkPathBuilder (this : * mut SkPathBuilder) ; } extern "C" { # [link_name = "\u{1}??0SkPathBuilder@@QEAA@W4SkPathFillType@@@Z"] pub fn SkPathBuilder_SkPathBuilder1 (this : * mut SkPathBuilder , arg1 : SkPathFillType) ; } extern "C" { # [link_name = "\u{1}??0SkPathBuilder@@QEAA@AEBVSkPath@@@Z"] pub fn SkPathBuilder_SkPathBuilder2 (this : * mut SkPathBuilder , arg1 : * const SkPath) ; } impl SkPathBuilder { # [inline] pub unsafe fn computeBounds (& self) -> SkRect { SkPathBuilder_computeBounds (self) } # [inline] pub unsafe fn snapshot (& self) -> SkPath { SkPathBuilder_snapshot (self) } # [inline] pub unsafe fn detach (& mut self) -> SkPath { SkPathBuilder_detach (self) } # [inline] pub unsafe fn reset (& mut self) -> * mut SkPathBuilder { SkPathBuilder_reset (self) } # [inline] pub unsafe fn moveTo (& mut self , pt : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_moveTo (self , pt) } # [inline] pub unsafe fn lineTo (& mut self , pt : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_lineTo (self , pt) } # [inline] pub unsafe fn quadTo (& mut self , pt1 : SkPoint , pt2 : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_quadTo (self , pt1 , pt2) } # [inline] pub unsafe fn conicTo (& mut self , pt1 : SkPoint , pt2 : SkPoint , w : SkScalar) -> * mut SkPathBuilder { SkPathBuilder_conicTo (self , pt1 , pt2 , w) } # [inline] pub unsafe fn cubicTo (& mut self , pt1 : SkPoint , pt2 : SkPoint , pt3 : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_cubicTo (self , pt1 , pt2 , pt3) } # [inline] pub unsafe fn close (& mut self) -> * mut SkPathBuilder { SkPathBuilder_close (self) } # [inline] pub unsafe fn polylineTo (& mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int) -> * mut SkPathBuilder { SkPathBuilder_polylineTo (self , pts , count) } # [inline] pub unsafe fn rLineTo (& mut self , pt : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_rLineTo (self , pt) } # [inline] pub unsafe fn rQuadTo (& mut self , pt1 : SkPoint , pt2 : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_rQuadTo (self , pt1 , pt2) } # [inline] pub unsafe fn rConicTo (& mut self , p1 : SkPoint , p2 : SkPoint , w : SkScalar) -> * mut SkPathBuilder { SkPathBuilder_rConicTo (self , p1 , p2 , w) } # [inline] pub unsafe fn rCubicTo (& mut self , pt1 : SkPoint , pt2 : SkPoint , pt3 : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_rCubicTo (self , pt1 , pt2 , pt3) } # [inline] pub unsafe fn arcTo (& mut self , oval : * const SkRect , startAngleDeg : SkScalar , sweepAngleDeg : SkScalar , forceMoveTo : bool) -> * mut SkPathBuilder { SkPathBuilder_arcTo (self , oval , startAngleDeg , sweepAngleDeg , forceMoveTo) } # [inline] pub unsafe fn arcTo1 (& mut self , p1 : SkPoint , p2 : SkPoint , radius : SkScalar) -> * mut SkPathBuilder { SkPathBuilder_arcTo1 (self , p1 , p2 , radius) } # [inline] pub unsafe fn arcTo2 (& mut self , r : SkPoint , xAxisRotate : SkScalar , largeArc : SkPathBuilder_ArcSize , sweep : SkPathDirection , xy : SkPoint) -> * mut SkPathBuilder { SkPathBuilder_arcTo2 (self , r , xAxisRotate , largeArc , sweep , xy) } # [inline] pub unsafe fn addArc (& mut self , oval : * const SkRect , startAngleDeg : SkScalar , sweepAngleDeg : SkScalar) -> * mut SkPathBuilder { SkPathBuilder_addArc (self , oval , startAngleDeg , sweepAngleDeg) } # [inline] pub unsafe fn addRect (& mut self , arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder { SkPathBuilder_addRect (self , arg1 , arg2 , startIndex) } # [inline] pub unsafe fn addOval (& mut self , arg1 : * const SkRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder { SkPathBuilder_addOval (self , arg1 , arg2 , startIndex) } # [inline] pub unsafe fn addRRect (& mut self , arg1 : * const SkRRect , arg2 : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) -> * mut SkPathBuilder { SkPathBuilder_addRRect (self , arg1 , arg2 , startIndex) } # [inline] pub unsafe fn addCircle (& mut self , center_x : SkScalar , center_y : SkScalar , radius : SkScalar , dir : SkPathDirection) -> * mut SkPathBuilder { SkPathBuilder_addCircle (self , center_x , center_y , radius , dir) } # [inline] pub unsafe fn addPolygon (& mut self , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , isClosed : bool) -> * mut SkPathBuilder { SkPathBuilder_addPolygon (self , pts , count , isClosed) } # [inline] pub unsafe fn addPath (& mut self , arg1 : * const SkPath) -> * mut SkPathBuilder { SkPathBuilder_addPath (self , arg1) } # [inline] pub unsafe fn incReserve (& mut self , extraPtCount : :: std :: os :: raw :: c_int , extraVerbCount : :: std :: os :: raw :: c_int) { SkPathBuilder_incReserve (self , extraPtCount , extraVerbCount) } # [inline] pub unsafe fn offset (& mut self , dx : SkScalar , dy : SkScalar) -> * mut SkPathBuilder { SkPathBuilder_offset (self , dx , dy) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPathBuilder_SkPathBuilder (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (arg1 : SkPathFillType) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPathBuilder_SkPathBuilder1 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (arg1 : * const SkPath) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPathBuilder_SkPathBuilder2 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkPathMeasure { pub fIter : SkContourMeasureIter , pub fContour : sk_sp < SkContourMeasure > , } pub const SkPathMeasure_MatrixFlags_kGetPosition_MatrixFlag : SkPathMeasure_MatrixFlags = 1 ; pub const SkPathMeasure_MatrixFlags_kGetTangent_MatrixFlag : SkPathMeasure_MatrixFlags = 2 ; pub const SkPathMeasure_MatrixFlags_kGetPosAndTan_MatrixFlag : SkPathMeasure_MatrixFlags = 3 ; pub type SkPathMeasure_MatrixFlags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkPathMeasure () { assert_eq ! (:: core :: mem :: size_of :: < SkPathMeasure > () , 16usize , concat ! ("Size of: " , stringify ! (SkPathMeasure))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPathMeasure > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPathMeasure))) ; fn test_field_fIter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathMeasure > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIter) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPathMeasure) , "::" , stringify ! (fIter))) ; } test_field_fIter () ; fn test_field_fContour () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathMeasure > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fContour) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPathMeasure) , "::" , stringify ! (fContour))) ; } test_field_fContour () ; } extern "C" { # [link_name = "\u{1}?setPath@SkPathMeasure@@QEAAXPEBVSkPath@@_N@Z"] pub fn SkPathMeasure_setPath (this : * mut SkPathMeasure , arg1 : * const SkPath , forceClosed : bool) ; } extern "C" { # [link_name = "\u{1}?getLength@SkPathMeasure@@QEAAMXZ"] pub fn SkPathMeasure_getLength (this : * mut SkPathMeasure) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?getPosTan@SkPathMeasure@@QEAA_NMPEAUSkPoint@@0@Z"] pub fn SkPathMeasure_getPosTan (this : * mut SkPathMeasure , distance : SkScalar , position : * mut SkPoint , tangent : * mut SkVector) -> bool ; } extern "C" { # [link_name = "\u{1}?getMatrix@SkPathMeasure@@QEAA_NMPEAVSkMatrix@@W4MatrixFlags@1@@Z"] pub fn SkPathMeasure_getMatrix (this : * mut SkPathMeasure , distance : SkScalar , matrix : * mut SkMatrix , flags : SkPathMeasure_MatrixFlags) -> bool ; } extern "C" { # [link_name = "\u{1}?getSegment@SkPathMeasure@@QEAA_NMMPEAVSkPath@@_N@Z"] pub fn SkPathMeasure_getSegment (this : * mut SkPathMeasure , startD : SkScalar , stopD : SkScalar , dst : * mut SkPath , startWithMoveTo : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?isClosed@SkPathMeasure@@QEAA_NXZ"] pub fn SkPathMeasure_isClosed (this : * mut SkPathMeasure) -> bool ; } extern "C" { # [link_name = "\u{1}?nextContour@SkPathMeasure@@QEAA_NXZ"] pub fn SkPathMeasure_nextContour (this : * mut SkPathMeasure) -> bool ; } extern "C" { # [link_name = "\u{1}??0SkPathMeasure@@QEAA@XZ"] pub fn SkPathMeasure_SkPathMeasure (this : * mut SkPathMeasure) ; } extern "C" { # [link_name = "\u{1}??0SkPathMeasure@@QEAA@AEBVSkPath@@_NM@Z"] pub fn SkPathMeasure_SkPathMeasure1 (this : * mut SkPathMeasure , path : * const SkPath , forceClosed : bool , resScale : SkScalar) ; } impl SkPathMeasure { # [inline] pub unsafe fn setPath (& mut self , arg1 : * const SkPath , forceClosed : bool) { SkPathMeasure_setPath (self , arg1 , forceClosed) } # [inline] pub unsafe fn getLength (& mut self) -> SkScalar { SkPathMeasure_getLength (self) } # [inline] pub unsafe fn getPosTan (& mut self , distance : SkScalar , position : * mut SkPoint , tangent : * mut SkVector) -> bool { SkPathMeasure_getPosTan (self , distance , position , tangent) } # [inline] pub unsafe fn getMatrix (& mut self , distance : SkScalar , matrix : * mut SkMatrix , flags : SkPathMeasure_MatrixFlags) -> bool { SkPathMeasure_getMatrix (self , distance , matrix , flags) } # [inline] pub unsafe fn getSegment (& mut self , startD : SkScalar , stopD : SkScalar , dst : * mut SkPath , startWithMoveTo : bool) -> bool { SkPathMeasure_getSegment (self , startD , stopD , dst , startWithMoveTo) } # [inline] pub unsafe fn isClosed (& mut self) -> bool { SkPathMeasure_isClosed (self) } # [inline] pub unsafe fn nextContour (& mut self) -> bool { SkPathMeasure_nextContour (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPathMeasure_SkPathMeasure (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (path : * const SkPath , forceClosed : bool , resScale : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPathMeasure_SkPathMeasure1 (__bindgen_tmp . as_mut_ptr () , path , forceClosed , resScale) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkPicture { pub _bindgen_opaque_blob : [u64 ; 3usize] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkPicture_AbortCallback { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkPicture_AbortCallback () { assert_eq ! (:: core :: mem :: size_of :: < SkPicture_AbortCallback > () , 8usize , concat ! ("Size of: " , stringify ! (SkPicture_AbortCallback))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPicture_AbortCallback > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPicture_AbortCallback))) ; } # [test] fn bindgen_test_layout_SkPicture () { assert_eq ! (:: core :: mem :: size_of :: < SkPicture > () , 24usize , concat ! ("Size of: " , stringify ! (SkPicture))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPicture > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPicture))) ; } extern "C" { # [link_name = "\u{1}?MakeFromStream@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEAVSkStream@@PEBUSkDeserialProcs@@@Z"] pub fn SkPicture_MakeFromStream (stream : * mut SkStream , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBVSkData@@PEBUSkDeserialProcs@@@Z"] pub fn SkPicture_MakeFromData (data : * const SkData , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?MakeFromData@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@PEBX_KPEBUSkDeserialProcs@@@Z"] pub fn SkPicture_MakeFromData1 (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?serialize@SkPicture@@QEBA?AV?$sk_sp@VSkData@@@@PEBUSkSerialProcs@@@Z"] pub fn SkPicture_serialize (this : * const SkPicture , procs : * const SkSerialProcs) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?serialize@SkPicture@@QEBAXPEAVSkWStream@@PEBUSkSerialProcs@@@Z"] pub fn SkPicture_serialize1 (this : * const SkPicture , stream : * mut SkWStream , procs : * const SkSerialProcs) ; } extern "C" { # [link_name = "\u{1}?MakePlaceholder@SkPicture@@SA?AV?$sk_sp@VSkPicture@@@@USkRect@@@Z"] pub fn SkPicture_MakePlaceholder (cull : SkRect) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?makeShader@SkPicture@@QEBA?AV?$sk_sp@VSkShader@@@@W4SkTileMode@@0W4SkFilterMode@@PEBVSkMatrix@@PEBUSkRect@@@Z"] pub fn SkPicture_makeShader (this : * const SkPicture , tmx : SkTileMode , tmy : SkTileMode , mode : SkFilterMode , localMatrix : * const SkMatrix , tileRect : * const SkRect) -> sk_sp < SkShader > ; } impl SkPicture { # [inline] pub unsafe fn MakeFromStream (stream : * mut SkStream , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > { SkPicture_MakeFromStream (stream , procs) } # [inline] pub unsafe fn MakeFromData (data : * const SkData , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > { SkPicture_MakeFromData (data , procs) } # [inline] pub unsafe fn MakeFromData1 (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkPicture > { SkPicture_MakeFromData1 (data , size , procs) } # [inline] pub unsafe fn serialize (& self , procs : * const SkSerialProcs) -> sk_sp < SkData > { SkPicture_serialize (self , procs) } # [inline] pub unsafe fn serialize1 (& self , stream : * mut SkWStream , procs : * const SkSerialProcs) { SkPicture_serialize1 (self , stream , procs) } # [inline] pub unsafe fn MakePlaceholder (cull : SkRect) -> sk_sp < SkPicture > { SkPicture_MakePlaceholder (cull) } # [inline] pub unsafe fn makeShader (& self , tmx : SkTileMode , tmy : SkTileMode , mode : SkFilterMode , localMatrix : * const SkMatrix , tileRect : * const SkRect) -> sk_sp < SkShader > { SkPicture_makeShader (self , tmx , tmy , mode , localMatrix , tileRect) } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkBBoxHierarchy { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkBBoxHierarchy_Metadata { pub isDraw : bool , } # [test] fn bindgen_test_layout_SkBBoxHierarchy_Metadata () { assert_eq ! (:: core :: mem :: size_of :: < SkBBoxHierarchy_Metadata > () , 1usize , concat ! ("Size of: " , stringify ! (SkBBoxHierarchy_Metadata))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBBoxHierarchy_Metadata > () , 1usize , concat ! ("Alignment of " , stringify ! (SkBBoxHierarchy_Metadata))) ; fn test_field_isDraw () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkBBoxHierarchy_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . isDraw) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkBBoxHierarchy_Metadata) , "::" , stringify ! (isDraw))) ; } test_field_isDraw () ; } # [test] fn bindgen_test_layout_SkBBoxHierarchy () { assert_eq ! (:: core :: mem :: size_of :: < SkBBoxHierarchy > () , 16usize , concat ! ("Size of: " , stringify ! (SkBBoxHierarchy))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBBoxHierarchy > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBBoxHierarchy))) ; } extern "C" { # [link_name = "\u{1}?insert@SkBBoxHierarchy@@UEAAXQEBUSkRect@@QEBUMetadata@1@H@Z"] pub fn SkBBoxHierarchy_insert1 (this : * mut :: core :: ffi :: c_void , arg1 : * const SkRect , arg2 : * const SkBBoxHierarchy_Metadata , N : :: std :: os :: raw :: c_int) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkBBHFactory { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkBBHFactory () { assert_eq ! (:: core :: mem :: size_of :: < SkBBHFactory > () , 8usize , concat ! ("Size of: " , stringify ! (SkBBHFactory))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBBHFactory > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBBHFactory))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRecord { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRecorder { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct SkPictureRecorder { pub fActivelyRecording : bool , pub fCullRect : SkRect , pub fBBH : sk_sp < SkBBoxHierarchy > , pub fRecorder : u64 , pub fRecord : sk_sp < SkRecord > , } pub type SkPictureRecorder_FinishFlags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkPictureRecorder () { assert_eq ! (:: core :: mem :: size_of :: < SkPictureRecorder > () , 48usize , concat ! ("Size of: " , stringify ! (SkPictureRecorder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPictureRecorder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPictureRecorder))) ; fn test_field_fActivelyRecording () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPictureRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fActivelyRecording) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPictureRecorder) , "::" , stringify ! (fActivelyRecording))) ; } test_field_fActivelyRecording () ; fn test_field_fCullRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPictureRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCullRect) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkPictureRecorder) , "::" , stringify ! (fCullRect))) ; } test_field_fCullRect () ; fn test_field_fBBH () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPictureRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBBH) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPictureRecorder) , "::" , stringify ! (fBBH))) ; } test_field_fBBH () ; fn test_field_fRecorder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPictureRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecorder) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPictureRecorder) , "::" , stringify ! (fRecorder))) ; } test_field_fRecorder () ; fn test_field_fRecord () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPictureRecorder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRecord) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkPictureRecorder) , "::" , stringify ! (fRecord))) ; } test_field_fRecord () ; } extern "C" { # [link_name = "\u{1}?beginRecording@SkPictureRecorder@@QEAAPEAVSkCanvas@@AEBUSkRect@@V?$sk_sp@VSkBBoxHierarchy@@@@@Z"] pub fn SkPictureRecorder_beginRecording (this : * mut SkPictureRecorder , bounds : * const SkRect , bbh : sk_sp < SkBBoxHierarchy >) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?beginRecording@SkPictureRecorder@@QEAAPEAVSkCanvas@@AEBUSkRect@@PEAVSkBBHFactory@@@Z"] pub fn SkPictureRecorder_beginRecording1 (this : * mut SkPictureRecorder , bounds : * const SkRect , bbhFactory : * mut SkBBHFactory) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?getRecordingCanvas@SkPictureRecorder@@QEAAPEAVSkCanvas@@XZ"] pub fn SkPictureRecorder_getRecordingCanvas (this : * mut SkPictureRecorder) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?finishRecordingAsPicture@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkPicture@@@@XZ"] pub fn SkPictureRecorder_finishRecordingAsPicture (this : * mut SkPictureRecorder) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?finishRecordingAsPictureWithCull@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkPicture@@@@AEBUSkRect@@@Z"] pub fn SkPictureRecorder_finishRecordingAsPictureWithCull (this : * mut SkPictureRecorder , cullRect : * const SkRect) -> sk_sp < SkPicture > ; } extern "C" { # [link_name = "\u{1}?finishRecordingAsDrawable@SkPictureRecorder@@QEAA?AV?$sk_sp@VSkDrawable@@@@XZ"] pub fn SkPictureRecorder_finishRecordingAsDrawable (this : * mut SkPictureRecorder) -> sk_sp < SkDrawable > ; } extern "C" { # [link_name = "\u{1}??0SkPictureRecorder@@QEAA@XZ"] pub fn SkPictureRecorder_SkPictureRecorder (this : * mut SkPictureRecorder) ; } impl SkPictureRecorder { # [inline] pub unsafe fn beginRecording (& mut self , bounds : * const SkRect , bbh : sk_sp < SkBBoxHierarchy >) -> * mut SkCanvas { SkPictureRecorder_beginRecording (self , bounds , bbh) } # [inline] pub unsafe fn beginRecording1 (& mut self , bounds : * const SkRect , bbhFactory : * mut SkBBHFactory) -> * mut SkCanvas { SkPictureRecorder_beginRecording1 (self , bounds , bbhFactory) } # [inline] pub unsafe fn getRecordingCanvas (& mut self) -> * mut SkCanvas { SkPictureRecorder_getRecordingCanvas (self) } # [inline] pub unsafe fn finishRecordingAsPicture (& mut self) -> sk_sp < SkPicture > { SkPictureRecorder_finishRecordingAsPicture (self) } # [inline] pub unsafe fn finishRecordingAsPictureWithCull (& mut self , cullRect : * const SkRect) -> sk_sp < SkPicture > { SkPictureRecorder_finishRecordingAsPictureWithCull (self , cullRect) } # [inline] pub unsafe fn finishRecordingAsDrawable (& mut self) -> sk_sp < SkDrawable > { SkPictureRecorder_finishRecordingAsDrawable (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPictureRecorder_SkPictureRecorder (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkMutex { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_SkMutex () { assert_eq ! (:: core :: mem :: size_of :: < SkMutex > () , 16usize , concat ! ("Size of: " , stringify ! (SkMutex))) ; assert_eq ! (:: core :: mem :: align_of :: < SkMutex > () , 8usize , concat ! ("Alignment of " , stringify ! (SkMutex))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkIDChangeListener { pub _bindgen_opaque_blob : [u64 ; 3usize] , } # [repr (C)] # [derive (Debug)] pub struct SkIDChangeListener_List { pub fMutex : SkMutex , pub fListeners : SkTDArray < * mut SkIDChangeListener > , } # [test] fn bindgen_test_layout_SkIDChangeListener_List () { assert_eq ! (:: core :: mem :: size_of :: < SkIDChangeListener_List > () , 32usize , concat ! ("Size of: " , stringify ! (SkIDChangeListener_List))) ; assert_eq ! (:: core :: mem :: align_of :: < SkIDChangeListener_List > () , 8usize , concat ! ("Alignment of " , stringify ! (SkIDChangeListener_List))) ; fn test_field_fMutex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIDChangeListener_List > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMutex) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkIDChangeListener_List) , "::" , stringify ! (fMutex))) ; } test_field_fMutex () ; fn test_field_fListeners () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkIDChangeListener_List > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fListeners) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkIDChangeListener_List) , "::" , stringify ! (fListeners))) ; } test_field_fListeners () ; } extern "C" { # [link_name = "\u{1}?add@List@SkIDChangeListener@@QEAAXV?$sk_sp@VSkIDChangeListener@@@@@Z"] pub fn SkIDChangeListener_List_add (this : * mut SkIDChangeListener_List , listener : sk_sp < SkIDChangeListener >) ; } extern "C" { # [link_name = "\u{1}?count@List@SkIDChangeListener@@QEBAHXZ"] pub fn SkIDChangeListener_List_count (this : * const SkIDChangeListener_List) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?changed@List@SkIDChangeListener@@QEAAXXZ"] pub fn SkIDChangeListener_List_changed (this : * mut SkIDChangeListener_List) ; } extern "C" { # [link_name = "\u{1}?reset@List@SkIDChangeListener@@QEAAXXZ"] pub fn SkIDChangeListener_List_reset (this : * mut SkIDChangeListener_List) ; } extern "C" { # [link_name = "\u{1}??0List@SkIDChangeListener@@QEAA@XZ"] pub fn SkIDChangeListener_List_List (this : * mut SkIDChangeListener_List) ; } impl SkIDChangeListener_List { # [inline] pub unsafe fn add (& mut self , listener : sk_sp < SkIDChangeListener >) { SkIDChangeListener_List_add (self , listener) } # [inline] pub unsafe fn count (& self) -> :: std :: os :: raw :: c_int { SkIDChangeListener_List_count (self) } # [inline] pub unsafe fn changed (& mut self) { SkIDChangeListener_List_changed (self) } # [inline] pub unsafe fn reset (& mut self) { SkIDChangeListener_List_reset (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkIDChangeListener_List_List (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [test] fn bindgen_test_layout_SkIDChangeListener () { assert_eq ! (:: core :: mem :: size_of :: < SkIDChangeListener > () , 24usize , concat ! ("Size of: " , stringify ! (SkIDChangeListener))) ; assert_eq ! (:: core :: mem :: align_of :: < SkIDChangeListener > () , 8usize , concat ! ("Alignment of " , stringify ! (SkIDChangeListener))) ; } extern "C" { # [link_name = "\u{1}??0SkIDChangeListener@@QEAA@XZ"] pub fn SkIDChangeListener_SkIDChangeListener (this : * mut SkIDChangeListener) ; } impl SkIDChangeListener { # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkIDChangeListener_SkIDChangeListener (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkPixelRef { pub _bindgen_opaque_blob : [u64 ; 11usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPixelRef_Mutability { kMutable = 0 , kTemporarilyImmutable = 1 , kImmutable = 2 , } pub type SkPixelRef_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkPixelRef () { assert_eq ! (:: core :: mem :: size_of :: < SkPixelRef > () , 88usize , concat ! ("Size of: " , stringify ! (SkPixelRef))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPixelRef > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPixelRef))) ; } extern "C" { # [link_name = "\u{1}?getGenerationID@SkPixelRef@@QEBAIXZ"] pub fn SkPixelRef_getGenerationID (this : * const SkPixelRef) -> u32 ; } extern "C" { # [link_name = "\u{1}?notifyPixelsChanged@SkPixelRef@@QEAAXXZ"] pub fn SkPixelRef_notifyPixelsChanged (this : * mut SkPixelRef) ; } extern "C" { # [link_name = "\u{1}?setImmutable@SkPixelRef@@QEAAXXZ"] pub fn SkPixelRef_setImmutable (this : * mut SkPixelRef) ; } extern "C" { # [link_name = "\u{1}?addGenIDChangeListener@SkPixelRef@@QEAAXV?$sk_sp@VSkIDChangeListener@@@@@Z"] pub fn SkPixelRef_addGenIDChangeListener (this : * mut SkPixelRef , listener : sk_sp < SkIDChangeListener >) ; } extern "C" { # [link_name = "\u{1}?android_only_reset@SkPixelRef@@IEAAXHH_K@Z"] pub fn SkPixelRef_android_only_reset (this : * mut SkPixelRef , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , rowBytes : usize) ; } extern "C" { # [link_name = "\u{1}??0SkPixelRef@@QEAA@HHPEAX_K@Z"] pub fn SkPixelRef_SkPixelRef (this : * mut SkPixelRef , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , addr : * mut :: core :: ffi :: c_void , rowBytes : usize) ; } impl SkPixelRef { # [inline] pub unsafe fn getGenerationID (& self) -> u32 { SkPixelRef_getGenerationID (self) } # [inline] pub unsafe fn notifyPixelsChanged (& mut self) { SkPixelRef_notifyPixelsChanged (self) } # [inline] pub unsafe fn setImmutable (& mut self) { SkPixelRef_setImmutable (self) } # [inline] pub unsafe fn addGenIDChangeListener (& mut self , listener : sk_sp < SkIDChangeListener >) { SkPixelRef_addGenIDChangeListener (self , listener) } # [inline] pub unsafe fn android_only_reset (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , rowBytes : usize) { SkPixelRef_android_only_reset (self , width , height , rowBytes) } # [inline] pub unsafe fn new (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , addr : * mut :: core :: ffi :: c_void , rowBytes : usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPixelRef_SkPixelRef (__bindgen_tmp . as_mut_ptr () , width , height , addr , rowBytes) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPoint3 { pub fX : SkScalar , pub fY : SkScalar , pub fZ : SkScalar , } # [test] fn bindgen_test_layout_SkPoint3 () { assert_eq ! (:: core :: mem :: size_of :: < SkPoint3 > () , 12usize , concat ! ("Size of: " , stringify ! (SkPoint3))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPoint3 > () , 4usize , concat ! ("Alignment of " , stringify ! (SkPoint3))) ; fn test_field_fX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPoint3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fX) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPoint3) , "::" , stringify ! (fX))) ; } test_field_fX () ; fn test_field_fY () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPoint3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fY) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkPoint3) , "::" , stringify ! (fY))) ; } test_field_fY () ; fn test_field_fZ () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPoint3 > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fZ) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPoint3) , "::" , stringify ! (fZ))) ; } test_field_fZ () ; } extern "C" { # [link_name = "\u{1}?Length@SkPoint3@@SAMMMM@Z"] pub fn SkPoint3_Length (x : SkScalar , y : SkScalar , z : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?normalize@SkPoint3@@QEAA_NXZ"] pub fn SkPoint3_normalize (this : * mut SkPoint3) -> bool ; } impl SkPoint3 { # [inline] pub unsafe fn Length (x : SkScalar , y : SkScalar , z : SkScalar) -> SkScalar { SkPoint3_Length (x , y , z) } # [inline] pub unsafe fn normalize (& mut self) -> bool { SkPoint3_normalize (self) } } # [repr (C)] # [derive (Debug)] pub struct SkRegion { pub fBounds : SkIRect , pub fRunHead : * mut SkRegion_RunHead , } pub type SkRegion_RunType = i32 ; impl SkRegion_Op { pub const LastOp : SkRegion_Op = SkRegion_Op :: Replace ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkRegion_Op { Difference = 0 , Intersect = 1 , Union = 2 , XOR = 3 , ReverseDifference = 4 , Replace = 5 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRegion_Iterator { pub fRgn : * const SkRegion , pub fRuns : * const SkRegion_RunType , pub fRect : SkIRect , pub fDone : bool , } # [test] fn bindgen_test_layout_SkRegion_Iterator () { assert_eq ! (:: core :: mem :: size_of :: < SkRegion_Iterator > () , 40usize , concat ! ("Size of: " , stringify ! (SkRegion_Iterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRegion_Iterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRegion_Iterator))) ; fn test_field_fRgn () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Iterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRgn) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Iterator) , "::" , stringify ! (fRgn))) ; } test_field_fRgn () ; fn test_field_fRuns () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Iterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRuns) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Iterator) , "::" , stringify ! (fRuns))) ; } test_field_fRuns () ; fn test_field_fRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Iterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRect) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Iterator) , "::" , stringify ! (fRect))) ; } test_field_fRect () ; fn test_field_fDone () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Iterator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDone) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Iterator) , "::" , stringify ! (fDone))) ; } test_field_fDone () ; } extern "C" { # [link_name = "\u{1}?rewind@Iterator@SkRegion@@QEAA_NXZ"] pub fn SkRegion_Iterator_rewind (this : * mut SkRegion_Iterator) -> bool ; } extern "C" { # [link_name = "\u{1}?reset@Iterator@SkRegion@@QEAAXAEBV2@@Z"] pub fn SkRegion_Iterator_reset (this : * mut SkRegion_Iterator , region : * const SkRegion) ; } extern "C" { # [link_name = "\u{1}?next@Iterator@SkRegion@@QEAAXXZ"] pub fn SkRegion_Iterator_next (this : * mut SkRegion_Iterator) ; } extern "C" { # [link_name = "\u{1}??0Iterator@SkRegion@@QEAA@AEBV1@@Z"] pub fn SkRegion_Iterator_Iterator (this : * mut SkRegion_Iterator , region : * const SkRegion) ; } impl SkRegion_Iterator { # [inline] pub unsafe fn rewind (& mut self) -> bool { SkRegion_Iterator_rewind (self) } # [inline] pub unsafe fn reset (& mut self , region : * const SkRegion) { SkRegion_Iterator_reset (self , region) } # [inline] pub unsafe fn next (& mut self) { SkRegion_Iterator_next (self) } # [inline] pub unsafe fn new (region : * const SkRegion) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_Iterator_Iterator (__bindgen_tmp . as_mut_ptr () , region) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRegion_Cliperator { pub fIter : SkRegion_Iterator , pub fClip : SkIRect , pub fRect : SkIRect , pub fDone : bool , } # [test] fn bindgen_test_layout_SkRegion_Cliperator () { assert_eq ! (:: core :: mem :: size_of :: < SkRegion_Cliperator > () , 80usize , concat ! ("Size of: " , stringify ! (SkRegion_Cliperator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRegion_Cliperator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRegion_Cliperator))) ; fn test_field_fIter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Cliperator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIter) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Cliperator) , "::" , stringify ! (fIter))) ; } test_field_fIter () ; fn test_field_fClip () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Cliperator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fClip) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Cliperator) , "::" , stringify ! (fClip))) ; } test_field_fClip () ; fn test_field_fRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Cliperator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRect) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Cliperator) , "::" , stringify ! (fRect))) ; } test_field_fRect () ; fn test_field_fDone () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Cliperator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDone) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Cliperator) , "::" , stringify ! (fDone))) ; } test_field_fDone () ; } extern "C" { # [link_name = "\u{1}?next@Cliperator@SkRegion@@QEAAXXZ"] pub fn SkRegion_Cliperator_next (this : * mut SkRegion_Cliperator) ; } extern "C" { # [link_name = "\u{1}??0Cliperator@SkRegion@@QEAA@AEBV1@AEBUSkIRect@@@Z"] pub fn SkRegion_Cliperator_Cliperator (this : * mut SkRegion_Cliperator , region : * const SkRegion , clip : * const SkIRect) ; } impl SkRegion_Cliperator { # [inline] pub unsafe fn next (& mut self) { SkRegion_Cliperator_next (self) } # [inline] pub unsafe fn new (region : * const SkRegion , clip : * const SkIRect) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_Cliperator_Cliperator (__bindgen_tmp . as_mut_ptr () , region , clip) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRegion_Spanerator { pub fRuns : * const SkRegion_RunType , pub fLeft : :: std :: os :: raw :: c_int , pub fRight : :: std :: os :: raw :: c_int , pub fDone : bool , } # [test] fn bindgen_test_layout_SkRegion_Spanerator () { assert_eq ! (:: core :: mem :: size_of :: < SkRegion_Spanerator > () , 24usize , concat ! ("Size of: " , stringify ! (SkRegion_Spanerator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRegion_Spanerator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRegion_Spanerator))) ; fn test_field_fRuns () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Spanerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRuns) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Spanerator) , "::" , stringify ! (fRuns))) ; } test_field_fRuns () ; fn test_field_fLeft () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Spanerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeft) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Spanerator) , "::" , stringify ! (fLeft))) ; } test_field_fLeft () ; fn test_field_fRight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Spanerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRight) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Spanerator) , "::" , stringify ! (fRight))) ; } test_field_fRight () ; fn test_field_fDone () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion_Spanerator > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDone) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRegion_Spanerator) , "::" , stringify ! (fDone))) ; } test_field_fDone () ; } extern "C" { # [link_name = "\u{1}?next@Spanerator@SkRegion@@QEAA_NPEAH0@Z"] pub fn SkRegion_Spanerator_next (this : * mut SkRegion_Spanerator , left : * mut :: std :: os :: raw :: c_int , right : * mut :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}??0Spanerator@SkRegion@@QEAA@AEBV1@HHH@Z"] pub fn SkRegion_Spanerator_Spanerator (this : * mut SkRegion_Spanerator , region : * const SkRegion , y : :: std :: os :: raw :: c_int , left : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int) ; } impl SkRegion_Spanerator { # [inline] pub unsafe fn next (& mut self , left : * mut :: std :: os :: raw :: c_int , right : * mut :: std :: os :: raw :: c_int) -> bool { SkRegion_Spanerator_next (self , left , right) } # [inline] pub unsafe fn new (region : * const SkRegion , y : :: std :: os :: raw :: c_int , left : :: std :: os :: raw :: c_int , right : :: std :: os :: raw :: c_int) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_Spanerator_Spanerator (__bindgen_tmp . as_mut_ptr () , region , y , left , right) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRegion_RunHead { _unused : [u8 ; 0] , } pub const SkRegion_kOpCnt : :: std :: os :: raw :: c_int = 6 ; pub const SkRegion_kOpCount : :: std :: os :: raw :: c_int = 6 ; pub const SkRegion_kRectRegionRuns : :: std :: os :: raw :: c_int = 7 ; extern "C" { # [link_name = "\u{1}?kRectRunHeadPtr@SkRegion@@0QEAURunHead@1@EA"] pub static SkRegion_kRectRunHeadPtr : * mut SkRegion_RunHead ; } # [test] fn bindgen_test_layout_SkRegion () { assert_eq ! (:: core :: mem :: size_of :: < SkRegion > () , 24usize , concat ! ("Size of: " , stringify ! (SkRegion))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRegion > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRegion))) ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRegion) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fRunHead () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRegion > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRunHead) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRegion) , "::" , stringify ! (fRunHead))) ; } test_field_fRunHead () ; } extern "C" { # [link_name = "\u{1}?swap@SkRegion@@QEAAXAEAV1@@Z"] pub fn SkRegion_swap (this : * mut SkRegion , other : * mut SkRegion) ; } extern "C" { # [link_name = "\u{1}?computeRegionComplexity@SkRegion@@QEBAHXZ"] pub fn SkRegion_computeRegionComplexity (this : * const SkRegion) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getBoundaryPath@SkRegion@@QEBA_NPEAVSkPath@@@Z"] pub fn SkRegion_getBoundaryPath (this : * const SkRegion , path : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?setEmpty@SkRegion@@QEAA_NXZ"] pub fn SkRegion_setEmpty (this : * mut SkRegion) -> bool ; } extern "C" { # [link_name = "\u{1}?setRect@SkRegion@@QEAA_NAEBUSkIRect@@@Z"] pub fn SkRegion_setRect (this : * mut SkRegion , rect : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?setRects@SkRegion@@QEAA_NQEBUSkIRect@@H@Z"] pub fn SkRegion_setRects (this : * mut SkRegion , rects : * const SkIRect , count : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?setRegion@SkRegion@@QEAA_NAEBV1@@Z"] pub fn SkRegion_setRegion (this : * mut SkRegion , region : * const SkRegion) -> bool ; } extern "C" { # [link_name = "\u{1}?setPath@SkRegion@@QEAA_NAEBVSkPath@@AEBV1@@Z"] pub fn SkRegion_setPath (this : * mut SkRegion , path : * const SkPath , clip : * const SkRegion) -> bool ; } extern "C" { # [link_name = "\u{1}?intersects@SkRegion@@QEBA_NAEBUSkIRect@@@Z"] pub fn SkRegion_intersects (this : * const SkRegion , rect : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?intersects@SkRegion@@QEBA_NAEBV1@@Z"] pub fn SkRegion_intersects1 (this : * const SkRegion , other : * const SkRegion) -> bool ; } extern "C" { # [link_name = "\u{1}?contains@SkRegion@@QEBA_NHH@Z"] pub fn SkRegion_contains (this : * const SkRegion , x : i32 , y : i32) -> bool ; } extern "C" { # [link_name = "\u{1}?contains@SkRegion@@QEBA_NAEBUSkIRect@@@Z"] pub fn SkRegion_contains1 (this : * const SkRegion , other : * const SkIRect) -> bool ; } extern "C" { # [link_name = "\u{1}?contains@SkRegion@@QEBA_NAEBV1@@Z"] pub fn SkRegion_contains2 (this : * const SkRegion , other : * const SkRegion) -> bool ; } extern "C" { # [link_name = "\u{1}?translate@SkRegion@@QEBAXHHPEAV1@@Z"] pub fn SkRegion_translate (this : * const SkRegion , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int , dst : * mut SkRegion) ; } extern "C" { # [link_name = "\u{1}?op@SkRegion@@QEAA_NAEBUSkIRect@@AEBV1@W4Op@1@@Z"] pub fn SkRegion_op (this : * mut SkRegion , rect : * const SkIRect , rgn : * const SkRegion , op : SkRegion_Op) -> bool ; } extern "C" { # [link_name = "\u{1}?op@SkRegion@@QEAA_NAEBV1@AEBUSkIRect@@W4Op@1@@Z"] pub fn SkRegion_op1 (this : * mut SkRegion , rgn : * const SkRegion , rect : * const SkIRect , op : SkRegion_Op) -> bool ; } extern "C" { # [link_name = "\u{1}?op@SkRegion@@QEAA_NAEBV1@0W4Op@1@@Z"] pub fn SkRegion_op2 (this : * mut SkRegion , rgna : * const SkRegion , rgnb : * const SkRegion , op : SkRegion_Op) -> bool ; } extern "C" { # [link_name = "\u{1}?writeToMemory@SkRegion@@QEBA_KPEAX@Z"] pub fn SkRegion_writeToMemory (this : * const SkRegion , buffer : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?readFromMemory@SkRegion@@QEAA_KPEBX_K@Z"] pub fn SkRegion_readFromMemory (this : * mut SkRegion , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize ; } extern "C" { # [link_name = "\u{1}??0SkRegion@@QEAA@XZ"] pub fn SkRegion_SkRegion (this : * mut SkRegion) ; } extern "C" { # [link_name = "\u{1}??0SkRegion@@QEAA@AEBV0@@Z"] pub fn SkRegion_SkRegion1 (this : * mut SkRegion , region : * const SkRegion) ; } extern "C" { # [link_name = "\u{1}??0SkRegion@@QEAA@AEBUSkIRect@@@Z"] pub fn SkRegion_SkRegion2 (this : * mut SkRegion , rect : * const SkIRect) ; } impl SkRegion { # [inline] pub unsafe fn swap (& mut self , other : * mut SkRegion) { SkRegion_swap (self , other) } # [inline] pub unsafe fn computeRegionComplexity (& self) -> :: std :: os :: raw :: c_int { SkRegion_computeRegionComplexity (self) } # [inline] pub unsafe fn getBoundaryPath (& self , path : * mut SkPath) -> bool { SkRegion_getBoundaryPath (self , path) } # [inline] pub unsafe fn setEmpty (& mut self) -> bool { SkRegion_setEmpty (self) } # [inline] pub unsafe fn setRect (& mut self , rect : * const SkIRect) -> bool { SkRegion_setRect (self , rect) } # [inline] pub unsafe fn setRects (& mut self , rects : * const SkIRect , count : :: std :: os :: raw :: c_int) -> bool { SkRegion_setRects (self , rects , count) } # [inline] pub unsafe fn setRegion (& mut self , region : * const SkRegion) -> bool { SkRegion_setRegion (self , region) } # [inline] pub unsafe fn setPath (& mut self , path : * const SkPath , clip : * const SkRegion) -> bool { SkRegion_setPath (self , path , clip) } # [inline] pub unsafe fn intersects (& self , rect : * const SkIRect) -> bool { SkRegion_intersects (self , rect) } # [inline] pub unsafe fn intersects1 (& self , other : * const SkRegion) -> bool { SkRegion_intersects1 (self , other) } # [inline] pub unsafe fn contains (& self , x : i32 , y : i32) -> bool { SkRegion_contains (self , x , y) } # [inline] pub unsafe fn contains1 (& self , other : * const SkIRect) -> bool { SkRegion_contains1 (self , other) } # [inline] pub unsafe fn contains2 (& self , other : * const SkRegion) -> bool { SkRegion_contains2 (self , other) } # [inline] pub unsafe fn translate (& self , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int , dst : * mut SkRegion) { SkRegion_translate (self , dx , dy , dst) } # [inline] pub unsafe fn op (& mut self , rect : * const SkIRect , rgn : * const SkRegion , op : SkRegion_Op) -> bool { SkRegion_op (self , rect , rgn , op) } # [inline] pub unsafe fn op1 (& mut self , rgn : * const SkRegion , rect : * const SkIRect , op : SkRegion_Op) -> bool { SkRegion_op1 (self , rgn , rect , op) } # [inline] pub unsafe fn op2 (& mut self , rgna : * const SkRegion , rgnb : * const SkRegion , op : SkRegion_Op) -> bool { SkRegion_op2 (self , rgna , rgnb , op) } # [inline] pub unsafe fn writeToMemory (& self , buffer : * mut :: core :: ffi :: c_void) -> usize { SkRegion_writeToMemory (self , buffer) } # [inline] pub unsafe fn readFromMemory (& mut self , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize { SkRegion_readFromMemory (self , buffer , length) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_SkRegion (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (region : * const SkRegion) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_SkRegion1 (__bindgen_tmp . as_mut_ptr () , region) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (rect : * const SkIRect) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRegion_SkRegion2 (__bindgen_tmp . as_mut_ptr () , rect) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRRect { pub fRect : SkRect , pub fRadii : [SkVector ; 4usize] , pub fType : i32 , } impl SkRRect_Type { pub const LastType : SkRRect_Type = SkRRect_Type :: Complex ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkRRect_Type { Empty = 0 , Rect = 1 , Oval = 2 , Simple = 3 , NinePatch = 4 , Complex = 5 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkRRect_Corner { UpperLeft = 0 , UpperRight = 1 , LowerRight = 2 , LowerLeft = 3 , } pub const SkRRect_kSizeInMemory : usize = 48 ; # [test] fn bindgen_test_layout_SkRRect () { assert_eq ! (:: core :: mem :: size_of :: < SkRRect > () , 52usize , concat ! ("Size of: " , stringify ! (SkRRect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRRect > () , 4usize , concat ! ("Alignment of " , stringify ! (SkRRect))) ; fn test_field_fRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRect) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRRect) , "::" , stringify ! (fRect))) ; } test_field_fRect () ; fn test_field_fRadii () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRadii) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRRect) , "::" , stringify ! (fRadii))) ; } test_field_fRadii () ; fn test_field_fType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fType) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkRRect) , "::" , stringify ! (fType))) ; } test_field_fType () ; } extern "C" { # [link_name = "\u{1}?setOval@SkRRect@@QEAAXAEBUSkRect@@@Z"] pub fn SkRRect_setOval (this : * mut SkRRect , oval : * const SkRect) ; } extern "C" { # [link_name = "\u{1}?setRectXY@SkRRect@@QEAAXAEBUSkRect@@MM@Z"] pub fn SkRRect_setRectXY (this : * mut SkRRect , rect : * const SkRect , xRad : SkScalar , yRad : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setNinePatch@SkRRect@@QEAAXAEBUSkRect@@MMMM@Z"] pub fn SkRRect_setNinePatch (this : * mut SkRRect , rect : * const SkRect , leftRad : SkScalar , topRad : SkScalar , rightRad : SkScalar , bottomRad : SkScalar) ; } extern "C" { # [link_name = "\u{1}?setRectRadii@SkRRect@@QEAAXAEBUSkRect@@QEBUSkPoint@@@Z"] pub fn SkRRect_setRectRadii (this : * mut SkRRect , rect : * const SkRect , radii : * const SkVector) ; } extern "C" { # [link_name = "\u{1}?inset@SkRRect@@QEBAXMMPEAV1@@Z"] pub fn SkRRect_inset (this : * const SkRRect , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect) ; } extern "C" { # [link_name = "\u{1}?contains@SkRRect@@QEBA_NAEBUSkRect@@@Z"] pub fn SkRRect_contains (this : * const SkRRect , rect : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?isValid@SkRRect@@QEBA_NXZ"] pub fn SkRRect_isValid (this : * const SkRRect) -> bool ; } extern "C" { # [link_name = "\u{1}?writeToMemory@SkRRect@@QEBA_KPEAX@Z"] pub fn SkRRect_writeToMemory (this : * const SkRRect , buffer : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?readFromMemory@SkRRect@@QEAA_KPEBX_K@Z"] pub fn SkRRect_readFromMemory (this : * mut SkRRect , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?transform@SkRRect@@QEBA_NAEBVSkMatrix@@PEAV1@@Z"] pub fn SkRRect_transform (this : * const SkRRect , matrix : * const SkMatrix , dst : * mut SkRRect) -> bool ; } extern "C" { # [link_name = "\u{1}?dump@SkRRect@@QEBAX_N@Z"] pub fn SkRRect_dump (this : * const SkRRect , asHex : bool) ; } extern "C" { # [link_name = "\u{1}?dumpToString@SkRRect@@QEBA?AVSkString@@_N@Z"] pub fn SkRRect_dumpToString (this : * const SkRRect , asHex : bool) -> SkString ; } impl SkRRect { # [inline] pub unsafe fn setOval (& mut self , oval : * const SkRect) { SkRRect_setOval (self , oval) } # [inline] pub unsafe fn setRectXY (& mut self , rect : * const SkRect , xRad : SkScalar , yRad : SkScalar) { SkRRect_setRectXY (self , rect , xRad , yRad) } # [inline] pub unsafe fn setNinePatch (& mut self , rect : * const SkRect , leftRad : SkScalar , topRad : SkScalar , rightRad : SkScalar , bottomRad : SkScalar) { SkRRect_setNinePatch (self , rect , leftRad , topRad , rightRad , bottomRad) } # [inline] pub unsafe fn setRectRadii (& mut self , rect : * const SkRect , radii : * const SkVector) { SkRRect_setRectRadii (self , rect , radii) } # [inline] pub unsafe fn inset (& self , dx : SkScalar , dy : SkScalar , dst : * mut SkRRect) { SkRRect_inset (self , dx , dy , dst) } # [inline] pub unsafe fn contains (& self , rect : * const SkRect) -> bool { SkRRect_contains (self , rect) } # [inline] pub unsafe fn isValid (& self) -> bool { SkRRect_isValid (self) } # [inline] pub unsafe fn writeToMemory (& self , buffer : * mut :: core :: ffi :: c_void) -> usize { SkRRect_writeToMemory (self , buffer) } # [inline] pub unsafe fn readFromMemory (& mut self , buffer : * const :: core :: ffi :: c_void , length : usize) -> usize { SkRRect_readFromMemory (self , buffer , length) } # [inline] pub unsafe fn transform (& self , matrix : * const SkMatrix , dst : * mut SkRRect) -> bool { SkRRect_transform (self , matrix , dst) } # [inline] pub unsafe fn dump (& self , asHex : bool) { SkRRect_dump (self , asHex) } # [inline] pub unsafe fn dumpToString (& self , asHex : bool) -> SkString { SkRRect_dumpToString (self , asHex) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRSXform { pub fSCos : SkScalar , pub fSSin : SkScalar , pub fTx : SkScalar , pub fTy : SkScalar , } # [test] fn bindgen_test_layout_SkRSXform () { assert_eq ! (:: core :: mem :: size_of :: < SkRSXform > () , 16usize , concat ! ("Size of: " , stringify ! (SkRSXform))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRSXform > () , 4usize , concat ! ("Alignment of " , stringify ! (SkRSXform))) ; fn test_field_fSCos () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRSXform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSCos) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRSXform) , "::" , stringify ! (fSCos))) ; } test_field_fSCos () ; fn test_field_fSSin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRSXform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSSin) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkRSXform) , "::" , stringify ! (fSSin))) ; } test_field_fSSin () ; fn test_field_fTx () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRSXform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTx) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRSXform) , "::" , stringify ! (fTx))) ; } test_field_fTx () ; fn test_field_fTy () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRSXform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTy) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkRSXform) , "::" , stringify ! (fTy))) ; } test_field_fTy () ; } extern "C" { # [link_name = "\u{1}?toQuad@SkRSXform@@QEBAXMMQEAUSkPoint@@@Z"] pub fn SkRSXform_toQuad (this : * const SkRSXform , width : SkScalar , height : SkScalar , quad : * mut SkPoint) ; } extern "C" { # [link_name = "\u{1}?toTriStrip@SkRSXform@@QEBAXMMQEAUSkPoint@@@Z"] pub fn SkRSXform_toTriStrip (this : * const SkRSXform , width : SkScalar , height : SkScalar , strip : * mut SkPoint) ; } impl SkRSXform { # [inline] pub unsafe fn toQuad (& self , width : SkScalar , height : SkScalar , quad : * mut SkPoint) { SkRSXform_toQuad (self , width , height , quad) } # [inline] pub unsafe fn toTriStrip (& self , width : SkScalar , height : SkScalar , strip : * mut SkPoint) { SkRSXform_toTriStrip (self , width , height , strip) } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkStream { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkStream () { assert_eq ! (:: core :: mem :: size_of :: < SkStream > () , 8usize , concat ! ("Size of: " , stringify ! (SkStream))) ; assert_eq ! (:: core :: mem :: align_of :: < SkStream > () , 8usize , concat ! ("Alignment of " , stringify ! (SkStream))) ; } extern "C" { # [link_name = "\u{1}?MakeFromFile@SkStream@@SA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@QEBD@Z"] pub fn SkStream_MakeFromFile (path : * const :: std :: os :: raw :: c_char) -> u64 ; } extern "C" { # [link_name = "\u{1}?readS8@SkStream@@QEAA_NPEAC@Z"] pub fn SkStream_readS8 (this : * mut SkStream , arg1 : * mut i8) -> bool ; } extern "C" { # [link_name = "\u{1}?readS16@SkStream@@QEAA_NPEAF@Z"] pub fn SkStream_readS16 (this : * mut SkStream , arg1 : * mut i16) -> bool ; } extern "C" { # [link_name = "\u{1}?readS32@SkStream@@QEAA_NPEAH@Z"] pub fn SkStream_readS32 (this : * mut SkStream , arg1 : * mut i32) -> bool ; } extern "C" { # [link_name = "\u{1}?readScalar@SkStream@@QEAA_NPEAM@Z"] pub fn SkStream_readScalar (this : * mut SkStream , arg1 : * mut SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?readPackedUInt@SkStream@@QEAA_NPEA_K@Z"] pub fn SkStream_readPackedUInt (this : * mut SkStream , arg1 : * mut usize) -> bool ; } impl SkStream { # [inline] pub unsafe fn MakeFromFile (path : * const :: std :: os :: raw :: c_char) -> u64 { SkStream_MakeFromFile (path) } # [inline] pub unsafe fn readS8 (& mut self , arg1 : * mut i8) -> bool { SkStream_readS8 (self , arg1) } # [inline] pub unsafe fn readS16 (& mut self , arg1 : * mut i16) -> bool { SkStream_readS16 (self , arg1) } # [inline] pub unsafe fn readS32 (& mut self , arg1 : * mut i32) -> bool { SkStream_readS32 (self , arg1) } # [inline] pub unsafe fn readScalar (& mut self , arg1 : * mut SkScalar) -> bool { SkStream_readScalar (self , arg1) } # [inline] pub unsafe fn readPackedUInt (& mut self , arg1 : * mut usize) -> bool { SkStream_readPackedUInt (self , arg1) } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkStreamAsset { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkStreamAsset () { assert_eq ! (:: core :: mem :: size_of :: < SkStreamAsset > () , 8usize , concat ! ("Size of: " , stringify ! (SkStreamAsset))) ; assert_eq ! (:: core :: mem :: align_of :: < SkStreamAsset > () , 8usize , concat ! ("Alignment of " , stringify ! (SkStreamAsset))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkStreamMemory { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkStreamMemory () { assert_eq ! (:: core :: mem :: size_of :: < SkStreamMemory > () , 8usize , concat ! ("Size of: " , stringify ! (SkStreamMemory))) ; assert_eq ! (:: core :: mem :: align_of :: < SkStreamMemory > () , 8usize , concat ! ("Alignment of " , stringify ! (SkStreamMemory))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkWStream { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkWStream () { assert_eq ! (:: core :: mem :: size_of :: < SkWStream > () , 8usize , concat ! ("Size of: " , stringify ! (SkWStream))) ; assert_eq ! (:: core :: mem :: align_of :: < SkWStream > () , 8usize , concat ! ("Alignment of " , stringify ! (SkWStream))) ; } extern "C" { # [link_name = "\u{1}?writeDecAsText@SkWStream@@QEAA_NH@Z"] pub fn SkWStream_writeDecAsText (this : * mut SkWStream , arg1 : i32) -> bool ; } extern "C" { # [link_name = "\u{1}?writeBigDecAsText@SkWStream@@QEAA_N_JH@Z"] pub fn SkWStream_writeBigDecAsText (this : * mut SkWStream , arg1 : i64 , minDigits : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?writeHexAsText@SkWStream@@QEAA_NIH@Z"] pub fn SkWStream_writeHexAsText (this : * mut SkWStream , arg1 : u32 , minDigits : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?writeScalarAsText@SkWStream@@QEAA_NM@Z"] pub fn SkWStream_writeScalarAsText (this : * mut SkWStream , arg1 : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?writeScalar@SkWStream@@QEAA_NM@Z"] pub fn SkWStream_writeScalar (this : * mut SkWStream , arg1 : SkScalar) -> bool ; } extern "C" { # [link_name = "\u{1}?writePackedUInt@SkWStream@@QEAA_N_K@Z"] pub fn SkWStream_writePackedUInt (this : * mut SkWStream , arg1 : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?writeStream@SkWStream@@QEAA_NPEAVSkStream@@_K@Z"] pub fn SkWStream_writeStream (this : * mut SkWStream , input : * mut SkStream , length : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?SizeOfPackedUInt@SkWStream@@SAH_K@Z"] pub fn SkWStream_SizeOfPackedUInt (value : usize) -> :: std :: os :: raw :: c_int ; } impl SkWStream { # [inline] pub unsafe fn writeDecAsText (& mut self , arg1 : i32) -> bool { SkWStream_writeDecAsText (self , arg1) } # [inline] pub unsafe fn writeBigDecAsText (& mut self , arg1 : i64 , minDigits : :: std :: os :: raw :: c_int) -> bool { SkWStream_writeBigDecAsText (self , arg1 , minDigits) } # [inline] pub unsafe fn writeHexAsText (& mut self , arg1 : u32 , minDigits : :: std :: os :: raw :: c_int) -> bool { SkWStream_writeHexAsText (self , arg1 , minDigits) } # [inline] pub unsafe fn writeScalarAsText (& mut self , arg1 : SkScalar) -> bool { SkWStream_writeScalarAsText (self , arg1) } # [inline] pub unsafe fn writeScalar (& mut self , arg1 : SkScalar) -> bool { SkWStream_writeScalar (self , arg1) } # [inline] pub unsafe fn writePackedUInt (& mut self , arg1 : usize) -> bool { SkWStream_writePackedUInt (self , arg1) } # [inline] pub unsafe fn writeStream (& mut self , input : * mut SkStream , length : usize) -> bool { SkWStream_writeStream (self , input , length) } # [inline] pub unsafe fn SizeOfPackedUInt (value : usize) -> :: std :: os :: raw :: c_int { SkWStream_SizeOfPackedUInt (value) } } extern "C" { # [link_name = "\u{1}?flush@SkWStream@@UEAAXXZ"] pub fn SkWStream_flush (this : * mut :: core :: ffi :: c_void) ; } # [repr (C)] # [derive (Debug)] pub struct SkMemoryStream { pub _base : SkStreamMemory , pub fData : sk_sp < SkData > , pub fOffset : usize , } pub type SkMemoryStream_INHERITED = SkStreamMemory ; # [test] fn bindgen_test_layout_SkMemoryStream () { assert_eq ! (:: core :: mem :: size_of :: < SkMemoryStream > () , 24usize , concat ! ("Size of: " , stringify ! (SkMemoryStream))) ; assert_eq ! (:: core :: mem :: align_of :: < SkMemoryStream > () , 8usize , concat ! ("Alignment of " , stringify ! (SkMemoryStream))) ; fn test_field_fData () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkMemoryStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fData) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkMemoryStream) , "::" , stringify ! (fData))) ; } test_field_fData () ; fn test_field_fOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkMemoryStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOffset) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkMemoryStream) , "::" , stringify ! (fOffset))) ; } test_field_fOffset () ; } extern "C" { # [link_name = "\u{1}?MakeCopy@SkMemoryStream@@SA?AV?$unique_ptr@VSkMemoryStream@@U?$default_delete@VSkMemoryStream@@@std@@@std@@PEBX_K@Z"] pub fn SkMemoryStream_MakeCopy (data : * const :: core :: ffi :: c_void , length : usize) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeDirect@SkMemoryStream@@SA?AV?$unique_ptr@VSkMemoryStream@@U?$default_delete@VSkMemoryStream@@@std@@@std@@PEBX_K@Z"] pub fn SkMemoryStream_MakeDirect (data : * const :: core :: ffi :: c_void , length : usize) -> u64 ; } extern "C" { # [link_name = "\u{1}?Make@SkMemoryStream@@SA?AV?$unique_ptr@VSkMemoryStream@@U?$default_delete@VSkMemoryStream@@@std@@@std@@V?$sk_sp@VSkData@@@@@Z"] pub fn SkMemoryStream_Make (data : sk_sp < SkData >) -> u64 ; } extern "C" { # [link_name = "\u{1}?setMemoryOwned@SkMemoryStream@@QEAAXPEBX_K@Z"] pub fn SkMemoryStream_setMemoryOwned (this : * mut SkMemoryStream , data : * const :: core :: ffi :: c_void , length : usize) ; } extern "C" { # [link_name = "\u{1}?setData@SkMemoryStream@@QEAAXV?$sk_sp@VSkData@@@@@Z"] pub fn SkMemoryStream_setData (this : * mut SkMemoryStream , data : sk_sp < SkData >) ; } extern "C" { # [link_name = "\u{1}?skipToAlign4@SkMemoryStream@@QEAAXXZ"] pub fn SkMemoryStream_skipToAlign4 (this : * mut SkMemoryStream) ; } extern "C" { # [link_name = "\u{1}?getAtPos@SkMemoryStream@@QEAAPEBXXZ"] pub fn SkMemoryStream_getAtPos (this : * mut SkMemoryStream) -> * const :: core :: ffi :: c_void ; } extern "C" { # [link_name = "\u{1}??0SkMemoryStream@@QEAA@XZ"] pub fn SkMemoryStream_SkMemoryStream (this : * mut SkMemoryStream) ; } extern "C" { # [link_name = "\u{1}??0SkMemoryStream@@QEAA@_K@Z"] pub fn SkMemoryStream_SkMemoryStream1 (this : * mut SkMemoryStream , length : usize) ; } extern "C" { # [link_name = "\u{1}??0SkMemoryStream@@QEAA@PEBX_K_N@Z"] pub fn SkMemoryStream_SkMemoryStream2 (this : * mut SkMemoryStream , data : * const :: core :: ffi :: c_void , length : usize , copyData : bool) ; } extern "C" { # [link_name = "\u{1}??0SkMemoryStream@@QEAA@V?$sk_sp@VSkData@@@@@Z"] pub fn SkMemoryStream_SkMemoryStream3 (this : * mut SkMemoryStream , data : sk_sp < SkData >) ; } impl SkMemoryStream { # [inline] pub unsafe fn MakeCopy (data : * const :: core :: ffi :: c_void , length : usize) -> u64 { SkMemoryStream_MakeCopy (data , length) } # [inline] pub unsafe fn MakeDirect (data : * const :: core :: ffi :: c_void , length : usize) -> u64 { SkMemoryStream_MakeDirect (data , length) } # [inline] pub unsafe fn Make (data : sk_sp < SkData >) -> u64 { SkMemoryStream_Make (data) } # [inline] pub unsafe fn setMemoryOwned (& mut self , data : * const :: core :: ffi :: c_void , length : usize) { SkMemoryStream_setMemoryOwned (self , data , length) } # [inline] pub unsafe fn setData (& mut self , data : sk_sp < SkData >) { SkMemoryStream_setData (self , data) } # [inline] pub unsafe fn skipToAlign4 (& mut self) { SkMemoryStream_skipToAlign4 (self) } # [inline] pub unsafe fn getAtPos (& mut self) -> * const :: core :: ffi :: c_void { SkMemoryStream_getAtPos (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkMemoryStream_SkMemoryStream (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (length : usize) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkMemoryStream_SkMemoryStream1 (__bindgen_tmp . as_mut_ptr () , length) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (data : * const :: core :: ffi :: c_void , length : usize , copyData : bool) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkMemoryStream_SkMemoryStream2 (__bindgen_tmp . as_mut_ptr () , data , length , copyData) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new3 (data : sk_sp < SkData >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkMemoryStream_SkMemoryStream3 (__bindgen_tmp . as_mut_ptr () , data) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?setMemory@SkMemoryStream@@UEAAXPEBX_K_N@Z"] pub fn SkMemoryStream_setMemory (this : * mut :: core :: ffi :: c_void , data : * const :: core :: ffi :: c_void , length : usize , copyData : bool) ; } extern "C" { # [link_name = "\u{1}?read@SkMemoryStream@@UEAA_KPEAX_K@Z"] pub fn SkMemoryStream_read (this : * mut :: core :: ffi :: c_void , buffer : * mut :: core :: ffi :: c_void , size : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?isAtEnd@SkMemoryStream@@UEBA_NXZ"] pub fn SkMemoryStream_isAtEnd (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?peek@SkMemoryStream@@UEBA_KPEAX_K@Z"] pub fn SkMemoryStream_peek (this : * mut :: core :: ffi :: c_void , buffer : * mut :: core :: ffi :: c_void , size : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?rewind@SkMemoryStream@@UEAA_NXZ"] pub fn SkMemoryStream_rewind (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?getPosition@SkMemoryStream@@UEBA_KXZ"] pub fn SkMemoryStream_getPosition (this : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?seek@SkMemoryStream@@UEAA_N_K@Z"] pub fn SkMemoryStream_seek (this : * mut :: core :: ffi :: c_void , position : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?move@SkMemoryStream@@UEAA_NJ@Z"] pub fn SkMemoryStream_move (this : * mut :: core :: ffi :: c_void , offset : :: std :: os :: raw :: c_long) -> bool ; } extern "C" { # [link_name = "\u{1}?getLength@SkMemoryStream@@UEBA_KXZ"] pub fn SkMemoryStream_getLength (this : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { # [link_name = "\u{1}?getMemoryBase@SkMemoryStream@@UEAAPEBXXZ"] pub fn SkMemoryStream_getMemoryBase (this : * mut :: core :: ffi :: c_void) -> * const :: core :: ffi :: c_void ; } # [repr (C)] # [derive (Debug)] pub struct SkDynamicMemoryWStream { pub _base : SkWStream , pub fHead : * mut SkDynamicMemoryWStream_Block , pub fTail : * mut SkDynamicMemoryWStream_Block , pub fBytesWrittenBeforeTail : usize , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkDynamicMemoryWStream_Block { _unused : [u8 ; 0] , } pub type SkDynamicMemoryWStream_INHERITED = SkWStream ; # [test] fn bindgen_test_layout_SkDynamicMemoryWStream () { assert_eq ! (:: core :: mem :: size_of :: < SkDynamicMemoryWStream > () , 32usize , concat ! ("Size of: " , stringify ! (SkDynamicMemoryWStream))) ; assert_eq ! (:: core :: mem :: align_of :: < SkDynamicMemoryWStream > () , 8usize , concat ! ("Alignment of " , stringify ! (SkDynamicMemoryWStream))) ; fn test_field_fHead () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDynamicMemoryWStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHead) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkDynamicMemoryWStream) , "::" , stringify ! (fHead))) ; } test_field_fHead () ; fn test_field_fTail () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDynamicMemoryWStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTail) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkDynamicMemoryWStream) , "::" , stringify ! (fTail))) ; } test_field_fTail () ; fn test_field_fBytesWrittenBeforeTail () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkDynamicMemoryWStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBytesWrittenBeforeTail) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkDynamicMemoryWStream) , "::" , stringify ! (fBytesWrittenBeforeTail))) ; } test_field_fBytesWrittenBeforeTail () ; } extern "C" { # [link_name = "\u{1}?read@SkDynamicMemoryWStream@@QEAA_NPEAX_K1@Z"] pub fn SkDynamicMemoryWStream_read (this : * mut SkDynamicMemoryWStream , buffer : * mut :: core :: ffi :: c_void , offset : usize , size : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?copyTo@SkDynamicMemoryWStream@@QEBAXPEAX@Z"] pub fn SkDynamicMemoryWStream_copyTo (this : * const SkDynamicMemoryWStream , dst : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?writeToStream@SkDynamicMemoryWStream@@QEBA_NPEAVSkWStream@@@Z"] pub fn SkDynamicMemoryWStream_writeToStream (this : * const SkDynamicMemoryWStream , dst : * mut SkWStream) -> bool ; } extern "C" { # [link_name = "\u{1}?copyToAndReset@SkDynamicMemoryWStream@@QEAAXPEAX@Z"] pub fn SkDynamicMemoryWStream_copyToAndReset (this : * mut SkDynamicMemoryWStream , dst : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?writeToAndReset@SkDynamicMemoryWStream@@QEAA_NPEAVSkWStream@@@Z"] pub fn SkDynamicMemoryWStream_writeToAndReset (this : * mut SkDynamicMemoryWStream , dst : * mut SkWStream) -> bool ; } extern "C" { # [link_name = "\u{1}?writeToAndReset@SkDynamicMemoryWStream@@QEAA_NPEAV1@@Z"] pub fn SkDynamicMemoryWStream_writeToAndReset1 (this : * mut SkDynamicMemoryWStream , dst : * mut SkDynamicMemoryWStream) -> bool ; } extern "C" { # [link_name = "\u{1}?prependToAndReset@SkDynamicMemoryWStream@@QEAAXPEAV1@@Z"] pub fn SkDynamicMemoryWStream_prependToAndReset (this : * mut SkDynamicMemoryWStream , dst : * mut SkDynamicMemoryWStream) ; } extern "C" { # [link_name = "\u{1}?detachAsData@SkDynamicMemoryWStream@@QEAA?AV?$sk_sp@VSkData@@@@XZ"] pub fn SkDynamicMemoryWStream_detachAsData (this : * mut SkDynamicMemoryWStream) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?detachAsStream@SkDynamicMemoryWStream@@QEAA?AV?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@XZ"] pub fn SkDynamicMemoryWStream_detachAsStream (this : * mut SkDynamicMemoryWStream) -> u64 ; } extern "C" { # [link_name = "\u{1}?reset@SkDynamicMemoryWStream@@QEAAXXZ"] pub fn SkDynamicMemoryWStream_reset (this : * mut SkDynamicMemoryWStream) ; } extern "C" { # [link_name = "\u{1}?padToAlign4@SkDynamicMemoryWStream@@QEAAXXZ"] pub fn SkDynamicMemoryWStream_padToAlign4 (this : * mut SkDynamicMemoryWStream) ; } extern "C" { # [link_name = "\u{1}??0SkDynamicMemoryWStream@@QEAA@$$QEAV0@@Z"] pub fn SkDynamicMemoryWStream_SkDynamicMemoryWStream (this : * mut SkDynamicMemoryWStream , arg1 : * mut SkDynamicMemoryWStream) ; } impl SkDynamicMemoryWStream { # [inline] pub unsafe fn read (& mut self , buffer : * mut :: core :: ffi :: c_void , offset : usize , size : usize) -> bool { SkDynamicMemoryWStream_read (self , buffer , offset , size) } # [inline] pub unsafe fn copyTo (& self , dst : * mut :: core :: ffi :: c_void) { SkDynamicMemoryWStream_copyTo (self , dst) } # [inline] pub unsafe fn writeToStream (& self , dst : * mut SkWStream) -> bool { SkDynamicMemoryWStream_writeToStream (self , dst) } # [inline] pub unsafe fn copyToAndReset (& mut self , dst : * mut :: core :: ffi :: c_void) { SkDynamicMemoryWStream_copyToAndReset (self , dst) } # [inline] pub unsafe fn writeToAndReset (& mut self , dst : * mut SkWStream) -> bool { SkDynamicMemoryWStream_writeToAndReset (self , dst) } # [inline] pub unsafe fn writeToAndReset1 (& mut self , dst : * mut SkDynamicMemoryWStream) -> bool { SkDynamicMemoryWStream_writeToAndReset1 (self , dst) } # [inline] pub unsafe fn prependToAndReset (& mut self , dst : * mut SkDynamicMemoryWStream) { SkDynamicMemoryWStream_prependToAndReset (self , dst) } # [inline] pub unsafe fn detachAsData (& mut self) -> sk_sp < SkData > { SkDynamicMemoryWStream_detachAsData (self) } # [inline] pub unsafe fn detachAsStream (& mut self) -> u64 { SkDynamicMemoryWStream_detachAsStream (self) } # [inline] pub unsafe fn reset (& mut self) { SkDynamicMemoryWStream_reset (self) } # [inline] pub unsafe fn padToAlign4 (& mut self) { SkDynamicMemoryWStream_padToAlign4 (self) } # [inline] pub unsafe fn new (arg1 : * mut SkDynamicMemoryWStream) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkDynamicMemoryWStream_SkDynamicMemoryWStream (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?write@SkDynamicMemoryWStream@@UEAA_NPEBX_K@Z"] pub fn SkDynamicMemoryWStream_write (this : * mut :: core :: ffi :: c_void , buffer : * const :: core :: ffi :: c_void , size : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?bytesWritten@SkDynamicMemoryWStream@@UEBA_KXZ"] pub fn SkDynamicMemoryWStream_bytesWritten (this : * mut :: core :: ffi :: c_void) -> usize ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkStrokeRec { pub fResScale : SkScalar , pub fWidth : SkScalar , pub fMiterLimit : SkScalar , pub _bitfield_align_1 : [u16 ; 0] , pub _bitfield_1 : __BindgenBitfieldUnit < [u8 ; 4usize] > , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkStrokeRec_InitStyle { Hairline = 0 , Fill = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkStrokeRec_Style { Hairline = 0 , Fill = 1 , Stroke = 2 , StrokeAndFill = 3 , } pub const SkStrokeRec_kStyleCount : :: std :: os :: raw :: c_int = 4 ; # [test] fn bindgen_test_layout_SkStrokeRec () { assert_eq ! (:: core :: mem :: size_of :: < SkStrokeRec > () , 16usize , concat ! ("Size of: " , stringify ! (SkStrokeRec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkStrokeRec > () , 4usize , concat ! ("Alignment of " , stringify ! (SkStrokeRec))) ; fn test_field_fResScale () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkStrokeRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fResScale) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkStrokeRec) , "::" , stringify ! (fResScale))) ; } test_field_fResScale () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkStrokeRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkStrokeRec) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fMiterLimit () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkStrokeRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMiterLimit) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkStrokeRec) , "::" , stringify ! (fMiterLimit))) ; } test_field_fMiterLimit () ; } extern "C" { # [link_name = "\u{1}?getStyle@SkStrokeRec@@QEBA?AW4Style@1@XZ"] pub fn SkStrokeRec_getStyle (this : * const SkStrokeRec) -> SkStrokeRec_Style ; } extern "C" { # [link_name = "\u{1}?setFillStyle@SkStrokeRec@@QEAAXXZ"] pub fn SkStrokeRec_setFillStyle (this : * mut SkStrokeRec) ; } extern "C" { # [link_name = "\u{1}?setHairlineStyle@SkStrokeRec@@QEAAXXZ"] pub fn SkStrokeRec_setHairlineStyle (this : * mut SkStrokeRec) ; } extern "C" { # [link_name = "\u{1}?setStrokeStyle@SkStrokeRec@@QEAAXM_N@Z"] pub fn SkStrokeRec_setStrokeStyle (this : * mut SkStrokeRec , width : SkScalar , strokeAndFill : bool) ; } extern "C" { # [link_name = "\u{1}?applyToPath@SkStrokeRec@@QEBA_NPEAVSkPath@@AEBV2@@Z"] pub fn SkStrokeRec_applyToPath (this : * const SkStrokeRec , dst : * mut SkPath , src : * const SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?applyToPaint@SkStrokeRec@@QEBAXPEAVSkPaint@@@Z"] pub fn SkStrokeRec_applyToPaint (this : * const SkStrokeRec , paint : * mut SkPaint) ; } extern "C" { # [link_name = "\u{1}?getInflationRadius@SkStrokeRec@@QEBAMXZ"] pub fn SkStrokeRec_getInflationRadius (this : * const SkStrokeRec) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?GetInflationRadius@SkStrokeRec@@SAMAEBVSkPaint@@W4Style@2@@Z"] pub fn SkStrokeRec_GetInflationRadius (arg1 : * const SkPaint , arg2 : SkPaint_Style) -> SkScalar ; } extern "C" { # [link_name = "\u{1}?GetInflationRadius@SkStrokeRec@@SAMW4Join@SkPaint@@MW4Cap@3@M@Z"] pub fn SkStrokeRec_GetInflationRadius1 (arg1 : SkPaint_Join , miterLimit : SkScalar , arg2 : SkPaint_Cap , strokeWidth : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}??0SkStrokeRec@@QEAA@W4InitStyle@0@@Z"] pub fn SkStrokeRec_SkStrokeRec (this : * mut SkStrokeRec , style : SkStrokeRec_InitStyle) ; } extern "C" { # [link_name = "\u{1}??0SkStrokeRec@@QEAA@AEBVSkPaint@@W4Style@1@M@Z"] pub fn SkStrokeRec_SkStrokeRec1 (this : * mut SkStrokeRec , arg1 : * const SkPaint , arg2 : SkPaint_Style , resScale : SkScalar) ; } extern "C" { # [link_name = "\u{1}??0SkStrokeRec@@QEAA@AEBVSkPaint@@M@Z"] pub fn SkStrokeRec_SkStrokeRec2 (this : * mut SkStrokeRec , arg1 : * const SkPaint , resScale : SkScalar) ; } impl SkStrokeRec { # [inline] pub fn fCap (& self) -> u32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (0usize , 16u8) as u32) } } # [inline] pub fn set_fCap (& mut self , val : u32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 16u8 , val as u64) } } # [inline] pub fn fJoin (& self) -> u32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (16usize , 15u8) as u32) } } # [inline] pub fn set_fJoin (& mut self , val : u32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (16usize , 15u8 , val as u64) } } # [inline] pub fn fStrokeAndFill (& self) -> u32 { unsafe { :: core :: mem :: transmute (self . _bitfield_1 . get (31usize , 1u8) as u32) } } # [inline] pub fn set_fStrokeAndFill (& mut self , val : u32) { unsafe { let val : u32 = :: core :: mem :: transmute (val) ; self . _bitfield_1 . set (31usize , 1u8 , val as u64) } } # [inline] pub fn new_bitfield_1 (fCap : u32 , fJoin : u32 , fStrokeAndFill : u32) -> __BindgenBitfieldUnit < [u8 ; 4usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 4usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 16u8 , { let fCap : u32 = unsafe { :: core :: mem :: transmute (fCap) } ; fCap as u64 }) ; __bindgen_bitfield_unit . set (16usize , 15u8 , { let fJoin : u32 = unsafe { :: core :: mem :: transmute (fJoin) } ; fJoin as u64 }) ; __bindgen_bitfield_unit . set (31usize , 1u8 , { let fStrokeAndFill : u32 = unsafe { :: core :: mem :: transmute (fStrokeAndFill) } ; fStrokeAndFill as u64 }) ; __bindgen_bitfield_unit } # [inline] pub unsafe fn getStyle (& self) -> SkStrokeRec_Style { SkStrokeRec_getStyle (self) } # [inline] pub unsafe fn setFillStyle (& mut self) { SkStrokeRec_setFillStyle (self) } # [inline] pub unsafe fn setHairlineStyle (& mut self) { SkStrokeRec_setHairlineStyle (self) } # [inline] pub unsafe fn setStrokeStyle (& mut self , width : SkScalar , strokeAndFill : bool) { SkStrokeRec_setStrokeStyle (self , width , strokeAndFill) } # [inline] pub unsafe fn applyToPath (& self , dst : * mut SkPath , src : * const SkPath) -> bool { SkStrokeRec_applyToPath (self , dst , src) } # [inline] pub unsafe fn applyToPaint (& self , paint : * mut SkPaint) { SkStrokeRec_applyToPaint (self , paint) } # [inline] pub unsafe fn getInflationRadius (& self) -> SkScalar { SkStrokeRec_getInflationRadius (self) } # [inline] pub unsafe fn GetInflationRadius (arg1 : * const SkPaint , arg2 : SkPaint_Style) -> SkScalar { SkStrokeRec_GetInflationRadius (arg1 , arg2) } # [inline] pub unsafe fn GetInflationRadius1 (arg1 : SkPaint_Join , miterLimit : SkScalar , arg2 : SkPaint_Cap , strokeWidth : SkScalar) -> SkScalar { SkStrokeRec_GetInflationRadius1 (arg1 , miterLimit , arg2 , strokeWidth) } # [inline] pub unsafe fn new (style : SkStrokeRec_InitStyle) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkStrokeRec_SkStrokeRec (__bindgen_tmp . as_mut_ptr () , style) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (arg1 : * const SkPaint , arg2 : SkPaint_Style , resScale : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkStrokeRec_SkStrokeRec1 (__bindgen_tmp . as_mut_ptr () , arg1 , arg2 , resScale) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new2 (arg1 : * const SkPaint , resScale : SkScalar) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkStrokeRec_SkStrokeRec2 (__bindgen_tmp . as_mut_ptr () , arg1 , resScale) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkSurface { pub _bindgen_opaque_blob : [u64 ; 5usize] , } pub type SkSurface_ReleaseContext = * mut :: core :: ffi :: c_void ; pub type SkSurface_RenderTargetReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (releaseContext : SkSurface_ReleaseContext) > ; pub type SkSurface_TextureReleaseProc = :: core :: option :: Option < unsafe extern "C" fn (releaseContext : SkSurface_ReleaseContext) > ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurface_ContentChangeMode { Discard = 0 , Retain = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurface_BackendHandleAccess { FlushRead = 0 , FlushWrite = 1 , DiscardWrite = 2 , } pub type SkSurface_AsyncReadResult = SkImage_AsyncReadResult ; pub type SkSurface_ReadPixelsContext = * mut :: core :: ffi :: c_void ; pub type SkSurface_ReadPixelsCallback = :: core :: option :: Option < unsafe extern "C" fn (arg1 : SkSurface_ReadPixelsContext , arg2 : u8) > ; pub use self :: SkImage_RescaleGamma as SkSurface_RescaleGamma ; pub use self :: SkImage_RescaleMode as SkSurface_RescaleMode ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSurface_BackendSurfaceAccess { NoAccess = 0 , Present = 1 , } pub type SkSurface_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkSurface () { assert_eq ! (:: core :: mem :: size_of :: < SkSurface > () , 40usize , concat ! ("Size of: " , stringify ! (SkSurface))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSurface > () , 8usize , concat ! ("Alignment of " , stringify ! (SkSurface))) ; } extern "C" { # [link_name = "\u{1}?MakeRasterDirect@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KPEBVSkSurfaceProps@@@Z"] pub fn SkSurface_MakeRasterDirect (imageInfo : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeRasterDirectReleaseProc@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@PEAX_KP6AX11@Z1PEBVSkSurfaceProps@@@Z"] pub fn SkSurface_MakeRasterDirectReleaseProc (imageInfo : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn (pixels : * mut :: core :: ffi :: c_void , context : * mut :: core :: ffi :: c_void) > , context : * mut :: core :: ffi :: c_void , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeRaster@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@_KPEBVSkSurfaceProps@@@Z"] pub fn SkSurface_MakeRaster (imageInfo : * const SkImageInfo , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeRasterN32Premul@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@HHPEBVSkSurfaceProps@@@Z"] pub fn SkSurface_MakeRasterN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeFromBackendTexture@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrRecordingContext@@AEBVGrBackendTexture@@W4GrSurfaceOrigin@@HW4SkColorType@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@P6AXPEAX@Z6@Z"] pub fn SkSurface_MakeFromBackendTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeFromBackendRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrRecordingContext@@AEBVGrBackendRenderTarget@@W4GrSurfaceOrigin@@W4SkColorType@@V?$sk_sp@VSkColorSpace@@@@PEBVSkSurfaceProps@@P6AXPEAX@Z6@Z"] pub fn SkSurface_MakeFromBackendRenderTarget (context : * mut GrRecordingContext , backendRenderTarget : * const GrBackendRenderTarget , origin : GrSurfaceOrigin , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , releaseProc : SkSurface_RenderTargetReleaseProc , releaseContext : SkSurface_ReleaseContext) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrRecordingContext@@W4SkBudgeted@@AEBUSkImageInfo@@HW4GrSurfaceOrigin@@PEBVSkSurfaceProps@@_N@Z"] pub fn SkSurface_MakeRenderTarget (context : * mut GrRecordingContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , surfaceOrigin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , shouldCreateWithMips : bool) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?MakeRenderTarget@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@PEAVGrRecordingContext@@AEBVSkSurfaceCharacterization@@W4SkBudgeted@@@Z"] pub fn SkSurface_MakeRenderTarget1 (context : * mut GrRecordingContext , characterization : * const SkSurfaceCharacterization , budgeted : SkBudgeted) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?isCompatible@SkSurface@@QEBA_NAEBVSkSurfaceCharacterization@@@Z"] pub fn SkSurface_isCompatible (this : * const SkSurface , characterization : * const SkSurfaceCharacterization) -> bool ; } extern "C" { # [link_name = "\u{1}?MakeNull@SkSurface@@SA?AV?$sk_sp@VSkSurface@@@@HH@Z"] pub fn SkSurface_MakeNull (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?imageInfo@SkSurface@@QEAA?AUSkImageInfo@@XZ"] pub fn SkSurface_imageInfo (this : * mut SkSurface) -> SkImageInfo ; } extern "C" { # [link_name = "\u{1}?generationID@SkSurface@@QEAAIXZ"] pub fn SkSurface_generationID (this : * mut SkSurface) -> u32 ; } extern "C" { # [link_name = "\u{1}?notifyContentWillChange@SkSurface@@QEAAXW4ContentChangeMode@1@@Z"] pub fn SkSurface_notifyContentWillChange (this : * mut SkSurface , mode : SkSurface_ContentChangeMode) ; } extern "C" { # [link_name = "\u{1}?recordingContext@SkSurface@@QEAAPEAVGrRecordingContext@@XZ"] pub fn SkSurface_recordingContext (this : * mut SkSurface) -> * mut GrRecordingContext ; } extern "C" { # [link_name = "\u{1}?recorder@SkSurface@@QEAAPEAVRecorder@graphite@skgpu@@XZ"] pub fn SkSurface_recorder (this : * mut SkSurface) -> * mut skgpu_graphite_Recorder ; } extern "C" { # [link_name = "\u{1}?getBackendTexture@SkSurface@@QEAA?AVGrBackendTexture@@W4BackendHandleAccess@1@@Z"] pub fn SkSurface_getBackendTexture (this : * mut SkSurface , backendHandleAccess : SkSurface_BackendHandleAccess) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?getBackendRenderTarget@SkSurface@@QEAA?AVGrBackendRenderTarget@@W4BackendHandleAccess@1@@Z"] pub fn SkSurface_getBackendRenderTarget (this : * mut SkSurface , backendHandleAccess : SkSurface_BackendHandleAccess) -> GrBackendRenderTarget ; } extern "C" { # [link_name = "\u{1}?replaceBackendTexture@SkSurface@@QEAA_NAEBVGrBackendTexture@@W4GrSurfaceOrigin@@W4ContentChangeMode@1@P6AXPEAX@Z3@Z"] pub fn SkSurface_replaceBackendTexture (this : * mut SkSurface , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , mode : SkSurface_ContentChangeMode , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext) -> bool ; } extern "C" { # [link_name = "\u{1}?getCanvas@SkSurface@@QEAAPEAVSkCanvas@@XZ"] pub fn SkSurface_getCanvas (this : * mut SkSurface) -> * mut SkCanvas ; } extern "C" { # [link_name = "\u{1}?capabilities@SkSurface@@QEAA?AV?$sk_sp@$$CBVSkCapabilities@@@@XZ"] pub fn SkSurface_capabilities (this : * mut SkSurface) -> sk_sp < SkCapabilities > ; } extern "C" { # [link_name = "\u{1}?makeSurface@SkSurface@@QEAA?AV?$sk_sp@VSkSurface@@@@AEBUSkImageInfo@@@Z"] pub fn SkSurface_makeSurface (this : * mut SkSurface , imageInfo : * const SkImageInfo) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?makeSurface@SkSurface@@QEAA?AV?$sk_sp@VSkSurface@@@@HH@Z"] pub fn SkSurface_makeSurface1 (this : * mut SkSurface , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> sk_sp < SkSurface > ; } extern "C" { # [link_name = "\u{1}?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@XZ"] pub fn SkSurface_makeImageSnapshot (this : * mut SkSurface) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeImageSnapshot@SkSurface@@QEAA?AV?$sk_sp@VSkImage@@@@AEBUSkIRect@@@Z"] pub fn SkSurface_makeImageSnapshot1 (this : * mut SkSurface , bounds : * const SkIRect) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?draw@SkSurface@@QEAAXPEAVSkCanvas@@MMAEBUSkSamplingOptions@@PEBVSkPaint@@@Z"] pub fn SkSurface_draw (this : * mut SkSurface , canvas : * mut SkCanvas , x : SkScalar , y : SkScalar , sampling : * const SkSamplingOptions , paint : * const SkPaint) ; } extern "C" { # [link_name = "\u{1}?peekPixels@SkSurface@@QEAA_NPEAVSkPixmap@@@Z"] pub fn SkSurface_peekPixels (this : * mut SkSurface , pixmap : * mut SkPixmap) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkSurface@@QEAA_NAEBVSkPixmap@@HH@Z"] pub fn SkSurface_readPixels (this : * mut SkSurface , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkSurface@@QEAA_NAEBUSkImageInfo@@PEAX_KHH@Z"] pub fn SkSurface_readPixels1 (this : * mut SkSurface , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?readPixels@SkSurface@@QEAA_NAEBVSkBitmap@@HH@Z"] pub fn SkSurface_readPixels2 (this : * mut SkSurface , dst : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}?asyncRescaleAndReadPixels@SkSurface@@QEAAXAEBUSkImageInfo@@AEBUSkIRect@@W4RescaleGamma@SkImage@@W4RescaleMode@5@P6AXPEAXV?$unique_ptr@$$CBVAsyncReadResult@SkImage@@U?$default_delete@$$CBVAsyncReadResult@SkImage@@@std@@@std@@@Z4@Z"] pub fn SkSurface_asyncRescaleAndReadPixels (this : * mut SkSurface , info : * const SkImageInfo , srcRect : * const SkIRect , rescaleGamma : SkSurface_RescaleGamma , rescaleMode : SkSurface_RescaleMode , callback : SkSurface_ReadPixelsCallback , context : SkSurface_ReadPixelsContext) ; } extern "C" { # [link_name = "\u{1}?asyncRescaleAndReadPixelsYUV420@SkSurface@@QEAAXW4SkYUVColorSpace@@V?$sk_sp@VSkColorSpace@@@@AEBUSkIRect@@AEBUSkISize@@W4RescaleGamma@SkImage@@W4RescaleMode@7@P6AXPEAXV?$unique_ptr@$$CBVAsyncReadResult@SkImage@@U?$default_delete@$$CBVAsyncReadResult@SkImage@@@std@@@std@@@Z6@Z"] pub fn SkSurface_asyncRescaleAndReadPixelsYUV420 (this : * mut SkSurface , yuvColorSpace : SkYUVColorSpace , dstColorSpace : sk_sp < SkColorSpace > , srcRect : * const SkIRect , dstSize : * const SkISize , rescaleGamma : SkSurface_RescaleGamma , rescaleMode : SkSurface_RescaleMode , callback : SkSurface_ReadPixelsCallback , context : SkSurface_ReadPixelsContext) ; } extern "C" { # [link_name = "\u{1}?writePixels@SkSurface@@QEAAXAEBVSkPixmap@@HH@Z"] pub fn SkSurface_writePixels (this : * mut SkSurface , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?writePixels@SkSurface@@QEAAXAEBVSkBitmap@@HH@Z"] pub fn SkSurface_writePixels1 (this : * mut SkSurface , src : * const SkBitmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?flushAndSubmit@SkSurface@@QEAAX_N@Z"] pub fn SkSurface_flushAndSubmit (this : * mut SkSurface , syncCpu : bool) ; } extern "C" { # [link_name = "\u{1}?resolveMSAA@SkSurface@@QEAAXXZ"] pub fn SkSurface_resolveMSAA (this : * mut SkSurface) ; } extern "C" { # [link_name = "\u{1}?flush@SkSurface@@QEAA?AW4GrSemaphoresSubmitted@@W4BackendSurfaceAccess@1@AEBUGrFlushInfo@@@Z"] pub fn SkSurface_flush (this : * mut SkSurface , access : SkSurface_BackendSurfaceAccess , info : * const GrFlushInfo) -> GrSemaphoresSubmitted ; } extern "C" { # [link_name = "\u{1}?flush@SkSurface@@QEAA?AW4GrSemaphoresSubmitted@@AEBUGrFlushInfo@@PEBVGrBackendSurfaceMutableState@@@Z"] pub fn SkSurface_flush1 (this : * mut SkSurface , info : * const GrFlushInfo , newState : * const GrBackendSurfaceMutableState) -> GrSemaphoresSubmitted ; } extern "C" { # [link_name = "\u{1}?flush@SkSurface@@QEAAXXZ"] pub fn SkSurface_flush2 (this : * mut SkSurface) ; } extern "C" { # [link_name = "\u{1}?wait@SkSurface@@QEAA_NHPEBVGrBackendSemaphore@@_N@Z"] pub fn SkSurface_wait (this : * mut SkSurface , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore , deleteSemaphoresAfterWait : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?characterize@SkSurface@@QEBA_NPEAVSkSurfaceCharacterization@@@Z"] pub fn SkSurface_characterize (this : * const SkSurface , characterization : * mut SkSurfaceCharacterization) -> bool ; } extern "C" { # [link_name = "\u{1}?draw@SkSurface@@QEAA_NV?$sk_sp@$$CBVSkDeferredDisplayList@@@@HH@Z"] pub fn SkSurface_draw1 (this : * mut SkSurface , deferredDisplayList : sk_sp < SkDeferredDisplayList > , xOffset : :: std :: os :: raw :: c_int , yOffset : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { # [link_name = "\u{1}??0SkSurface@@IEAA@HHPEBVSkSurfaceProps@@@Z"] pub fn SkSurface_SkSurface (this : * mut SkSurface , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps) ; } extern "C" { # [link_name = "\u{1}??0SkSurface@@IEAA@AEBUSkImageInfo@@PEBVSkSurfaceProps@@@Z"] pub fn SkSurface_SkSurface1 (this : * mut SkSurface , imageInfo : * const SkImageInfo , surfaceProps : * const SkSurfaceProps) ; } impl SkSurface { # [inline] pub unsafe fn MakeRasterDirect (imageInfo : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > { SkSurface_MakeRasterDirect (imageInfo , pixels , rowBytes , surfaceProps) } # [inline] pub unsafe fn MakeRasterDirectReleaseProc (imageInfo : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , releaseProc : :: core :: option :: Option < unsafe extern "C" fn (pixels : * mut :: core :: ffi :: c_void , context : * mut :: core :: ffi :: c_void) > , context : * mut :: core :: ffi :: c_void , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > { SkSurface_MakeRasterDirectReleaseProc (imageInfo , pixels , rowBytes , releaseProc , context , surfaceProps) } # [inline] pub unsafe fn MakeRaster (imageInfo : * const SkImageInfo , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > { SkSurface_MakeRaster (imageInfo , rowBytes , surfaceProps) } # [inline] pub unsafe fn MakeRasterN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps) -> sk_sp < SkSurface > { SkSurface_MakeRasterN32Premul (width , height , surfaceProps) } # [inline] pub unsafe fn MakeFromBackendTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext) -> sk_sp < SkSurface > { SkSurface_MakeFromBackendTexture (context , backendTexture , origin , sampleCnt , colorType , colorSpace , surfaceProps , textureReleaseProc , releaseContext) } # [inline] pub unsafe fn MakeFromBackendRenderTarget (context : * mut GrRecordingContext , backendRenderTarget : * const GrBackendRenderTarget , origin : GrSurfaceOrigin , colorType : SkColorType , colorSpace : sk_sp < SkColorSpace > , surfaceProps : * const SkSurfaceProps , releaseProc : SkSurface_RenderTargetReleaseProc , releaseContext : SkSurface_ReleaseContext) -> sk_sp < SkSurface > { SkSurface_MakeFromBackendRenderTarget (context , backendRenderTarget , origin , colorType , colorSpace , surfaceProps , releaseProc , releaseContext) } # [inline] pub unsafe fn MakeRenderTarget (context : * mut GrRecordingContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , surfaceOrigin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , shouldCreateWithMips : bool) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget (context , budgeted , imageInfo , sampleCount , surfaceOrigin , surfaceProps , shouldCreateWithMips) } # [inline] pub unsafe fn MakeRenderTarget1 (context : * mut GrRecordingContext , characterization : * const SkSurfaceCharacterization , budgeted : SkBudgeted) -> sk_sp < SkSurface > { SkSurface_MakeRenderTarget1 (context , characterization , budgeted) } # [inline] pub unsafe fn isCompatible (& self , characterization : * const SkSurfaceCharacterization) -> bool { SkSurface_isCompatible (self , characterization) } # [inline] pub unsafe fn MakeNull (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> sk_sp < SkSurface > { SkSurface_MakeNull (width , height) } # [inline] pub unsafe fn imageInfo (& mut self) -> SkImageInfo { SkSurface_imageInfo (self) } # [inline] pub unsafe fn generationID (& mut self) -> u32 { SkSurface_generationID (self) } # [inline] pub unsafe fn notifyContentWillChange (& mut self , mode : SkSurface_ContentChangeMode) { SkSurface_notifyContentWillChange (self , mode) } # [inline] pub unsafe fn recordingContext (& mut self) -> * mut GrRecordingContext { SkSurface_recordingContext (self) } # [inline] pub unsafe fn recorder (& mut self) -> * mut skgpu_graphite_Recorder { SkSurface_recorder (self) } # [inline] pub unsafe fn getBackendTexture (& mut self , backendHandleAccess : SkSurface_BackendHandleAccess) -> GrBackendTexture { SkSurface_getBackendTexture (self , backendHandleAccess) } # [inline] pub unsafe fn getBackendRenderTarget (& mut self , backendHandleAccess : SkSurface_BackendHandleAccess) -> GrBackendRenderTarget { SkSurface_getBackendRenderTarget (self , backendHandleAccess) } # [inline] pub unsafe fn replaceBackendTexture (& mut self , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , mode : SkSurface_ContentChangeMode , textureReleaseProc : SkSurface_TextureReleaseProc , releaseContext : SkSurface_ReleaseContext) -> bool { SkSurface_replaceBackendTexture (self , backendTexture , origin , mode , textureReleaseProc , releaseContext) } # [inline] pub unsafe fn getCanvas (& mut self) -> * mut SkCanvas { SkSurface_getCanvas (self) } # [inline] pub unsafe fn capabilities (& mut self) -> sk_sp < SkCapabilities > { SkSurface_capabilities (self) } # [inline] pub unsafe fn makeSurface (& mut self , imageInfo : * const SkImageInfo) -> sk_sp < SkSurface > { SkSurface_makeSurface (self , imageInfo) } # [inline] pub unsafe fn makeSurface1 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> sk_sp < SkSurface > { SkSurface_makeSurface1 (self , width , height) } # [inline] pub unsafe fn makeImageSnapshot (& mut self) -> sk_sp < SkImage > { SkSurface_makeImageSnapshot (self) } # [inline] pub unsafe fn makeImageSnapshot1 (& mut self , bounds : * const SkIRect) -> sk_sp < SkImage > { SkSurface_makeImageSnapshot1 (self , bounds) } # [inline] pub unsafe fn draw (& mut self , canvas : * mut SkCanvas , x : SkScalar , y : SkScalar , sampling : * const SkSamplingOptions , paint : * const SkPaint) { SkSurface_draw (self , canvas , x , y , sampling , paint) } # [inline] pub unsafe fn peekPixels (& mut self , pixmap : * mut SkPixmap) -> bool { SkSurface_peekPixels (self , pixmap) } # [inline] pub unsafe fn readPixels (& mut self , dst : * const SkPixmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkSurface_readPixels (self , dst , srcX , srcY) } # [inline] pub unsafe fn readPixels1 (& mut self , dstInfo : * const SkImageInfo , dstPixels : * mut :: core :: ffi :: c_void , dstRowBytes : usize , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkSurface_readPixels1 (self , dstInfo , dstPixels , dstRowBytes , srcX , srcY) } # [inline] pub unsafe fn readPixels2 (& mut self , dst : * const SkBitmap , srcX : :: std :: os :: raw :: c_int , srcY : :: std :: os :: raw :: c_int) -> bool { SkSurface_readPixels2 (self , dst , srcX , srcY) } # [inline] pub unsafe fn asyncRescaleAndReadPixels (& mut self , info : * const SkImageInfo , srcRect : * const SkIRect , rescaleGamma : SkSurface_RescaleGamma , rescaleMode : SkSurface_RescaleMode , callback : SkSurface_ReadPixelsCallback , context : SkSurface_ReadPixelsContext) { SkSurface_asyncRescaleAndReadPixels (self , info , srcRect , rescaleGamma , rescaleMode , callback , context) } # [inline] pub unsafe fn asyncRescaleAndReadPixelsYUV420 (& mut self , yuvColorSpace : SkYUVColorSpace , dstColorSpace : sk_sp < SkColorSpace > , srcRect : * const SkIRect , dstSize : * const SkISize , rescaleGamma : SkSurface_RescaleGamma , rescaleMode : SkSurface_RescaleMode , callback : SkSurface_ReadPixelsCallback , context : SkSurface_ReadPixelsContext) { SkSurface_asyncRescaleAndReadPixelsYUV420 (self , yuvColorSpace , dstColorSpace , srcRect , dstSize , rescaleGamma , rescaleMode , callback , context) } # [inline] pub unsafe fn writePixels (& mut self , src : * const SkPixmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) { SkSurface_writePixels (self , src , dstX , dstY) } # [inline] pub unsafe fn writePixels1 (& mut self , src : * const SkBitmap , dstX : :: std :: os :: raw :: c_int , dstY : :: std :: os :: raw :: c_int) { SkSurface_writePixels1 (self , src , dstX , dstY) } # [inline] pub unsafe fn flushAndSubmit (& mut self , syncCpu : bool) { SkSurface_flushAndSubmit (self , syncCpu) } # [inline] pub unsafe fn resolveMSAA (& mut self) { SkSurface_resolveMSAA (self) } # [inline] pub unsafe fn flush (& mut self , access : SkSurface_BackendSurfaceAccess , info : * const GrFlushInfo) -> GrSemaphoresSubmitted { SkSurface_flush (self , access , info) } # [inline] pub unsafe fn flush1 (& mut self , info : * const GrFlushInfo , newState : * const GrBackendSurfaceMutableState) -> GrSemaphoresSubmitted { SkSurface_flush1 (self , info , newState) } # [inline] pub unsafe fn flush2 (& mut self) { SkSurface_flush2 (self) } # [inline] pub unsafe fn wait (& mut self , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore , deleteSemaphoresAfterWait : bool) -> bool { SkSurface_wait (self , numSemaphores , waitSemaphores , deleteSemaphoresAfterWait) } # [inline] pub unsafe fn characterize (& self , characterization : * mut SkSurfaceCharacterization) -> bool { SkSurface_characterize (self , characterization) } # [inline] pub unsafe fn draw1 (& mut self , deferredDisplayList : sk_sp < SkDeferredDisplayList > , xOffset : :: std :: os :: raw :: c_int , yOffset : :: std :: os :: raw :: c_int) -> bool { SkSurface_draw1 (self , deferredDisplayList , xOffset , yOffset) } # [inline] pub unsafe fn new (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkSurface_SkSurface (__bindgen_tmp . as_mut_ptr () , width , height , surfaceProps) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (imageInfo : * const SkImageInfo , surfaceProps : * const SkSurfaceProps) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkSurface_SkSurface1 (__bindgen_tmp . as_mut_ptr () , imageInfo , surfaceProps) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?kFlushRead_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"] pub static SkSurface_kFlushRead_TextureHandleAccess : SkSurface_BackendHandleAccess ; } extern "C" { # [link_name = "\u{1}?kFlushWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"] pub static SkSurface_kFlushWrite_TextureHandleAccess : SkSurface_BackendHandleAccess ; } extern "C" { # [link_name = "\u{1}?kDiscardWrite_TextureHandleAccess@SkSurface@@2W4BackendHandleAccess@1@B"] pub static SkSurface_kDiscardWrite_TextureHandleAccess : SkSurface_BackendHandleAccess ; } extern "C" { # [link_name = "\u{1}?SkSwapRB@@YAXPEAIPEBIH@Z"] pub fn SkSwapRB (dest : * mut u32 , src : * const u32 , count : :: std :: os :: raw :: c_int) ; } # [repr (C)] # [derive (Debug)] pub struct SkTextBlob { pub _base : SkNVRefCnt , pub fBounds : SkRect , pub fUniqueID : u32 , pub fCacheID : u32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTextBlob_RunRecord { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTextBlob_Iter { pub fRunRecord : * const SkTextBlob_RunRecord , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTextBlob_Iter_Run { pub fTypeface : * mut SkTypeface , pub fGlyphCount : :: std :: os :: raw :: c_int , pub fGlyphIndices : * const u16 , } # [test] fn bindgen_test_layout_SkTextBlob_Iter_Run () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlob_Iter_Run > () , 24usize , concat ! ("Size of: " , stringify ! (SkTextBlob_Iter_Run))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlob_Iter_Run > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlob_Iter_Run))) ; fn test_field_fTypeface () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_Run > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTypeface) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_Run) , "::" , stringify ! (fTypeface))) ; } test_field_fTypeface () ; fn test_field_fGlyphCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_Run > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphCount) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_Run) , "::" , stringify ! (fGlyphCount))) ; } test_field_fGlyphCount () ; fn test_field_fGlyphIndices () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_Run > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphIndices) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_Run) , "::" , stringify ! (fGlyphIndices))) ; } test_field_fGlyphIndices () ; } # [repr (C)] # [derive (Debug)] pub struct SkTextBlob_Iter_ExperimentalRun { pub font : SkFont , pub count : :: std :: os :: raw :: c_int , pub glyphs : * const u16 , pub positions : * const SkPoint , } # [test] fn bindgen_test_layout_SkTextBlob_Iter_ExperimentalRun () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlob_Iter_ExperimentalRun > () , 48usize , concat ! ("Size of: " , stringify ! (SkTextBlob_Iter_ExperimentalRun))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlob_Iter_ExperimentalRun > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlob_Iter_ExperimentalRun))) ; fn test_field_font () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_ExperimentalRun > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . font) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_ExperimentalRun) , "::" , stringify ! (font))) ; } test_field_font () ; fn test_field_count () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_ExperimentalRun > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_ExperimentalRun) , "::" , stringify ! (count))) ; } test_field_count () ; fn test_field_glyphs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_ExperimentalRun > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . glyphs) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_ExperimentalRun) , "::" , stringify ! (glyphs))) ; } test_field_glyphs () ; fn test_field_positions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter_ExperimentalRun > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . positions) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter_ExperimentalRun) , "::" , stringify ! (positions))) ; } test_field_positions () ; } # [test] fn bindgen_test_layout_SkTextBlob_Iter () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlob_Iter > () , 8usize , concat ! ("Size of: " , stringify ! (SkTextBlob_Iter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlob_Iter > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlob_Iter))) ; fn test_field_fRunRecord () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob_Iter > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRunRecord) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob_Iter) , "::" , stringify ! (fRunRecord))) ; } test_field_fRunRecord () ; } extern "C" { # [link_name = "\u{1}?next@Iter@SkTextBlob@@QEAA_NPEAURun@12@@Z"] pub fn SkTextBlob_Iter_next (this : * mut SkTextBlob_Iter , arg1 : * mut SkTextBlob_Iter_Run) -> bool ; } extern "C" { # [link_name = "\u{1}?experimentalNext@Iter@SkTextBlob@@QEAA_NPEAUExperimentalRun@12@@Z"] pub fn SkTextBlob_Iter_experimentalNext (this : * mut SkTextBlob_Iter , arg1 : * mut SkTextBlob_Iter_ExperimentalRun) -> bool ; } extern "C" { # [link_name = "\u{1}??0Iter@SkTextBlob@@QEAA@AEBV1@@Z"] pub fn SkTextBlob_Iter_Iter (this : * mut SkTextBlob_Iter , arg1 : * const SkTextBlob) ; } impl SkTextBlob_Iter { # [inline] pub unsafe fn next (& mut self , arg1 : * mut SkTextBlob_Iter_Run) -> bool { SkTextBlob_Iter_next (self , arg1) } # [inline] pub unsafe fn experimentalNext (& mut self , arg1 : * mut SkTextBlob_Iter_ExperimentalRun) -> bool { SkTextBlob_Iter_experimentalNext (self , arg1) } # [inline] pub unsafe fn new (arg1 : * const SkTextBlob) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkTextBlob_Iter_Iter (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTextBlob_GlyphPositioning { __bindgen_cannot_repr_c_on_empty_enum = 0 } pub type SkTextBlob_INHERITED = SkRefCnt ; # [test] fn bindgen_test_layout_SkTextBlob () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlob > () , 28usize , concat ! ("Size of: " , stringify ! (SkTextBlob))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlob > () , 4usize , concat ! ("Alignment of " , stringify ! (SkTextBlob))) ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fUniqueID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUniqueID) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob) , "::" , stringify ! (fUniqueID))) ; } test_field_fUniqueID () ; fn test_field_fCacheID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlob > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCacheID) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkTextBlob) , "::" , stringify ! (fCacheID))) ; } test_field_fCacheID () ; } extern "C" { # [link_name = "\u{1}?getIntercepts@SkTextBlob@@QEBAHQEBMQEAMPEBVSkPaint@@@Z"] pub fn SkTextBlob_getIntercepts (this : * const SkTextBlob , bounds : * const SkScalar , intervals : * mut SkScalar , paint : * const SkPaint) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?MakeFromText@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@PEBX_KAEBVSkFont@@W4SkTextEncoding@@@Z"] pub fn SkTextBlob_MakeFromText (text : * const :: core :: ffi :: c_void , byteLength : usize , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > ; } extern "C" { # [link_name = "\u{1}?MakeFromPosTextH@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@PEBX_KQEBMMAEBVSkFont@@W4SkTextEncoding@@@Z"] pub fn SkTextBlob_MakeFromPosTextH (text : * const :: core :: ffi :: c_void , byteLength : usize , xpos : * const SkScalar , constY : SkScalar , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > ; } extern "C" { # [link_name = "\u{1}?MakeFromPosText@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@PEBX_KQEBUSkPoint@@AEBVSkFont@@W4SkTextEncoding@@@Z"] pub fn SkTextBlob_MakeFromPosText (text : * const :: core :: ffi :: c_void , byteLength : usize , pos : * const SkPoint , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > ; } extern "C" { # [link_name = "\u{1}?MakeFromRSXform@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@PEBX_KQEBUSkRSXform@@AEBVSkFont@@W4SkTextEncoding@@@Z"] pub fn SkTextBlob_MakeFromRSXform (text : * const :: core :: ffi :: c_void , byteLength : usize , xform : * const SkRSXform , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > ; } extern "C" { # [link_name = "\u{1}?serialize@SkTextBlob@@QEBA_KAEBUSkSerialProcs@@PEAX_K@Z"] pub fn SkTextBlob_serialize (this : * const SkTextBlob , procs : * const SkSerialProcs , memory : * mut :: core :: ffi :: c_void , memory_size : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?serialize@SkTextBlob@@QEBA?AV?$sk_sp@VSkData@@@@AEBUSkSerialProcs@@@Z"] pub fn SkTextBlob_serialize1 (this : * const SkTextBlob , procs : * const SkSerialProcs) -> sk_sp < SkData > ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkTextBlob@@SA?AV?$sk_sp@VSkTextBlob@@@@PEBX_KAEBUSkDeserialProcs@@@Z"] pub fn SkTextBlob_Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkTextBlob > ; } impl SkTextBlob { # [inline] pub unsafe fn getIntercepts (& self , bounds : * const SkScalar , intervals : * mut SkScalar , paint : * const SkPaint) -> :: std :: os :: raw :: c_int { SkTextBlob_getIntercepts (self , bounds , intervals , paint) } # [inline] pub unsafe fn MakeFromText (text : * const :: core :: ffi :: c_void , byteLength : usize , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > { SkTextBlob_MakeFromText (text , byteLength , font , encoding) } # [inline] pub unsafe fn MakeFromPosTextH (text : * const :: core :: ffi :: c_void , byteLength : usize , xpos : * const SkScalar , constY : SkScalar , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > { SkTextBlob_MakeFromPosTextH (text , byteLength , xpos , constY , font , encoding) } # [inline] pub unsafe fn MakeFromPosText (text : * const :: core :: ffi :: c_void , byteLength : usize , pos : * const SkPoint , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > { SkTextBlob_MakeFromPosText (text , byteLength , pos , font , encoding) } # [inline] pub unsafe fn MakeFromRSXform (text : * const :: core :: ffi :: c_void , byteLength : usize , xform : * const SkRSXform , font : * const SkFont , encoding : SkTextEncoding) -> sk_sp < SkTextBlob > { SkTextBlob_MakeFromRSXform (text , byteLength , xform , font , encoding) } # [inline] pub unsafe fn serialize (& self , procs : * const SkSerialProcs , memory : * mut :: core :: ffi :: c_void , memory_size : usize) -> usize { SkTextBlob_serialize (self , procs , memory , memory_size) } # [inline] pub unsafe fn serialize1 (& self , procs : * const SkSerialProcs) -> sk_sp < SkData > { SkTextBlob_serialize1 (self , procs) } # [inline] pub unsafe fn Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkTextBlob > { SkTextBlob_Deserialize (data , size , procs) } } # [repr (C)] # [derive (Debug)] pub struct SkTextBlobBuilder { pub fStorage : u64 , pub fStorageSize : usize , pub fStorageUsed : usize , pub fBounds : SkRect , pub fRunCount : :: std :: os :: raw :: c_int , pub fDeferredBounds : bool , pub fLastRun : usize , pub fCurrentRunBuffer : SkTextBlobBuilder_RunBuffer , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTextBlobBuilder_RunBuffer { pub glyphs : * mut SkGlyphID , pub pos : * mut SkScalar , pub utf8text : * mut :: std :: os :: raw :: c_char , pub clusters : * mut u32 , } # [test] fn bindgen_test_layout_SkTextBlobBuilder_RunBuffer () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlobBuilder_RunBuffer > () , 32usize , concat ! ("Size of: " , stringify ! (SkTextBlobBuilder_RunBuffer))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlobBuilder_RunBuffer > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlobBuilder_RunBuffer))) ; fn test_field_glyphs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder_RunBuffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . glyphs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder_RunBuffer) , "::" , stringify ! (glyphs))) ; } test_field_glyphs () ; fn test_field_pos () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder_RunBuffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . pos) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder_RunBuffer) , "::" , stringify ! (pos))) ; } test_field_pos () ; fn test_field_utf8text () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder_RunBuffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . utf8text) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder_RunBuffer) , "::" , stringify ! (utf8text))) ; } test_field_utf8text () ; fn test_field_clusters () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder_RunBuffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . clusters) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder_RunBuffer) , "::" , stringify ! (clusters))) ; } test_field_clusters () ; } # [test] fn bindgen_test_layout_SkTextBlobBuilder () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlobBuilder > () , 88usize , concat ! ("Size of: " , stringify ! (SkTextBlobBuilder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlobBuilder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlobBuilder))) ; fn test_field_fStorage () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStorage) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fStorage))) ; } test_field_fStorage () ; fn test_field_fStorageSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStorageSize) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fStorageSize))) ; } test_field_fStorageSize () ; fn test_field_fStorageUsed () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStorageUsed) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fStorageUsed))) ; } test_field_fStorageUsed () ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fRunCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRunCount) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fRunCount))) ; } test_field_fRunCount () ; fn test_field_fDeferredBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDeferredBounds) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fDeferredBounds))) ; } test_field_fDeferredBounds () ; fn test_field_fLastRun () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastRun) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fLastRun))) ; } test_field_fLastRun () ; fn test_field_fCurrentRunBuffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCurrentRunBuffer) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilder) , "::" , stringify ! (fCurrentRunBuffer))) ; } test_field_fCurrentRunBuffer () ; } extern "C" { # [link_name = "\u{1}?make@SkTextBlobBuilder@@QEAA?AV?$sk_sp@VSkTextBlob@@@@XZ"] pub fn SkTextBlobBuilder_make (this : * mut SkTextBlobBuilder) -> sk_sp < SkTextBlob > ; } extern "C" { # [link_name = "\u{1}?allocRun@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HMMPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRun (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , x : SkScalar , y : SkScalar , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunPosH@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HMPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunPosH (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , y : SkScalar , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunPos@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunPos (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunRSXform@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@H@Z"] pub fn SkTextBlobBuilder_allocRunRSXform (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunText@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HMMHPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunText (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , x : SkScalar , y : SkScalar , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunTextPosH@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HMHPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunTextPosH (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , y : SkScalar , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunTextPos@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HHPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunTextPos (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}?allocRunTextRSXform@SkTextBlobBuilder@@QEAAAEBURunBuffer@1@AEBVSkFont@@HHPEBUSkRect@@@Z"] pub fn SkTextBlobBuilder_allocRunTextRSXform (this : * mut SkTextBlobBuilder , font : * const SkFont , count : :: std :: os :: raw :: c_int , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer ; } extern "C" { # [link_name = "\u{1}??0SkTextBlobBuilder@@QEAA@XZ"] pub fn SkTextBlobBuilder_SkTextBlobBuilder (this : * mut SkTextBlobBuilder) ; } impl SkTextBlobBuilder { # [inline] pub unsafe fn make (& mut self) -> sk_sp < SkTextBlob > { SkTextBlobBuilder_make (self) } # [inline] pub unsafe fn allocRun (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , x : SkScalar , y : SkScalar , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRun (self , font , count , x , y , bounds) } # [inline] pub unsafe fn allocRunPosH (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , y : SkScalar , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunPosH (self , font , count , y , bounds) } # [inline] pub unsafe fn allocRunPos (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunPos (self , font , count , bounds) } # [inline] pub unsafe fn allocRunRSXform (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunRSXform (self , font , count) } # [inline] pub unsafe fn allocRunText (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , x : SkScalar , y : SkScalar , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunText (self , font , count , x , y , textByteCount , bounds) } # [inline] pub unsafe fn allocRunTextPosH (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , y : SkScalar , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunTextPosH (self , font , count , y , textByteCount , bounds) } # [inline] pub unsafe fn allocRunTextPos (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunTextPos (self , font , count , textByteCount , bounds) } # [inline] pub unsafe fn allocRunTextRSXform (& mut self , font : * const SkFont , count : :: std :: os :: raw :: c_int , textByteCount : :: std :: os :: raw :: c_int , bounds : * const SkRect) -> * const SkTextBlobBuilder_RunBuffer { SkTextBlobBuilder_allocRunTextRSXform (self , font , count , textByteCount , bounds) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkTextBlobBuilder_SkTextBlobBuilder (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkVertices { pub _base : SkNVRefCnt , pub fUniqueID : u32 , pub fPositions : * mut SkPoint , pub fIndices : * mut u16 , pub fTexs : * mut SkPoint , pub fColors : * mut SkColor , pub fBounds : SkRect , pub fVertexCount : :: std :: os :: raw :: c_int , pub fIndexCount : :: std :: os :: raw :: c_int , pub fMode : SkVertices_VertexMode , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkVertices_Desc { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkVertices_Sizes { _unused : [u8 ; 0] , } impl SkVertices_VertexMode { pub const Last : SkVertices_VertexMode = SkVertices_VertexMode :: TriangleFan ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkVertices_VertexMode { Triangles = 0 , TriangleStrip = 1 , TriangleFan = 2 , } pub const SkVertices_BuilderFlags_kHasTexCoords_BuilderFlag : SkVertices_BuilderFlags = 1 ; pub const SkVertices_BuilderFlags_kHasColors_BuilderFlag : SkVertices_BuilderFlags = 2 ; pub type SkVertices_BuilderFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug)] pub struct SkVertices_Builder { pub fVertices : sk_sp < SkVertices > , pub fIntermediateFanIndices : u64 , } # [test] fn bindgen_test_layout_SkVertices_Builder () { assert_eq ! (:: core :: mem :: size_of :: < SkVertices_Builder > () , 16usize , concat ! ("Size of: " , stringify ! (SkVertices_Builder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkVertices_Builder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkVertices_Builder))) ; fn test_field_fVertices () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices_Builder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVertices) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkVertices_Builder) , "::" , stringify ! (fVertices))) ; } test_field_fVertices () ; fn test_field_fIntermediateFanIndices () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices_Builder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIntermediateFanIndices) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkVertices_Builder) , "::" , stringify ! (fIntermediateFanIndices))) ; } test_field_fIntermediateFanIndices () ; } extern "C" { # [link_name = "\u{1}?positions@Builder@SkVertices@@QEAAPEAUSkPoint@@XZ"] pub fn SkVertices_Builder_positions (this : * mut SkVertices_Builder) -> * mut SkPoint ; } extern "C" { # [link_name = "\u{1}?indices@Builder@SkVertices@@QEAAPEAGXZ"] pub fn SkVertices_Builder_indices (this : * mut SkVertices_Builder) -> * mut u16 ; } extern "C" { # [link_name = "\u{1}?texCoords@Builder@SkVertices@@QEAAPEAUSkPoint@@XZ"] pub fn SkVertices_Builder_texCoords (this : * mut SkVertices_Builder) -> * mut SkPoint ; } extern "C" { # [link_name = "\u{1}?colors@Builder@SkVertices@@QEAAPEAIXZ"] pub fn SkVertices_Builder_colors (this : * mut SkVertices_Builder) -> * mut SkColor ; } extern "C" { # [link_name = "\u{1}?detach@Builder@SkVertices@@QEAA?AV?$sk_sp@VSkVertices@@@@XZ"] pub fn SkVertices_Builder_detach (this : * mut SkVertices_Builder) -> sk_sp < SkVertices > ; } extern "C" { # [link_name = "\u{1}??0Builder@SkVertices@@QEAA@W4VertexMode@1@HHI@Z"] pub fn SkVertices_Builder_Builder (this : * mut SkVertices_Builder , mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , indexCount : :: std :: os :: raw :: c_int , flags : u32) ; } impl SkVertices_Builder { # [inline] pub unsafe fn positions (& mut self) -> * mut SkPoint { SkVertices_Builder_positions (self) } # [inline] pub unsafe fn indices (& mut self) -> * mut u16 { SkVertices_Builder_indices (self) } # [inline] pub unsafe fn texCoords (& mut self) -> * mut SkPoint { SkVertices_Builder_texCoords (self) } # [inline] pub unsafe fn colors (& mut self) -> * mut SkColor { SkVertices_Builder_colors (self) } # [inline] pub unsafe fn detach (& mut self) -> sk_sp < SkVertices > { SkVertices_Builder_detach (self) } # [inline] pub unsafe fn new (mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , indexCount : :: std :: os :: raw :: c_int , flags : u32) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkVertices_Builder_Builder (__bindgen_tmp . as_mut_ptr () , mode , vertexCount , indexCount , flags) ; __bindgen_tmp . assume_init () } } # [test] fn bindgen_test_layout_SkVertices () { assert_eq ! (:: core :: mem :: size_of :: < SkVertices > () , 72usize , concat ! ("Size of: " , stringify ! (SkVertices))) ; assert_eq ! (:: core :: mem :: align_of :: < SkVertices > () , 8usize , concat ! ("Alignment of " , stringify ! (SkVertices))) ; fn test_field_fUniqueID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUniqueID) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fUniqueID))) ; } test_field_fUniqueID () ; fn test_field_fPositions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPositions) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fPositions))) ; } test_field_fPositions () ; fn test_field_fIndices () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIndices) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fIndices))) ; } test_field_fIndices () ; fn test_field_fTexs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTexs) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fTexs))) ; } test_field_fTexs () ; fn test_field_fColors () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColors) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fColors))) ; } test_field_fColors () ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fVertexCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVertexCount) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fVertexCount))) ; } test_field_fVertexCount () ; fn test_field_fIndexCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIndexCount) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fIndexCount))) ; } test_field_fIndexCount () ; fn test_field_fMode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkVertices > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMode) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (SkVertices) , "::" , stringify ! (fMode))) ; } test_field_fMode () ; } extern "C" { # [link_name = "\u{1}?MakeCopy@SkVertices@@SA?AV?$sk_sp@VSkVertices@@@@W4VertexMode@1@HQEBUSkPoint@@1QEBIHQEBG@Z"] pub fn SkVertices_MakeCopy (mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , indexCount : :: std :: os :: raw :: c_int , indices : * const u16) -> sk_sp < SkVertices > ; } extern "C" { # [link_name = "\u{1}?approximateSize@SkVertices@@QEBA_KXZ"] pub fn SkVertices_approximateSize (this : * const SkVertices) -> usize ; } impl SkVertices { # [inline] pub unsafe fn MakeCopy (mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , indexCount : :: std :: os :: raw :: c_int , indices : * const u16) -> sk_sp < SkVertices > { SkVertices_MakeCopy (mode , vertexCount , positions , texs , colors , indexCount , indices) } # [inline] pub unsafe fn approximateSize (& self) -> usize { SkVertices_approximateSize (self) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTime_DateTime { pub fTimeZoneMinutes : i16 , pub fYear : u16 , pub fMonth : u8 , pub fDayOfWeek : u8 , pub fDay : u8 , pub fHour : u8 , pub fMinute : u8 , pub fSecond : u8 , } # [test] fn bindgen_test_layout_SkTime_DateTime () { assert_eq ! (:: core :: mem :: size_of :: < SkTime_DateTime > () , 10usize , concat ! ("Size of: " , stringify ! (SkTime_DateTime))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTime_DateTime > () , 2usize , concat ! ("Alignment of " , stringify ! (SkTime_DateTime))) ; fn test_field_fTimeZoneMinutes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTimeZoneMinutes) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fTimeZoneMinutes))) ; } test_field_fTimeZoneMinutes () ; fn test_field_fYear () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYear) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fYear))) ; } test_field_fYear () ; fn test_field_fMonth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMonth) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fMonth))) ; } test_field_fMonth () ; fn test_field_fDayOfWeek () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDayOfWeek) as usize - ptr as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fDayOfWeek))) ; } test_field_fDayOfWeek () ; fn test_field_fDay () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDay) as usize - ptr as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fDay))) ; } test_field_fDay () ; fn test_field_fHour () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHour) as usize - ptr as usize } , 7usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fHour))) ; } test_field_fHour () ; fn test_field_fMinute () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMinute) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fMinute))) ; } test_field_fMinute () ; fn test_field_fSecond () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTime_DateTime > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSecond) as usize - ptr as usize } , 9usize , concat ! ("Offset of field: " , stringify ! (SkTime_DateTime) , "::" , stringify ! (fSecond))) ; } test_field_fSecond () ; } extern "C" { # [link_name = "\u{1}?toISO8601@DateTime@SkTime@@QEBAXPEAVSkString@@@Z"] pub fn SkTime_DateTime_toISO8601 (this : * const SkTime_DateTime , dst : * mut SkString) ; } impl SkTime_DateTime { # [inline] pub unsafe fn toISO8601 (& self , dst : * mut SkString) { SkTime_DateTime_toISO8601 (self , dst) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPDFArray { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug)] pub struct SkPDF_AttributeList { pub fAttrs : u64 , } # [test] fn bindgen_test_layout_SkPDF_AttributeList () { assert_eq ! (:: core :: mem :: size_of :: < SkPDF_AttributeList > () , 8usize , concat ! ("Size of: " , stringify ! (SkPDF_AttributeList))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPDF_AttributeList > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPDF_AttributeList))) ; fn test_field_fAttrs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_AttributeList > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAttrs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPDF_AttributeList) , "::" , stringify ! (fAttrs))) ; } test_field_fAttrs () ; } extern "C" { # [link_name = "\u{1}?appendInt@AttributeList@SkPDF@@QEAAXPEBD0H@Z"] pub fn SkPDF_AttributeList_appendInt (this : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : :: std :: os :: raw :: c_int) ; } extern "C" { # [link_name = "\u{1}?appendFloat@AttributeList@SkPDF@@QEAAXPEBD0M@Z"] pub fn SkPDF_AttributeList_appendFloat (this : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : f32) ; } extern "C" { # [link_name = "\u{1}?appendName@AttributeList@SkPDF@@QEAAXPEBD00@Z"] pub fn SkPDF_AttributeList_appendName (this : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , attrName : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?appendFloatArray@AttributeList@SkPDF@@QEAAXPEBD0AEBV?$vector@MV?$allocator@M@std@@@std@@@Z"] pub fn SkPDF_AttributeList_appendFloatArray (this : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : * const [u64 ; 3usize]) ; } extern "C" { # [link_name = "\u{1}?appendNodeIdArray@AttributeList@SkPDF@@QEAAXPEBD0AEBV?$vector@HV?$allocator@H@std@@@std@@@Z"] pub fn SkPDF_AttributeList_appendNodeIdArray (this : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , attrName : * const :: std :: os :: raw :: c_char , nodeIds : * const [u64 ; 3usize]) ; } extern "C" { # [link_name = "\u{1}??0AttributeList@SkPDF@@QEAA@XZ"] pub fn SkPDF_AttributeList_AttributeList (this : * mut SkPDF_AttributeList) ; } impl SkPDF_AttributeList { # [inline] pub unsafe fn appendInt (& mut self , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : :: std :: os :: raw :: c_int) { SkPDF_AttributeList_appendInt (self , owner , name , value) } # [inline] pub unsafe fn appendFloat (& mut self , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : f32) { SkPDF_AttributeList_appendFloat (self , owner , name , value) } # [inline] pub unsafe fn appendName (& mut self , owner : * const :: std :: os :: raw :: c_char , attrName : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) { SkPDF_AttributeList_appendName (self , owner , attrName , value) } # [inline] pub unsafe fn appendFloatArray (& mut self , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : * const [u64 ; 3usize]) { SkPDF_AttributeList_appendFloatArray (self , owner , name , value) } # [inline] pub unsafe fn appendNodeIdArray (& mut self , owner : * const :: std :: os :: raw :: c_char , attrName : * const :: std :: os :: raw :: c_char , nodeIds : * const [u64 ; 3usize]) { SkPDF_AttributeList_appendNodeIdArray (self , owner , attrName , nodeIds) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPDF_AttributeList_AttributeList (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct SkPDF_StructureElementNode { pub fTypeString : SkString , pub fChildVector : [u64 ; 3usize] , pub fNodeId : :: std :: os :: raw :: c_int , pub fAdditionalNodeIds : [u64 ; 3usize] , pub fAttributes : SkPDF_AttributeList , pub fAlt : SkString , pub fLang : SkString , } # [test] fn bindgen_test_layout_SkPDF_StructureElementNode () { assert_eq ! (:: core :: mem :: size_of :: < SkPDF_StructureElementNode > () , 88usize , concat ! ("Size of: " , stringify ! (SkPDF_StructureElementNode))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPDF_StructureElementNode > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPDF_StructureElementNode))) ; fn test_field_fTypeString () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTypeString) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fTypeString))) ; } test_field_fTypeString () ; fn test_field_fChildVector () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fChildVector) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fChildVector))) ; } test_field_fChildVector () ; fn test_field_fNodeId () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNodeId) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fNodeId))) ; } test_field_fNodeId () ; fn test_field_fAdditionalNodeIds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAdditionalNodeIds) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fAdditionalNodeIds))) ; } test_field_fAdditionalNodeIds () ; fn test_field_fAttributes () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAttributes) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fAttributes))) ; } test_field_fAttributes () ; fn test_field_fAlt () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlt) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fAlt))) ; } test_field_fAlt () ; fn test_field_fLang () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_StructureElementNode > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLang) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (SkPDF_StructureElementNode) , "::" , stringify ! (fLang))) ; } test_field_fLang () ; } # [repr (C)] # [derive (Debug)] pub struct SkPDF_Metadata { pub fTitle : SkString , pub fAuthor : SkString , pub fSubject : SkString , pub fKeywords : SkString , pub fCreator : SkString , pub fProducer : SkString , pub fCreation : SkTime_DateTime , pub fModified : SkTime_DateTime , pub fRasterDPI : SkScalar , pub fPDFA : bool , pub fEncodingQuality : :: std :: os :: raw :: c_int , pub fStructureElementTreeRoot : * mut SkPDF_StructureElementNode , pub fExecutor : * mut SkExecutor , pub fSubsetter : SkPDF_Metadata_Subsetter , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPDF_Metadata_Subsetter { kHarfbuzz_Subsetter = 0 , kSfntly_Subsetter = 1 , } # [test] fn bindgen_test_layout_SkPDF_Metadata () { assert_eq ! (:: core :: mem :: size_of :: < SkPDF_Metadata > () , 104usize , concat ! ("Size of: " , stringify ! (SkPDF_Metadata))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPDF_Metadata > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPDF_Metadata))) ; fn test_field_fTitle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTitle) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fTitle))) ; } test_field_fTitle () ; fn test_field_fAuthor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAuthor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fAuthor))) ; } test_field_fAuthor () ; fn test_field_fSubject () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubject) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fSubject))) ; } test_field_fSubject () ; fn test_field_fKeywords () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fKeywords) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fKeywords))) ; } test_field_fKeywords () ; fn test_field_fCreator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCreator) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fCreator))) ; } test_field_fCreator () ; fn test_field_fProducer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProducer) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fProducer))) ; } test_field_fProducer () ; fn test_field_fCreation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCreation) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fCreation))) ; } test_field_fCreation () ; fn test_field_fModified () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fModified) as usize - ptr as usize } , 58usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fModified))) ; } test_field_fModified () ; fn test_field_fRasterDPI () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRasterDPI) as usize - ptr as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fRasterDPI))) ; } test_field_fRasterDPI () ; fn test_field_fPDFA () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPDFA) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fPDFA))) ; } test_field_fPDFA () ; fn test_field_fEncodingQuality () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEncodingQuality) as usize - ptr as usize } , 76usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fEncodingQuality))) ; } test_field_fEncodingQuality () ; fn test_field_fStructureElementTreeRoot () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStructureElementTreeRoot) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fStructureElementTreeRoot))) ; } test_field_fStructureElementTreeRoot () ; fn test_field_fExecutor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExecutor) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fExecutor))) ; } test_field_fExecutor () ; fn test_field_fSubsetter () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPDF_Metadata > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSubsetter) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (SkPDF_Metadata) , "::" , stringify ! (fSubsetter))) ; } test_field_fSubsetter () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkPathEffect { pub _bindgen_opaque_blob : [u64 ; 2usize] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathEffect_DashType { kNone_DashType = 0 , kDash_DashType = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPathEffect_DashInfo { pub fIntervals : * mut SkScalar , pub fCount : i32 , pub fPhase : SkScalar , } # [test] fn bindgen_test_layout_SkPathEffect_DashInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkPathEffect_DashInfo > () , 16usize , concat ! ("Size of: " , stringify ! (SkPathEffect_DashInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPathEffect_DashInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPathEffect_DashInfo))) ; fn test_field_fIntervals () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathEffect_DashInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIntervals) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPathEffect_DashInfo) , "::" , stringify ! (fIntervals))) ; } test_field_fIntervals () ; fn test_field_fCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathEffect_DashInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCount) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkPathEffect_DashInfo) , "::" , stringify ! (fCount))) ; } test_field_fCount () ; fn test_field_fPhase () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPathEffect_DashInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPhase) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkPathEffect_DashInfo) , "::" , stringify ! (fPhase))) ; } test_field_fPhase () ; } pub type SkPathEffect_INHERITED = SkFlattenable ; # [test] fn bindgen_test_layout_SkPathEffect () { assert_eq ! (:: core :: mem :: size_of :: < SkPathEffect > () , 16usize , concat ! ("Size of: " , stringify ! (SkPathEffect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPathEffect > () , 8usize , concat ! ("Alignment of " , stringify ! (SkPathEffect))) ; } extern "C" { # [link_name = "\u{1}?MakeSum@SkPathEffect@@SA?AV?$sk_sp@VSkPathEffect@@@@V2@0@Z"] pub fn SkPathEffect_MakeSum (first : sk_sp < SkPathEffect > , second : sk_sp < SkPathEffect >) -> sk_sp < SkPathEffect > ; } extern "C" { # [link_name = "\u{1}?MakeCompose@SkPathEffect@@SA?AV?$sk_sp@VSkPathEffect@@@@V2@0@Z"] pub fn SkPathEffect_MakeCompose (outer : sk_sp < SkPathEffect > , inner : sk_sp < SkPathEffect >) -> sk_sp < SkPathEffect > ; } extern "C" { # [link_name = "\u{1}?asADash@SkPathEffect@@QEBA?AW4DashType@1@PEAUDashInfo@1@@Z"] pub fn SkPathEffect_asADash (this : * const SkPathEffect , info : * mut SkPathEffect_DashInfo) -> SkPathEffect_DashType ; } extern "C" { # [link_name = "\u{1}?filterPath@SkPathEffect@@QEBA_NPEAVSkPath@@AEBV2@PEAVSkStrokeRec@@PEBUSkRect@@@Z"] pub fn SkPathEffect_filterPath (this : * const SkPathEffect , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?filterPath@SkPathEffect@@QEBA_NPEAVSkPath@@AEBV2@PEAVSkStrokeRec@@PEBUSkRect@@AEBVSkMatrix@@@Z"] pub fn SkPathEffect_filterPath1 (this : * const SkPathEffect , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect , ctm : * const SkMatrix) -> bool ; } extern "C" { # [link_name = "\u{1}?needsCTM@SkPathEffect@@QEBA_NXZ"] pub fn SkPathEffect_needsCTM (this : * const SkPathEffect) -> bool ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkPathEffect@@SA?AV?$sk_sp@VSkPathEffect@@@@PEBX_KPEBUSkDeserialProcs@@@Z"] pub fn SkPathEffect_Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkPathEffect > ; } impl SkPathEffect { # [inline] pub unsafe fn MakeSum (first : sk_sp < SkPathEffect > , second : sk_sp < SkPathEffect >) -> sk_sp < SkPathEffect > { SkPathEffect_MakeSum (first , second) } # [inline] pub unsafe fn MakeCompose (outer : sk_sp < SkPathEffect > , inner : sk_sp < SkPathEffect >) -> sk_sp < SkPathEffect > { SkPathEffect_MakeCompose (outer , inner) } # [inline] pub unsafe fn asADash (& self , info : * mut SkPathEffect_DashInfo) -> SkPathEffect_DashType { SkPathEffect_asADash (self , info) } # [inline] pub unsafe fn filterPath (& self , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect) -> bool { SkPathEffect_filterPath (self , dst , src , arg1 , cullR) } # [inline] pub unsafe fn filterPath1 (& self , dst : * mut SkPath , src : * const SkPath , arg1 : * mut SkStrokeRec , cullR : * const SkRect , ctm : * const SkMatrix) -> bool { SkPathEffect_filterPath1 (self , dst , src , arg1 , cullR , ctm) } # [inline] pub unsafe fn needsCTM (& self) -> bool { SkPathEffect_needsCTM (self) } # [inline] pub unsafe fn Deserialize (data : * const :: core :: ffi :: c_void , size : usize , procs : * const SkDeserialProcs) -> sk_sp < SkPathEffect > { SkPathEffect_Deserialize (data , size , procs) } } impl SkPath1DPathEffect_Style { pub const LastEnum : SkPath1DPathEffect_Style = SkPath1DPathEffect_Style :: Morph ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPath1DPathEffect_Style { Translate = 0 , Rotate = 1 , Morph = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkBlender { pub _base : SkFlattenable , } pub type SkBlender_INHERITED = SkFlattenable ; # [test] fn bindgen_test_layout_SkBlender () { assert_eq ! (:: core :: mem :: size_of :: < SkBlender > () , 16usize , concat ! ("Size of: " , stringify ! (SkBlender))) ; assert_eq ! (:: core :: mem :: align_of :: < SkBlender > () , 8usize , concat ! ("Alignment of " , stringify ! (SkBlender))) ; } extern "C" { # [link_name = "\u{1}?Mode@SkBlender@@SA?AV?$sk_sp@VSkBlender@@@@W4SkBlendMode@@@Z"] pub fn SkBlender_Mode (mode : SkBlendMode) -> sk_sp < SkBlender > ; } impl SkBlender { # [inline] pub unsafe fn Mode (mode : SkBlendMode) -> sk_sp < SkBlender > { SkBlender_Mode (mode) } } # [repr (C)] pub struct SkColorMatrix { pub fMat : [u32 ; 20usize] , } # [test] fn bindgen_test_layout_SkColorMatrix () { assert_eq ! (:: core :: mem :: size_of :: < SkColorMatrix > () , 80usize , concat ! ("Size of: " , stringify ! (SkColorMatrix))) ; assert_eq ! (:: core :: mem :: align_of :: < SkColorMatrix > () , 4usize , concat ! ("Alignment of " , stringify ! (SkColorMatrix))) ; fn test_field_fMat () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkColorMatrix > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMat) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkColorMatrix) , "::" , stringify ! (fMat))) ; } test_field_fMat () ; } extern "C" { # [link_name = "\u{1}?RGBtoYUV@SkColorMatrix@@SA?AV1@W4SkYUVColorSpace@@@Z"] pub fn SkColorMatrix_RGBtoYUV (arg1 : SkYUVColorSpace) -> SkColorMatrix ; } extern "C" { # [link_name = "\u{1}?YUVtoRGB@SkColorMatrix@@SA?AV1@W4SkYUVColorSpace@@@Z"] pub fn SkColorMatrix_YUVtoRGB (arg1 : SkYUVColorSpace) -> SkColorMatrix ; } extern "C" { # [link_name = "\u{1}?setIdentity@SkColorMatrix@@QEAAXXZ"] pub fn SkColorMatrix_setIdentity (this : * mut SkColorMatrix) ; } extern "C" { # [link_name = "\u{1}?setScale@SkColorMatrix@@QEAAXMMMM@Z"] pub fn SkColorMatrix_setScale (this : * mut SkColorMatrix , rScale : f32 , gScale : f32 , bScale : f32 , aScale : f32) ; } extern "C" { # [link_name = "\u{1}?postTranslate@SkColorMatrix@@QEAAXMMMM@Z"] pub fn SkColorMatrix_postTranslate (this : * mut SkColorMatrix , dr : f32 , dg : f32 , db : f32 , da : f32) ; } extern "C" { # [link_name = "\u{1}?setConcat@SkColorMatrix@@QEAAXAEBV1@0@Z"] pub fn SkColorMatrix_setConcat (this : * mut SkColorMatrix , a : * const SkColorMatrix , b : * const SkColorMatrix) ; } extern "C" { # [link_name = "\u{1}?setSaturation@SkColorMatrix@@QEAAXM@Z"] pub fn SkColorMatrix_setSaturation (this : * mut SkColorMatrix , sat : f32) ; } impl SkColorMatrix { # [inline] pub unsafe fn RGBtoYUV (arg1 : SkYUVColorSpace) -> SkColorMatrix { SkColorMatrix_RGBtoYUV (arg1) } # [inline] pub unsafe fn YUVtoRGB (arg1 : SkYUVColorSpace) -> SkColorMatrix { SkColorMatrix_YUVtoRGB (arg1) } # [inline] pub unsafe fn setIdentity (& mut self) { SkColorMatrix_setIdentity (self) } # [inline] pub unsafe fn setScale (& mut self , rScale : f32 , gScale : f32 , bScale : f32 , aScale : f32) { SkColorMatrix_setScale (self , rScale , gScale , bScale , aScale) } # [inline] pub unsafe fn postTranslate (& mut self , dr : f32 , dg : f32 , db : f32 , da : f32) { SkColorMatrix_postTranslate (self , dr , dg , db , da) } # [inline] pub unsafe fn setConcat (& mut self , a : * const SkColorMatrix , b : * const SkColorMatrix) { SkColorMatrix_setConcat (self , a , b) } # [inline] pub unsafe fn setSaturation (& mut self , sat : f32) { SkColorMatrix_setSaturation (self , sat) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkGradientShader { pub _address : u8 , } pub const SkGradientShader_Flags_kInterpolateColorsInPremul_Flag : SkGradientShader_Flags = 1 ; pub type SkGradientShader_Flags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkGradientShader () { assert_eq ! (:: core :: mem :: size_of :: < SkGradientShader > () , 1usize , concat ! ("Size of: " , stringify ! (SkGradientShader))) ; assert_eq ! (:: core :: mem :: align_of :: < SkGradientShader > () , 1usize , concat ! ("Alignment of " , stringify ! (SkGradientShader))) ; } extern "C" { # [link_name = "\u{1}?MakeLinear@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@QEBUSkPoint@@QEBIQEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeLinear (pts : * const SkPoint , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeLinear@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@QEBUSkPoint@@QEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeLinear1 (pts : * const SkPoint , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeLinear@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@QEBUSkPoint@@QEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@@Z"] pub fn SkGradientShader_MakeLinear2 (pts : * const SkPoint , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeRadial@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@MQEBIQEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeRadial (center : * const SkPoint , radius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeRadial@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@MQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeRadial1 (center : * const SkPoint , radius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeRadial@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@MQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@@Z"] pub fn SkGradientShader_MakeRadial2 (center : * const SkPoint , radius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeTwoPointConical@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@M0MQEBIQEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeTwoPointConical (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeTwoPointConical@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@M0MQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@IPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeTwoPointConical1 (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeTwoPointConical@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@AEBUSkPoint@@M0MQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@@Z"] pub fn SkGradientShader_MakeTwoPointConical2 (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeSweep@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@MMQEBIQEBMHW4SkTileMode@@MMIPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeSweep (cx : SkScalar , cy : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeSweep@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@MMQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHW4SkTileMode@@MMIPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeSweep1 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeSweep@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@MMQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMHIPEBVSkMatrix@@@Z"] pub fn SkGradientShader_MakeSweep2 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?MakeSweep@SkGradientShader@@SA?AV?$sk_sp@VSkShader@@@@MMQEBU?$SkRGBA4f@$02@@V?$sk_sp@VSkColorSpace@@@@QEBMH@Z"] pub fn SkGradientShader_MakeSweep3 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?RegisterFlattenables@SkGradientShader@@SAXXZ"] pub fn SkGradientShader_RegisterFlattenables () ; } impl SkGradientShader { # [inline] pub unsafe fn MakeLinear (pts : * const SkPoint , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeLinear (pts , colors , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeLinear1 (pts : * const SkPoint , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeLinear1 (pts , colors , colorSpace , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeLinear2 (pts : * const SkPoint , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > { SkGradientShader_MakeLinear2 (pts , colors , colorSpace , pos , count , mode) } # [inline] pub unsafe fn MakeRadial (center : * const SkPoint , radius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeRadial (center , radius , colors , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeRadial1 (center : * const SkPoint , radius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeRadial1 (center , radius , colors , colorSpace , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeRadial2 (center : * const SkPoint , radius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > { SkGradientShader_MakeRadial2 (center , radius , colors , colorSpace , pos , count , mode) } # [inline] pub unsafe fn MakeTwoPointConical (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeTwoPointConical (start , startRadius , end , endRadius , colors , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeTwoPointConical1 (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeTwoPointConical1 (start , startRadius , end , endRadius , colors , colorSpace , pos , count , mode , flags , localMatrix) } # [inline] pub unsafe fn MakeTwoPointConical2 (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode) -> sk_sp < SkShader > { SkGradientShader_MakeTwoPointConical2 (start , startRadius , end , endRadius , colors , colorSpace , pos , count , mode) } # [inline] pub unsafe fn MakeSweep (cx : SkScalar , cy : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeSweep (cx , cy , colors , pos , count , mode , startAngle , endAngle , flags , localMatrix) } # [inline] pub unsafe fn MakeSweep1 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeSweep1 (cx , cy , colors , colorSpace , pos , count , mode , startAngle , endAngle , flags , localMatrix) } # [inline] pub unsafe fn MakeSweep2 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , flags : u32 , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkGradientShader_MakeSweep2 (cx , cy , colors , colorSpace , pos , count , flags , localMatrix) } # [inline] pub unsafe fn MakeSweep3 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : sk_sp < SkColorSpace > , pos : * const SkScalar , count : :: std :: os :: raw :: c_int) -> sk_sp < SkShader > { SkGradientShader_MakeSweep3 (cx , cy , colors , colorSpace , pos , count) } # [inline] pub unsafe fn RegisterFlattenables () { SkGradientShader_RegisterFlattenables () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkHighContrastConfig { pub fGrayscale : bool , pub fInvertStyle : SkHighContrastConfig_InvertStyle , pub fContrast : SkScalar , } impl SkHighContrastConfig_InvertStyle { pub const Last : SkHighContrastConfig_InvertStyle = SkHighContrastConfig_InvertStyle :: InvertLightness ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkHighContrastConfig_InvertStyle { NoInvert = 0 , InvertBrightness = 1 , InvertLightness = 2 , } # [test] fn bindgen_test_layout_SkHighContrastConfig () { assert_eq ! (:: core :: mem :: size_of :: < SkHighContrastConfig > () , 12usize , concat ! ("Size of: " , stringify ! (SkHighContrastConfig))) ; assert_eq ! (:: core :: mem :: align_of :: < SkHighContrastConfig > () , 4usize , concat ! ("Alignment of " , stringify ! (SkHighContrastConfig))) ; fn test_field_fGrayscale () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkHighContrastConfig > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGrayscale) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkHighContrastConfig) , "::" , stringify ! (fGrayscale))) ; } test_field_fGrayscale () ; fn test_field_fInvertStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkHighContrastConfig > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInvertStyle) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkHighContrastConfig) , "::" , stringify ! (fInvertStyle))) ; } test_field_fInvertStyle () ; fn test_field_fContrast () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkHighContrastConfig > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fContrast) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkHighContrastConfig) , "::" , stringify ! (fContrast))) ; } test_field_fContrast () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSpan < T > { pub fPtr : * mut T , pub fSize : usize , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSL_Version { k100 = 0 , k300 = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSL_DebugTrace { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkRuntimeEffect { pub _bindgen_opaque_blob : [u64 ; 16usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRuntimeEffect_Uniform { pub name : std_string_view , pub offset : usize , pub type_ : SkRuntimeEffect_Uniform_Type , pub count : :: std :: os :: raw :: c_int , pub flags : u32 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkRuntimeEffect_Uniform_Type { Float = 0 , Float2 = 1 , Float3 = 2 , Float4 = 3 , Float2x2 = 4 , Float3x3 = 5 , Float4x4 = 6 , Int = 7 , Int2 = 8 , Int3 = 9 , Int4 = 10 , } pub const SkRuntimeEffect_Uniform_Flags_kArray_Flag : SkRuntimeEffect_Uniform_Flags = 1 ; pub const SkRuntimeEffect_Uniform_Flags_kColor_Flag : SkRuntimeEffect_Uniform_Flags = 2 ; pub const SkRuntimeEffect_Uniform_Flags_kVertex_Flag : SkRuntimeEffect_Uniform_Flags = 4 ; pub const SkRuntimeEffect_Uniform_Flags_kFragment_Flag : SkRuntimeEffect_Uniform_Flags = 8 ; pub const SkRuntimeEffect_Uniform_Flags_kHalfPrecision_Flag : SkRuntimeEffect_Uniform_Flags = 16 ; pub type SkRuntimeEffect_Uniform_Flags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkRuntimeEffect_Uniform () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_Uniform > () , 40usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_Uniform))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_Uniform > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_Uniform))) ; fn test_field_name () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Uniform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . name) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Uniform) , "::" , stringify ! (name))) ; } test_field_name () ; fn test_field_offset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Uniform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . offset) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Uniform) , "::" , stringify ! (offset))) ; } test_field_offset () ; fn test_field_type () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Uniform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Uniform) , "::" , stringify ! (type_))) ; } test_field_type () ; fn test_field_count () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Uniform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Uniform) , "::" , stringify ! (count))) ; } test_field_count () ; fn test_field_flags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Uniform > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Uniform) , "::" , stringify ! (flags))) ; } test_field_flags () ; } extern "C" { # [link_name = "\u{1}?sizeInBytes@Uniform@SkRuntimeEffect@@QEBA_KXZ"] pub fn SkRuntimeEffect_Uniform_sizeInBytes (this : * const SkRuntimeEffect_Uniform) -> usize ; } impl SkRuntimeEffect_Uniform { # [inline] pub unsafe fn sizeInBytes (& self) -> usize { SkRuntimeEffect_Uniform_sizeInBytes (self) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkRuntimeEffect_ChildType { Shader = 0 , ColorFilter = 1 , Blender = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRuntimeEffect_Child { pub name : std_string_view , pub type_ : SkRuntimeEffect_ChildType , pub index : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_SkRuntimeEffect_Child () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_Child > () , 24usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_Child))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_Child > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_Child))) ; fn test_field_name () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Child > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . name) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Child) , "::" , stringify ! (name))) ; } test_field_name () ; fn test_field_type () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Child > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . type_) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Child) , "::" , stringify ! (type_))) ; } test_field_type () ; fn test_field_index () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Child > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . index) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Child) , "::" , stringify ! (index))) ; } test_field_index () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkRuntimeEffect_Options { pub forceUnoptimized : bool , pub usePrivateRTShaderModule : bool , pub maxVersionAllowed : SkSL_Version , } # [test] fn bindgen_test_layout_SkRuntimeEffect_Options () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_Options > () , 8usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_Options))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_Options > () , 4usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_Options))) ; fn test_field_forceUnoptimized () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . forceUnoptimized) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Options) , "::" , stringify ! (forceUnoptimized))) ; } test_field_forceUnoptimized () ; fn test_field_usePrivateRTShaderModule () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . usePrivateRTShaderModule) as usize - ptr as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Options) , "::" , stringify ! (usePrivateRTShaderModule))) ; } test_field_usePrivateRTShaderModule () ; fn test_field_maxVersionAllowed () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Options > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . maxVersionAllowed) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Options) , "::" , stringify ! (maxVersionAllowed))) ; } test_field_maxVersionAllowed () ; } # [repr (C)] # [derive (Debug)] pub struct SkRuntimeEffect_Result { pub effect : sk_sp < SkRuntimeEffect > , pub errorText : SkString , } # [test] fn bindgen_test_layout_SkRuntimeEffect_Result () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_Result > () , 16usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_Result))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_Result > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_Result))) ; fn test_field_effect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Result > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . effect) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Result) , "::" , stringify ! (effect))) ; } test_field_effect () ; fn test_field_errorText () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_Result > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . errorText) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_Result) , "::" , stringify ! (errorText))) ; } test_field_errorText () ; } # [repr (C)] # [derive (Debug)] pub struct SkRuntimeEffect_ChildPtr { pub fChild : sk_sp < SkFlattenable > , } # [test] fn bindgen_test_layout_SkRuntimeEffect_ChildPtr () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_ChildPtr > () , 8usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_ChildPtr))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_ChildPtr > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_ChildPtr))) ; fn test_field_fChild () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_ChildPtr > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fChild) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_ChildPtr) , "::" , stringify ! (fChild))) ; } test_field_fChild () ; } extern "C" { # [link_name = "\u{1}?type@ChildPtr@SkRuntimeEffect@@QEBA?AV?$optional@W4ChildType@SkRuntimeEffect@@@std@@XZ"] pub fn SkRuntimeEffect_ChildPtr_type (this : * const SkRuntimeEffect_ChildPtr) -> u8 ; } extern "C" { # [link_name = "\u{1}?shader@ChildPtr@SkRuntimeEffect@@QEBAPEAVSkShader@@XZ"] pub fn SkRuntimeEffect_ChildPtr_shader (this : * const SkRuntimeEffect_ChildPtr) -> * mut SkShader ; } extern "C" { # [link_name = "\u{1}?colorFilter@ChildPtr@SkRuntimeEffect@@QEBAPEAVSkColorFilter@@XZ"] pub fn SkRuntimeEffect_ChildPtr_colorFilter (this : * const SkRuntimeEffect_ChildPtr) -> * mut SkColorFilter ; } extern "C" { # [link_name = "\u{1}?blender@ChildPtr@SkRuntimeEffect@@QEBAPEAVSkBlender@@XZ"] pub fn SkRuntimeEffect_ChildPtr_blender (this : * const SkRuntimeEffect_ChildPtr) -> * mut SkBlender ; } extern "C" { # [link_name = "\u{1}??0ChildPtr@SkRuntimeEffect@@QEAA@V?$sk_sp@VSkFlattenable@@@@@Z"] pub fn SkRuntimeEffect_ChildPtr_ChildPtr (this : * mut SkRuntimeEffect_ChildPtr , f : sk_sp < SkFlattenable >) ; } impl SkRuntimeEffect_ChildPtr { # [inline] pub unsafe fn type_ (& self) -> u8 { SkRuntimeEffect_ChildPtr_type (self) } # [inline] pub unsafe fn shader (& self) -> * mut SkShader { SkRuntimeEffect_ChildPtr_shader (self) } # [inline] pub unsafe fn colorFilter (& self) -> * mut SkColorFilter { SkRuntimeEffect_ChildPtr_colorFilter (self) } # [inline] pub unsafe fn blender (& self) -> * mut SkBlender { SkRuntimeEffect_ChildPtr_blender (self) } # [inline] pub unsafe fn new (f : sk_sp < SkFlattenable >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkRuntimeEffect_ChildPtr_ChildPtr (__bindgen_tmp . as_mut_ptr () , f) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkRuntimeEffect_TracedShader { pub shader : sk_sp < SkShader > , pub debugTrace : sk_sp < SkSL_DebugTrace > , } # [test] fn bindgen_test_layout_SkRuntimeEffect_TracedShader () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect_TracedShader > () , 16usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect_TracedShader))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect_TracedShader > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect_TracedShader))) ; fn test_field_shader () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_TracedShader > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . shader) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_TracedShader) , "::" , stringify ! (shader))) ; } test_field_shader () ; fn test_field_debugTrace () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkRuntimeEffect_TracedShader > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . debugTrace) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkRuntimeEffect_TracedShader) , "::" , stringify ! (debugTrace))) ; } test_field_debugTrace () ; } pub const SkRuntimeEffect_Flags_kUsesSampleCoords_Flag : SkRuntimeEffect_Flags = 1 ; pub const SkRuntimeEffect_Flags_kAllowColorFilter_Flag : SkRuntimeEffect_Flags = 2 ; pub const SkRuntimeEffect_Flags_kAllowShader_Flag : SkRuntimeEffect_Flags = 4 ; pub const SkRuntimeEffect_Flags_kAllowBlender_Flag : SkRuntimeEffect_Flags = 8 ; pub const SkRuntimeEffect_Flags_kSamplesOutsideMain_Flag : SkRuntimeEffect_Flags = 16 ; pub const SkRuntimeEffect_Flags_kUsesColorTransform_Flag : SkRuntimeEffect_Flags = 32 ; pub const SkRuntimeEffect_Flags_kAlwaysOpaque_Flag : SkRuntimeEffect_Flags = 64 ; pub type SkRuntimeEffect_Flags = :: std :: os :: raw :: c_int ; # [test] fn bindgen_test_layout_SkRuntimeEffect () { assert_eq ! (:: core :: mem :: size_of :: < SkRuntimeEffect > () , 128usize , concat ! ("Size of: " , stringify ! (SkRuntimeEffect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkRuntimeEffect > () , 8usize , concat ! ("Alignment of " , stringify ! (SkRuntimeEffect))) ; } extern "C" { # [link_name = "\u{1}?MakeForColorFilter@SkRuntimeEffect@@SA?AUResult@1@VSkString@@AEBVOptions@1@@Z"] pub fn SkRuntimeEffect_MakeForColorFilter (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result ; } extern "C" { # [link_name = "\u{1}?MakeForShader@SkRuntimeEffect@@SA?AUResult@1@VSkString@@AEBVOptions@1@@Z"] pub fn SkRuntimeEffect_MakeForShader (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result ; } extern "C" { # [link_name = "\u{1}?MakeForBlender@SkRuntimeEffect@@SA?AUResult@1@VSkString@@AEBVOptions@1@@Z"] pub fn SkRuntimeEffect_MakeForBlender (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result ; } extern "C" { # [link_name = "\u{1}?makeShader@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@$$CBVSkData@@@@QEAV2@_KPEBVSkMatrix@@@Z"] pub fn SkRuntimeEffect_makeShader (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData > , children : * mut sk_sp < SkShader > , childCount : usize , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?makeShader@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkShader@@@@V?$sk_sp@$$CBVSkData@@@@V?$SkSpan@VChildPtr@SkRuntimeEffect@@@@PEBVSkMatrix@@@Z"] pub fn SkRuntimeEffect_makeShader1 (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr > , localMatrix : * const SkMatrix) -> sk_sp < SkShader > ; } extern "C" { # [link_name = "\u{1}?makeImage@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkImage@@@@PEAVGrRecordingContext@@V?$sk_sp@$$CBVSkData@@@@V?$SkSpan@VChildPtr@SkRuntimeEffect@@@@PEBVSkMatrix@@USkImageInfo@@_N@Z"] pub fn SkRuntimeEffect_makeImage (this : * const SkRuntimeEffect , arg1 : * mut GrRecordingContext , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr > , localMatrix : * const SkMatrix , resultInfo : SkImageInfo , mipmapped : bool) -> sk_sp < SkImage > ; } extern "C" { # [link_name = "\u{1}?makeColorFilter@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkColorFilter@@@@V?$sk_sp@$$CBVSkData@@@@@Z"] pub fn SkRuntimeEffect_makeColorFilter (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData >) -> sk_sp < SkColorFilter > ; } extern "C" { # [link_name = "\u{1}?makeColorFilter@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkColorFilter@@@@V?$sk_sp@$$CBVSkData@@@@QEAV2@_K@Z"] pub fn SkRuntimeEffect_makeColorFilter1 (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData > , children : * mut sk_sp < SkColorFilter > , childCount : usize) -> sk_sp < SkColorFilter > ; } extern "C" { # [link_name = "\u{1}?makeColorFilter@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkColorFilter@@@@V?$sk_sp@$$CBVSkData@@@@V?$SkSpan@VChildPtr@SkRuntimeEffect@@@@@Z"] pub fn SkRuntimeEffect_makeColorFilter2 (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr >) -> sk_sp < SkColorFilter > ; } extern "C" { # [link_name = "\u{1}?makeBlender@SkRuntimeEffect@@QEBA?AV?$sk_sp@VSkBlender@@@@V?$sk_sp@$$CBVSkData@@@@V?$SkSpan@VChildPtr@SkRuntimeEffect@@@@@Z"] pub fn SkRuntimeEffect_makeBlender (this : * const SkRuntimeEffect , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr >) -> sk_sp < SkBlender > ; } extern "C" { # [link_name = "\u{1}?MakeTraced@SkRuntimeEffect@@SA?AUTracedShader@1@V?$sk_sp@VSkShader@@@@AEBUSkIPoint@@@Z"] pub fn SkRuntimeEffect_MakeTraced (shader : sk_sp < SkShader > , traceCoord : * const SkIPoint) -> SkRuntimeEffect_TracedShader ; } extern "C" { # [link_name = "\u{1}?source@SkRuntimeEffect@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ"] pub fn SkRuntimeEffect_source (this : * const SkRuntimeEffect) -> * const std_string ; } extern "C" { # [link_name = "\u{1}?uniformSize@SkRuntimeEffect@@QEBA_KXZ"] pub fn SkRuntimeEffect_uniformSize (this : * const SkRuntimeEffect) -> usize ; } extern "C" { # [link_name = "\u{1}?findUniform@SkRuntimeEffect@@QEBAPEBUUniform@1@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z"] pub fn SkRuntimeEffect_findUniform (this : * const SkRuntimeEffect , name : std_string_view) -> * const SkRuntimeEffect_Uniform ; } extern "C" { # [link_name = "\u{1}?findChild@SkRuntimeEffect@@QEBAPEBUChild@1@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@Z"] pub fn SkRuntimeEffect_findChild (this : * const SkRuntimeEffect , name : std_string_view) -> * const SkRuntimeEffect_Child ; } extern "C" { # [link_name = "\u{1}?RegisterFlattenables@SkRuntimeEffect@@SAXXZ"] pub fn SkRuntimeEffect_RegisterFlattenables () ; } impl SkRuntimeEffect { # [inline] pub unsafe fn MakeForColorFilter (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result { SkRuntimeEffect_MakeForColorFilter (sksl , arg1) } # [inline] pub unsafe fn MakeForShader (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result { SkRuntimeEffect_MakeForShader (sksl , arg1) } # [inline] pub unsafe fn MakeForBlender (sksl : SkString , arg1 : * const SkRuntimeEffect_Options) -> SkRuntimeEffect_Result { SkRuntimeEffect_MakeForBlender (sksl , arg1) } # [inline] pub unsafe fn makeShader (& self , uniforms : sk_sp < SkData > , children : * mut sk_sp < SkShader > , childCount : usize , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkRuntimeEffect_makeShader (self , uniforms , children , childCount , localMatrix) } # [inline] pub unsafe fn makeShader1 (& self , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr > , localMatrix : * const SkMatrix) -> sk_sp < SkShader > { SkRuntimeEffect_makeShader1 (self , uniforms , children , localMatrix) } # [inline] pub unsafe fn makeImage (& self , arg1 : * mut GrRecordingContext , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr > , localMatrix : * const SkMatrix , resultInfo : SkImageInfo , mipmapped : bool) -> sk_sp < SkImage > { SkRuntimeEffect_makeImage (self , arg1 , uniforms , children , localMatrix , resultInfo , mipmapped) } # [inline] pub unsafe fn makeColorFilter (& self , uniforms : sk_sp < SkData >) -> sk_sp < SkColorFilter > { SkRuntimeEffect_makeColorFilter (self , uniforms) } # [inline] pub unsafe fn makeColorFilter1 (& self , uniforms : sk_sp < SkData > , children : * mut sk_sp < SkColorFilter > , childCount : usize) -> sk_sp < SkColorFilter > { SkRuntimeEffect_makeColorFilter1 (self , uniforms , children , childCount) } # [inline] pub unsafe fn makeColorFilter2 (& self , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr >) -> sk_sp < SkColorFilter > { SkRuntimeEffect_makeColorFilter2 (self , uniforms , children) } # [inline] pub unsafe fn makeBlender (& self , uniforms : sk_sp < SkData > , children : SkSpan < SkRuntimeEffect_ChildPtr >) -> sk_sp < SkBlender > { SkRuntimeEffect_makeBlender (self , uniforms , children) } # [inline] pub unsafe fn MakeTraced (shader : sk_sp < SkShader > , traceCoord : * const SkIPoint) -> SkRuntimeEffect_TracedShader { SkRuntimeEffect_MakeTraced (shader , traceCoord) } # [inline] pub unsafe fn source (& self) -> * const std_string { SkRuntimeEffect_source (self) } # [inline] pub unsafe fn uniformSize (& self) -> usize { SkRuntimeEffect_uniformSize (self) } # [inline] pub unsafe fn findUniform (& self , name : std_string_view) -> * const SkRuntimeEffect_Uniform { SkRuntimeEffect_findUniform (self , name) } # [inline] pub unsafe fn findChild (& self , name : std_string_view) -> * const SkRuntimeEffect_Child { SkRuntimeEffect_findChild (self , name) } # [inline] pub unsafe fn RegisterFlattenables () { SkRuntimeEffect_RegisterFlattenables () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkImageFilters_CropRect { pub fCropRect : SkRect , } # [test] fn bindgen_test_layout_SkImageFilters_CropRect () { assert_eq ! (:: core :: mem :: size_of :: < SkImageFilters_CropRect > () , 16usize , concat ! ("Size of: " , stringify ! (SkImageFilters_CropRect))) ; assert_eq ! (:: core :: mem :: align_of :: < SkImageFilters_CropRect > () , 4usize , concat ! ("Alignment of " , stringify ! (SkImageFilters_CropRect))) ; fn test_field_fCropRect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkImageFilters_CropRect > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCropRect) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkImageFilters_CropRect) , "::" , stringify ! (fCropRect))) ; } test_field_fCropRect () ; } # [repr (u8)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkImageFilters_Dither { No = 0 , Yes = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkPathOp { Difference = 0 , Intersect = 1 , Union = 2 , XOR = 3 , ReverseDifference = 4 , } extern "C" { # [link_name = "\u{1}?Op@@YA_NAEBVSkPath@@0W4SkPathOp@@PEAV1@@Z"] pub fn Op (one : * const SkPath , two : * const SkPath , op : SkPathOp , result : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?Simplify@@YA_NAEBVSkPath@@PEAV1@@Z"] pub fn Simplify (path : * const SkPath , result : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?TightBounds@@YA_NAEBVSkPath@@PEAUSkRect@@@Z"] pub fn TightBounds (path : * const SkPath , result : * mut SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?AsWinding@@YA_NAEBVSkPath@@PEAV1@@Z"] pub fn AsWinding (path : * const SkPath , result : * mut SkPath) -> bool ; } # [repr (C)] # [derive (Debug)] pub struct SkOpBuilder { pub fPathRefs : [u64 ; 2usize] , pub fOps : SkTDArray < SkPathOp > , } # [test] fn bindgen_test_layout_SkOpBuilder () { assert_eq ! (:: core :: mem :: size_of :: < SkOpBuilder > () , 32usize , concat ! ("Size of: " , stringify ! (SkOpBuilder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkOpBuilder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkOpBuilder))) ; fn test_field_fPathRefs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkOpBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPathRefs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkOpBuilder) , "::" , stringify ! (fPathRefs))) ; } test_field_fPathRefs () ; fn test_field_fOps () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkOpBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOps) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkOpBuilder) , "::" , stringify ! (fOps))) ; } test_field_fOps () ; } extern "C" { # [link_name = "\u{1}?add@SkOpBuilder@@QEAAXAEBVSkPath@@W4SkPathOp@@@Z"] pub fn SkOpBuilder_add (this : * mut SkOpBuilder , path : * const SkPath , _operator : SkPathOp) ; } extern "C" { # [link_name = "\u{1}?resolve@SkOpBuilder@@QEAA_NPEAVSkPath@@@Z"] pub fn SkOpBuilder_resolve (this : * mut SkOpBuilder , result : * mut SkPath) -> bool ; } impl SkOpBuilder { # [inline] pub unsafe fn add (& mut self , path : * const SkPath , _operator : SkPathOp) { SkOpBuilder_add (self , path , _operator) } # [inline] pub unsafe fn resolve (& mut self , result : * mut SkPath) -> bool { SkOpBuilder_resolve (self , result) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTableMaskFilter { pub _address : u8 , } # [test] fn bindgen_test_layout_SkTableMaskFilter () { assert_eq ! (:: core :: mem :: size_of :: < SkTableMaskFilter > () , 1usize , concat ! ("Size of: " , stringify ! (SkTableMaskFilter))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTableMaskFilter > () , 1usize , concat ! ("Alignment of " , stringify ! (SkTableMaskFilter))) ; } extern "C" { # [link_name = "\u{1}?MakeGammaTable@SkTableMaskFilter@@SAXQEAEM@Z"] pub fn SkTableMaskFilter_MakeGammaTable (table : * mut u8 , gamma : SkScalar) ; } extern "C" { # [link_name = "\u{1}?MakeClipTable@SkTableMaskFilter@@SAXQEAEEE@Z"] pub fn SkTableMaskFilter_MakeClipTable (table : * mut u8 , min : u8 , max : u8) ; } extern "C" { # [link_name = "\u{1}?Create@SkTableMaskFilter@@SAPEAVSkMaskFilter@@QEBE@Z"] pub fn SkTableMaskFilter_Create (table : * const u8) -> * mut SkMaskFilter ; } extern "C" { # [link_name = "\u{1}?CreateGamma@SkTableMaskFilter@@SAPEAVSkMaskFilter@@M@Z"] pub fn SkTableMaskFilter_CreateGamma (gamma : SkScalar) -> * mut SkMaskFilter ; } extern "C" { # [link_name = "\u{1}?CreateClip@SkTableMaskFilter@@SAPEAVSkMaskFilter@@EE@Z"] pub fn SkTableMaskFilter_CreateClip (min : u8 , max : u8) -> * mut SkMaskFilter ; } impl SkTableMaskFilter { # [inline] pub unsafe fn MakeGammaTable (table : * mut u8 , gamma : SkScalar) { SkTableMaskFilter_MakeGammaTable (table , gamma) } # [inline] pub unsafe fn MakeClipTable (table : * mut u8 , min : u8 , max : u8) { SkTableMaskFilter_MakeClipTable (table , min , max) } # [inline] pub unsafe fn Create (table : * const u8) -> * mut SkMaskFilter { SkTableMaskFilter_Create (table) } # [inline] pub unsafe fn CreateGamma (gamma : SkScalar) -> * mut SkMaskFilter { SkTableMaskFilter_CreateGamma (gamma) } # [inline] pub unsafe fn CreateClip (min : u8 , max : u8) -> * mut SkMaskFilter { SkTableMaskFilter_CreateClip (min , max) } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTrimPathEffect_Mode { Normal = 0 , Inverted = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkSVGCanvas { pub _address : u8 , } pub const SkSVGCanvas_kConvertTextToPaths_Flag : SkSVGCanvas__bindgen_ty_1 = SkSVGCanvas__bindgen_ty_1 :: kConvertTextToPaths_Flag ; pub const SkSVGCanvas_kNoPrettyXML_Flag : SkSVGCanvas__bindgen_ty_1 = SkSVGCanvas__bindgen_ty_1 :: kNoPrettyXML_Flag ; pub const SkSVGCanvas_kRelativePathEncoding_Flag : SkSVGCanvas__bindgen_ty_1 = SkSVGCanvas__bindgen_ty_1 :: kRelativePathEncoding_Flag ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkSVGCanvas__bindgen_ty_1 { kConvertTextToPaths_Flag = 1 , kNoPrettyXML_Flag = 2 , kRelativePathEncoding_Flag = 4 , } # [test] fn bindgen_test_layout_SkSVGCanvas () { assert_eq ! (:: core :: mem :: size_of :: < SkSVGCanvas > () , 1usize , concat ! ("Size of: " , stringify ! (SkSVGCanvas))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSVGCanvas > () , 1usize , concat ! ("Alignment of " , stringify ! (SkSVGCanvas))) ; } extern "C" { # [link_name = "\u{1}?Make@SkSVGCanvas@@SA?AV?$unique_ptr@VSkCanvas@@U?$default_delete@VSkCanvas@@@std@@@std@@AEBUSkRect@@PEAVSkWStream@@I@Z"] pub fn SkSVGCanvas_Make (bounds : * const SkRect , arg1 : * mut SkWStream , flags : u32) -> u64 ; } impl SkSVGCanvas { # [inline] pub unsafe fn Make (bounds : * const SkRect , arg1 : * mut SkWStream , flags : u32) -> u64 { SkSVGCanvas_Make (bounds , arg1 , flags) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkPatch3D { pub fU : SkV3 , pub fV : SkV3 , pub fOrigin : SkV3 , } # [test] fn bindgen_test_layout_SkPatch3D () { assert_eq ! (:: core :: mem :: size_of :: < SkPatch3D > () , 36usize , concat ! ("Size of: " , stringify ! (SkPatch3D))) ; assert_eq ! (:: core :: mem :: align_of :: < SkPatch3D > () , 4usize , concat ! ("Alignment of " , stringify ! (SkPatch3D))) ; fn test_field_fU () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPatch3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fU) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkPatch3D) , "::" , stringify ! (fU))) ; } test_field_fU () ; fn test_field_fV () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPatch3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fV) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkPatch3D) , "::" , stringify ! (fV))) ; } test_field_fV () ; fn test_field_fOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkPatch3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOrigin) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkPatch3D) , "::" , stringify ! (fOrigin))) ; } test_field_fOrigin () ; } extern "C" { # [link_name = "\u{1}?reset@SkPatch3D@@QEAAXXZ"] pub fn SkPatch3D_reset (this : * mut SkPatch3D) ; } extern "C" { # [link_name = "\u{1}?transform@SkPatch3D@@QEBAXAEBVSkM44@@PEAV1@@Z"] pub fn SkPatch3D_transform (this : * const SkPatch3D , arg1 : * const SkM44 , dst : * mut SkPatch3D) ; } extern "C" { # [link_name = "\u{1}?dotWith@SkPatch3D@@QEBAMMMM@Z"] pub fn SkPatch3D_dotWith (this : * const SkPatch3D , dx : SkScalar , dy : SkScalar , dz : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}??0SkPatch3D@@QEAA@XZ"] pub fn SkPatch3D_SkPatch3D (this : * mut SkPatch3D) ; } impl SkPatch3D { # [inline] pub unsafe fn reset (& mut self) { SkPatch3D_reset (self) } # [inline] pub unsafe fn transform (& self , arg1 : * const SkM44 , dst : * mut SkPatch3D) { SkPatch3D_transform (self , arg1 , dst) } # [inline] pub unsafe fn dotWith (& self , dx : SkScalar , dy : SkScalar , dz : SkScalar) -> SkScalar { SkPatch3D_dotWith (self , dx , dy , dz) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkPatch3D_SkPatch3D (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkCamera3D { pub fLocation : SkV3 , pub fAxis : SkV3 , pub fZenith : SkV3 , pub fObserver : SkV3 , pub fOrientation : SkMatrix , pub fNeedToUpdate : bool , } # [test] fn bindgen_test_layout_SkCamera3D () { assert_eq ! (:: core :: mem :: size_of :: < SkCamera3D > () , 92usize , concat ! ("Size of: " , stringify ! (SkCamera3D))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCamera3D > () , 4usize , concat ! ("Alignment of " , stringify ! (SkCamera3D))) ; fn test_field_fLocation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLocation) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fLocation))) ; } test_field_fLocation () ; fn test_field_fAxis () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAxis) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fAxis))) ; } test_field_fAxis () ; fn test_field_fZenith () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fZenith) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fZenith))) ; } test_field_fZenith () ; fn test_field_fObserver () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fObserver) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fObserver))) ; } test_field_fObserver () ; fn test_field_fOrientation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOrientation) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fOrientation))) ; } test_field_fOrientation () ; fn test_field_fNeedToUpdate () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCamera3D > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNeedToUpdate) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkCamera3D) , "::" , stringify ! (fNeedToUpdate))) ; } test_field_fNeedToUpdate () ; } extern "C" { # [link_name = "\u{1}?reset@SkCamera3D@@QEAAXXZ"] pub fn SkCamera3D_reset (this : * mut SkCamera3D) ; } extern "C" { # [link_name = "\u{1}?update@SkCamera3D@@QEAAXXZ"] pub fn SkCamera3D_update (this : * mut SkCamera3D) ; } extern "C" { # [link_name = "\u{1}?patchToMatrix@SkCamera3D@@QEBAXAEBVSkPatch3D@@PEAVSkMatrix@@@Z"] pub fn SkCamera3D_patchToMatrix (this : * const SkCamera3D , arg1 : * const SkPatch3D , matrix : * mut SkMatrix) ; } extern "C" { # [link_name = "\u{1}??0SkCamera3D@@QEAA@XZ"] pub fn SkCamera3D_SkCamera3D (this : * mut SkCamera3D) ; } impl SkCamera3D { # [inline] pub unsafe fn reset (& mut self) { SkCamera3D_reset (self) } # [inline] pub unsafe fn update (& mut self) { SkCamera3D_update (self) } # [inline] pub unsafe fn patchToMatrix (& self , arg1 : * const SkPatch3D , matrix : * mut SkMatrix) { SkCamera3D_patchToMatrix (self , arg1 , matrix) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCamera3D_SkCamera3D (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct Sk3DView { pub fRec : * mut Sk3DView_Rec , pub fInitialRec : Sk3DView_Rec , pub fCamera : SkCamera3D , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct Sk3DView_Rec { pub fNext : * mut Sk3DView_Rec , pub fMatrix : SkM44 , } # [test] fn bindgen_test_layout_Sk3DView_Rec () { assert_eq ! (:: core :: mem :: size_of :: < Sk3DView_Rec > () , 72usize , concat ! ("Size of: " , stringify ! (Sk3DView_Rec))) ; assert_eq ! (:: core :: mem :: align_of :: < Sk3DView_Rec > () , 8usize , concat ! ("Alignment of " , stringify ! (Sk3DView_Rec))) ; fn test_field_fNext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < Sk3DView_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fNext) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (Sk3DView_Rec) , "::" , stringify ! (fNext))) ; } test_field_fNext () ; fn test_field_fMatrix () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < Sk3DView_Rec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMatrix) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (Sk3DView_Rec) , "::" , stringify ! (fMatrix))) ; } test_field_fMatrix () ; } # [test] fn bindgen_test_layout_Sk3DView () { assert_eq ! (:: core :: mem :: size_of :: < Sk3DView > () , 176usize , concat ! ("Size of: " , stringify ! (Sk3DView))) ; assert_eq ! (:: core :: mem :: align_of :: < Sk3DView > () , 8usize , concat ! ("Alignment of " , stringify ! (Sk3DView))) ; fn test_field_fRec () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < Sk3DView > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRec) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (Sk3DView) , "::" , stringify ! (fRec))) ; } test_field_fRec () ; fn test_field_fInitialRec () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < Sk3DView > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInitialRec) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (Sk3DView) , "::" , stringify ! (fInitialRec))) ; } test_field_fInitialRec () ; fn test_field_fCamera () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < Sk3DView > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCamera) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (Sk3DView) , "::" , stringify ! (fCamera))) ; } test_field_fCamera () ; } extern "C" { # [link_name = "\u{1}?save@Sk3DView@@QEAAXXZ"] pub fn Sk3DView_save (this : * mut Sk3DView) ; } extern "C" { # [link_name = "\u{1}?restore@Sk3DView@@QEAAXXZ"] pub fn Sk3DView_restore (this : * mut Sk3DView) ; } extern "C" { # [link_name = "\u{1}?translate@Sk3DView@@QEAAXMMM@Z"] pub fn Sk3DView_translate (this : * mut Sk3DView , x : SkScalar , y : SkScalar , z : SkScalar) ; } extern "C" { # [link_name = "\u{1}?rotateX@Sk3DView@@QEAAXM@Z"] pub fn Sk3DView_rotateX (this : * mut Sk3DView , deg : SkScalar) ; } extern "C" { # [link_name = "\u{1}?rotateY@Sk3DView@@QEAAXM@Z"] pub fn Sk3DView_rotateY (this : * mut Sk3DView , deg : SkScalar) ; } extern "C" { # [link_name = "\u{1}?rotateZ@Sk3DView@@QEAAXM@Z"] pub fn Sk3DView_rotateZ (this : * mut Sk3DView , deg : SkScalar) ; } extern "C" { # [link_name = "\u{1}?getMatrix@Sk3DView@@QEBAXPEAVSkMatrix@@@Z"] pub fn Sk3DView_getMatrix (this : * const Sk3DView , arg1 : * mut SkMatrix) ; } extern "C" { # [link_name = "\u{1}?applyToCanvas@Sk3DView@@QEBAXPEAVSkCanvas@@@Z"] pub fn Sk3DView_applyToCanvas (this : * const Sk3DView , arg1 : * mut SkCanvas) ; } extern "C" { # [link_name = "\u{1}?dotWithNormal@Sk3DView@@QEBAMMMM@Z"] pub fn Sk3DView_dotWithNormal (this : * const Sk3DView , dx : SkScalar , dy : SkScalar , dz : SkScalar) -> SkScalar ; } extern "C" { # [link_name = "\u{1}??0Sk3DView@@QEAA@XZ"] pub fn Sk3DView_Sk3DView (this : * mut Sk3DView) ; } impl Sk3DView { # [inline] pub unsafe fn save (& mut self) { Sk3DView_save (self) } # [inline] pub unsafe fn restore (& mut self) { Sk3DView_restore (self) } # [inline] pub unsafe fn translate (& mut self , x : SkScalar , y : SkScalar , z : SkScalar) { Sk3DView_translate (self , x , y , z) } # [inline] pub unsafe fn rotateX (& mut self , deg : SkScalar) { Sk3DView_rotateX (self , deg) } # [inline] pub unsafe fn rotateY (& mut self , deg : SkScalar) { Sk3DView_rotateY (self , deg) } # [inline] pub unsafe fn rotateZ (& mut self , deg : SkScalar) { Sk3DView_rotateZ (self , deg) } # [inline] pub unsafe fn getMatrix (& self , arg1 : * mut SkMatrix) { Sk3DView_getMatrix (self , arg1) } # [inline] pub unsafe fn applyToCanvas (& self , arg1 : * mut SkCanvas) { Sk3DView_applyToCanvas (self , arg1) } # [inline] pub unsafe fn dotWithNormal (& self , dx : SkScalar , dy : SkScalar , dz : SkScalar) -> SkScalar { Sk3DView_dotWithNormal (self , dx , dy , dz) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; Sk3DView_Sk3DView (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct SkCustomTypefaceBuilder { pub fGlyphRecs : [u64 ; 3usize] , pub fMetrics : SkFontMetrics , pub fStyle : SkFontStyle , } # [repr (C)] # [derive (Debug)] pub struct SkCustomTypefaceBuilder_GlyphRec { pub fPath : SkPath , pub fDrawable : sk_sp < SkDrawable > , pub fBounds : SkRect , pub fAdvance : f32 , } # [test] fn bindgen_test_layout_SkCustomTypefaceBuilder_GlyphRec () { assert_eq ! (:: core :: mem :: size_of :: < SkCustomTypefaceBuilder_GlyphRec > () , 48usize , concat ! ("Size of: " , stringify ! (SkCustomTypefaceBuilder_GlyphRec))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCustomTypefaceBuilder_GlyphRec > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCustomTypefaceBuilder_GlyphRec))) ; fn test_field_fPath () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder_GlyphRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPath) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder_GlyphRec) , "::" , stringify ! (fPath))) ; } test_field_fPath () ; fn test_field_fDrawable () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder_GlyphRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDrawable) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder_GlyphRec) , "::" , stringify ! (fDrawable))) ; } test_field_fDrawable () ; fn test_field_fBounds () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder_GlyphRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBounds) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder_GlyphRec) , "::" , stringify ! (fBounds))) ; } test_field_fBounds () ; fn test_field_fAdvance () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder_GlyphRec > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAdvance) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder_GlyphRec) , "::" , stringify ! (fAdvance))) ; } test_field_fAdvance () ; } # [test] fn bindgen_test_layout_SkCustomTypefaceBuilder () { assert_eq ! (:: core :: mem :: size_of :: < SkCustomTypefaceBuilder > () , 96usize , concat ! ("Size of: " , stringify ! (SkCustomTypefaceBuilder))) ; assert_eq ! (:: core :: mem :: align_of :: < SkCustomTypefaceBuilder > () , 8usize , concat ! ("Alignment of " , stringify ! (SkCustomTypefaceBuilder))) ; fn test_field_fGlyphRecs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphRecs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder) , "::" , stringify ! (fGlyphRecs))) ; } test_field_fGlyphRecs () ; fn test_field_fMetrics () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMetrics) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder) , "::" , stringify ! (fMetrics))) ; } test_field_fMetrics () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkCustomTypefaceBuilder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkCustomTypefaceBuilder) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; } extern "C" { # [link_name = "\u{1}?setGlyph@SkCustomTypefaceBuilder@@QEAAXGMAEBVSkPath@@@Z"] pub fn SkCustomTypefaceBuilder_setGlyph (this : * mut SkCustomTypefaceBuilder , arg1 : SkGlyphID , advance : f32 , arg2 : * const SkPath) ; } extern "C" { # [link_name = "\u{1}?setMetrics@SkCustomTypefaceBuilder@@QEAAXAEBUSkFontMetrics@@M@Z"] pub fn SkCustomTypefaceBuilder_setMetrics (this : * mut SkCustomTypefaceBuilder , fm : * const SkFontMetrics , scale : f32) ; } extern "C" { # [link_name = "\u{1}?setFontStyle@SkCustomTypefaceBuilder@@QEAAXVSkFontStyle@@@Z"] pub fn SkCustomTypefaceBuilder_setFontStyle (this : * mut SkCustomTypefaceBuilder , arg1 : SkFontStyle) ; } extern "C" { # [link_name = "\u{1}?detach@SkCustomTypefaceBuilder@@QEAA?AV?$sk_sp@VSkTypeface@@@@XZ"] pub fn SkCustomTypefaceBuilder_detach (this : * mut SkCustomTypefaceBuilder) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}??0SkCustomTypefaceBuilder@@QEAA@XZ"] pub fn SkCustomTypefaceBuilder_SkCustomTypefaceBuilder (this : * mut SkCustomTypefaceBuilder) ; } impl SkCustomTypefaceBuilder { # [inline] pub unsafe fn setGlyph (& mut self , arg1 : SkGlyphID , advance : f32 , arg2 : * const SkPath) { SkCustomTypefaceBuilder_setGlyph (self , arg1 , advance , arg2) } # [inline] pub unsafe fn setMetrics (& mut self , fm : * const SkFontMetrics , scale : f32) { SkCustomTypefaceBuilder_setMetrics (self , fm , scale) } # [inline] pub unsafe fn setFontStyle (& mut self , arg1 : SkFontStyle) { SkCustomTypefaceBuilder_setFontStyle (self , arg1) } # [inline] pub unsafe fn detach (& mut self) -> sk_sp < SkTypeface > { SkCustomTypefaceBuilder_detach (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkCustomTypefaceBuilder_SkCustomTypefaceBuilder (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct SkOrderedFontMgr { pub _base : SkFontMgr , pub fList : [u64 ; 3usize] , } # [test] fn bindgen_test_layout_SkOrderedFontMgr () { assert_eq ! (:: core :: mem :: size_of :: < SkOrderedFontMgr > () , 40usize , concat ! ("Size of: " , stringify ! (SkOrderedFontMgr))) ; assert_eq ! (:: core :: mem :: align_of :: < SkOrderedFontMgr > () , 8usize , concat ! ("Alignment of " , stringify ! (SkOrderedFontMgr))) ; fn test_field_fList () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkOrderedFontMgr > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fList) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkOrderedFontMgr) , "::" , stringify ! (fList))) ; } test_field_fList () ; } extern "C" { # [link_name = "\u{1}?append@SkOrderedFontMgr@@QEAAXV?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkOrderedFontMgr_append (this : * mut SkOrderedFontMgr , arg1 : sk_sp < SkFontMgr >) ; } extern "C" { # [link_name = "\u{1}??0SkOrderedFontMgr@@QEAA@XZ"] pub fn SkOrderedFontMgr_SkOrderedFontMgr (this : * mut SkOrderedFontMgr) ; } impl SkOrderedFontMgr { # [inline] pub unsafe fn append (& mut self , arg1 : sk_sp < SkFontMgr >) { SkOrderedFontMgr_append (self , arg1) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkOrderedFontMgr_SkOrderedFontMgr (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?onCountFamilies@SkOrderedFontMgr@@MEBAHXZ"] pub fn SkOrderedFontMgr_onCountFamilies (this : * mut :: core :: ffi :: c_void) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?onGetFamilyName@SkOrderedFontMgr@@MEBAXHPEAVSkString@@@Z"] pub fn SkOrderedFontMgr_onGetFamilyName (this : * mut :: core :: ffi :: c_void , index : :: std :: os :: raw :: c_int , familyName : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?onCreateStyleSet@SkOrderedFontMgr@@MEBAPEAVSkFontStyleSet@@H@Z"] pub fn SkOrderedFontMgr_onCreateStyleSet (this : * mut :: core :: ffi :: c_void , index : :: std :: os :: raw :: c_int) -> * mut SkFontStyleSet ; } extern "C" { # [link_name = "\u{1}?onMatchFamily@SkOrderedFontMgr@@MEBAPEAVSkFontStyleSet@@QEBD@Z"] pub fn SkOrderedFontMgr_onMatchFamily (this : * mut :: core :: ffi :: c_void , familyName : * const :: std :: os :: raw :: c_char) -> * mut SkFontStyleSet ; } extern "C" { # [link_name = "\u{1}?onMatchFamilyStyle@SkOrderedFontMgr@@MEBAPEAVSkTypeface@@QEBDAEBVSkFontStyle@@@Z"] pub fn SkOrderedFontMgr_onMatchFamilyStyle (this : * mut :: core :: ffi :: c_void , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?onMatchFamilyStyleCharacter@SkOrderedFontMgr@@MEBAPEAVSkTypeface@@QEBDAEBVSkFontStyle@@QEAPEBDHH@Z"] pub fn SkOrderedFontMgr_onMatchFamilyStyleCharacter (this : * mut :: core :: ffi :: c_void , familyName : * const :: std :: os :: raw :: c_char , arg1 : * const SkFontStyle , bcp47 : * mut * const :: std :: os :: raw :: c_char , bcp47Count : :: std :: os :: raw :: c_int , character : SkUnichar) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?onMakeFromData@SkOrderedFontMgr@@MEBA?AV?$sk_sp@VSkTypeface@@@@V?$sk_sp@VSkData@@@@H@Z"] pub fn SkOrderedFontMgr_onMakeFromData (this : * mut :: core :: ffi :: c_void , arg1 : sk_sp < SkData > , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?onMakeFromStreamIndex@SkOrderedFontMgr@@MEBA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@H@Z"] pub fn SkOrderedFontMgr_onMakeFromStreamIndex (this : * mut :: core :: ffi :: c_void , arg1 : u64 , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?onMakeFromStreamArgs@SkOrderedFontMgr@@MEBA?AV?$sk_sp@VSkTypeface@@@@V?$unique_ptr@VSkStreamAsset@@U?$default_delete@VSkStreamAsset@@@std@@@std@@AEBUSkFontArguments@@@Z"] pub fn SkOrderedFontMgr_onMakeFromStreamArgs (this : * mut :: core :: ffi :: c_void , arg1 : u64 , arg2 : * const SkFontArguments) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?onMakeFromFile@SkOrderedFontMgr@@MEBA?AV?$sk_sp@VSkTypeface@@@@QEBDH@Z"] pub fn SkOrderedFontMgr_onMakeFromFile (this : * mut :: core :: ffi :: c_void , path : * const :: std :: os :: raw :: c_char , ttcIndex : :: std :: os :: raw :: c_int) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?onLegacyMakeTypeface@SkOrderedFontMgr@@MEBA?AV?$sk_sp@VSkTypeface@@@@QEBDVSkFontStyle@@@Z"] pub fn SkOrderedFontMgr_onLegacyMakeTypeface (this : * mut :: core :: ffi :: c_void , familyName : * const :: std :: os :: raw :: c_char , arg1 : SkFontStyle) -> sk_sp < SkTypeface > ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkParsePath { pub _address : u8 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkParsePath_PathEncoding { Absolute = 0 , Relative = 1 , } # [test] fn bindgen_test_layout_SkParsePath () { assert_eq ! (:: core :: mem :: size_of :: < SkParsePath > () , 1usize , concat ! ("Size of: " , stringify ! (SkParsePath))) ; assert_eq ! (:: core :: mem :: align_of :: < SkParsePath > () , 1usize , concat ! ("Alignment of " , stringify ! (SkParsePath))) ; } extern "C" { # [link_name = "\u{1}?FromSVGString@SkParsePath@@SA_NQEBDPEAVSkPath@@@Z"] pub fn SkParsePath_FromSVGString (str_ : * const :: std :: os :: raw :: c_char , arg1 : * mut SkPath) -> bool ; } extern "C" { # [link_name = "\u{1}?ToSVGString@SkParsePath@@SAXAEBVSkPath@@PEAVSkString@@W4PathEncoding@1@@Z"] pub fn SkParsePath_ToSVGString (arg1 : * const SkPath , arg2 : * mut SkString , arg3 : SkParsePath_PathEncoding) ; } impl SkParsePath { # [inline] pub unsafe fn FromSVGString (str_ : * const :: std :: os :: raw :: c_char , arg1 : * mut SkPath) -> bool { SkParsePath_FromSVGString (str_ , arg1) } # [inline] pub unsafe fn ToSVGString (arg1 : * const SkPath , arg2 : * mut SkString , arg3 : SkParsePath_PathEncoding) { SkParsePath_ToSVGString (arg1 , arg2 , arg3) } } pub const SkShadowFlags_kNone_ShadowFlag : SkShadowFlags = 0 ; pub const SkShadowFlags_kTransparentOccluder_ShadowFlag : SkShadowFlags = 1 ; pub const SkShadowFlags_kGeometricOnly_ShadowFlag : SkShadowFlags = 2 ; pub const SkShadowFlags_kDirectionalLight_ShadowFlag : SkShadowFlags = 4 ; pub const SkShadowFlags_kConcaveBlurOnly_ShadowFlag : SkShadowFlags = 8 ; pub const SkShadowFlags_kAll_ShadowFlag : SkShadowFlags = 15 ; pub type SkShadowFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShadowUtils { pub _address : u8 , } # [test] fn bindgen_test_layout_SkShadowUtils () { assert_eq ! (:: core :: mem :: size_of :: < SkShadowUtils > () , 1usize , concat ! ("Size of: " , stringify ! (SkShadowUtils))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShadowUtils > () , 1usize , concat ! ("Alignment of " , stringify ! (SkShadowUtils))) ; } extern "C" { # [link_name = "\u{1}?DrawShadow@SkShadowUtils@@SAXPEAVSkCanvas@@AEBVSkPath@@AEBUSkPoint3@@2MIII@Z"] pub fn SkShadowUtils_DrawShadow (canvas : * mut SkCanvas , path : * const SkPath , zPlaneParams : * const SkPoint3 , lightPos : * const SkPoint3 , lightRadius : SkScalar , ambientColor : SkColor , spotColor : SkColor , flags : u32) ; } extern "C" { # [link_name = "\u{1}?GetLocalBounds@SkShadowUtils@@SA_NAEBVSkMatrix@@AEBVSkPath@@AEBUSkPoint3@@2MIPEAUSkRect@@@Z"] pub fn SkShadowUtils_GetLocalBounds (ctm : * const SkMatrix , path : * const SkPath , zPlaneParams : * const SkPoint3 , lightPos : * const SkPoint3 , lightRadius : SkScalar , flags : u32 , bounds : * mut SkRect) -> bool ; } extern "C" { # [link_name = "\u{1}?ComputeTonalColors@SkShadowUtils@@SAXIIPEAI0@Z"] pub fn SkShadowUtils_ComputeTonalColors (inAmbientColor : SkColor , inSpotColor : SkColor , outAmbientColor : * mut SkColor , outSpotColor : * mut SkColor) ; } impl SkShadowUtils { # [inline] pub unsafe fn DrawShadow (canvas : * mut SkCanvas , path : * const SkPath , zPlaneParams : * const SkPoint3 , lightPos : * const SkPoint3 , lightRadius : SkScalar , ambientColor : SkColor , spotColor : SkColor , flags : u32) { SkShadowUtils_DrawShadow (canvas , path , zPlaneParams , lightPos , lightRadius , ambientColor , spotColor , flags) } # [inline] pub unsafe fn GetLocalBounds (ctm : * const SkMatrix , path : * const SkPath , zPlaneParams : * const SkPoint3 , lightPos : * const SkPoint3 , lightRadius : SkScalar , flags : u32 , bounds : * mut SkRect) -> bool { SkShadowUtils_GetLocalBounds (ctm , path , zPlaneParams , lightPos , lightRadius , flags , bounds) } # [inline] pub unsafe fn ComputeTonalColors (inAmbientColor : SkColor , inSpotColor : SkColor , outAmbientColor : * mut SkColor , outSpotColor : * mut SkColor) { SkShadowUtils_ComputeTonalColors (inAmbientColor , inSpotColor , outAmbientColor , outSpotColor) } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTextUtils { pub _address : u8 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTextUtils_Align { Left = 0 , Center = 1 , Right = 2 , } # [test] fn bindgen_test_layout_SkTextUtils () { assert_eq ! (:: core :: mem :: size_of :: < SkTextUtils > () , 1usize , concat ! ("Size of: " , stringify ! (SkTextUtils))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextUtils > () , 1usize , concat ! ("Alignment of " , stringify ! (SkTextUtils))) ; } extern "C" { # [link_name = "\u{1}?Draw@SkTextUtils@@SAXPEAVSkCanvas@@PEBX_KW4SkTextEncoding@@MMAEBVSkFont@@AEBVSkPaint@@W4Align@1@@Z"] pub fn SkTextUtils_Draw (arg1 : * mut SkCanvas , text : * const :: core :: ffi :: c_void , size : usize , arg2 : SkTextEncoding , x : SkScalar , y : SkScalar , arg3 : * const SkFont , arg4 : * const SkPaint , arg5 : SkTextUtils_Align) ; } extern "C" { # [link_name = "\u{1}?GetPath@SkTextUtils@@SAXPEBX_KW4SkTextEncoding@@MMAEBVSkFont@@PEAVSkPath@@@Z"] pub fn SkTextUtils_GetPath (text : * const :: core :: ffi :: c_void , length : usize , arg1 : SkTextEncoding , x : SkScalar , y : SkScalar , arg2 : * const SkFont , arg3 : * mut SkPath) ; } impl SkTextUtils { # [inline] pub unsafe fn Draw (arg1 : * mut SkCanvas , text : * const :: core :: ffi :: c_void , size : usize , arg2 : SkTextEncoding , x : SkScalar , y : SkScalar , arg3 : * const SkFont , arg4 : * const SkPaint , arg5 : SkTextUtils_Align) { SkTextUtils_Draw (arg1 , text , size , arg2 , x , y , arg3 , arg4 , arg5) } # [inline] pub unsafe fn GetPath (text : * const :: core :: ffi :: c_void , length : usize , arg1 : SkTextEncoding , x : SkScalar , y : SkScalar , arg2 : * const SkFont , arg3 : * mut SkPath) { SkTextUtils_GetPath (text , length , arg1 , x , y , arg2 , arg3) } } extern "C" { pub fn C_SkCodec_MakeFromData (data : * mut SkData) -> * mut SkCodec ; } extern "C" { pub fn C_SkCodec_getInfo (self_ : * const SkCodec , info : * mut SkImageInfo) ; } extern "C" { pub fn C_SkCodec_dimensions (self_ : * const SkCodec) -> SkISize ; } extern "C" { pub fn C_SkCodec_bounds (self_ : * const SkCodec) -> SkIRect ; } extern "C" { pub fn C_SkCodec_getOrigin (self_ : * const SkCodec) -> SkEncodedOrigin ; } extern "C" { pub fn C_SkCodec_getScaledDimensions (self_ : * const SkCodec , desiredScale : f32) -> SkISize ; } extern "C" { pub fn C_SkCodec_getValidSubset (self_ : * const SkCodec , desiredSubset : * mut SkIRect) -> bool ; } extern "C" { pub fn C_SkCodec_getEncodedFormat (self_ : * const SkCodec) -> SkEncodedImageFormat ; } extern "C" { pub fn C_SkCodec_getImage (self_ : * mut SkCodec , info : * const SkImageInfo , opts : * const SkCodec_Options , result : * mut SkCodec_Result) -> * mut SkImage ; } extern "C" { pub fn C_SkCodec_incrementalDecode (self_ : * mut SkCodec , rowsDecoded : * mut :: std :: os :: raw :: c_int) -> SkCodec_Result ; } extern "C" { pub fn C_SkCodec_getScanlineOrder (self_ : * const SkCodec) -> SkCodec_SkScanlineOrder ; } extern "C" { pub fn C_SkCodec_nextScanline (self_ : * const SkCodec) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkCodec_getFrameCount (self_ : * mut SkCodec) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkCodec_getRepetitionCount (self_ : * mut SkCodec) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkEncodedOriginToMatrix (origin : SkEncodedOrigin , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , matrix : * mut SkMatrix) ; } extern "C" { pub fn C_Core_Types (arg1 : * mut SkGraphics , arg2 : * mut SkCoverageMode , arg3 : * mut SkColorChannelFlag) ; } extern "C" { pub fn C_SkBlender_Mode (mode : SkBlendMode) -> * mut SkBlender ; } extern "C" { pub fn C_SkBlender_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkBlender ; } extern "C" { pub fn C_SkCubicMap_computeFromT (self_ : * const SkCubicMap , t : f32) -> SkPoint ; } extern "C" { pub fn C_SkSurface_MakeRasterDirect (imageInfo : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeRaster (imageInfo : * const SkImageInfo , rowBytes : usize , surfaceProps : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeRasterN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , surfaceProps : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeNull (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_width (self_ : * const SkSurface) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkSurface_height (self_ : * const SkSurface) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkSurface_imageInfo (self_ : * mut SkSurface , info : * mut SkImageInfo) ; } extern "C" { pub fn C_SkSurface_makeImageSnapshot (self_ : * mut SkSurface , bounds : * const SkIRect) -> * mut SkImage ; } extern "C" { pub fn C_SkSurface_makeSurface (self_ : * mut SkSurface , imageInfo : * const SkImageInfo) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_makeSurface2 (self_ : * mut SkSurface , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_props (self_ : * const SkSurface) -> * const SkSurfaceProps ; } extern "C" { pub fn C_SkSurface_draw (self_ : * mut SkSurface , displayList : * const SkDeferredDisplayList , xOffset : :: std :: os :: raw :: c_int , yOffset : :: std :: os :: raw :: c_int) -> bool ; } extern "C" { pub fn C_SkSurfaceCharacterization_Construct (uninitialized : * mut SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkSurfaceCharacterization_CopyConstruct (uninitialized : * mut SkSurfaceCharacterization , from : * const SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkSurfaceCharacterization_destruct (self_ : * mut SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkSurfaceCharacterization_equals (self_ : * const SkSurfaceCharacterization , rhs : * const SkSurfaceCharacterization) -> bool ; } extern "C" { pub fn C_SkSurfaceCharacterization_createColorSpace (self_ : * const SkSurfaceCharacterization , cs : * mut SkColorSpace , out : * mut SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkImage_MakeRasterFromCompressed (data : * mut SkData , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeRasterData (info : * const SkImageInfo , pixels : * mut SkData , rowBytes : usize) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromBitmap (bitmap : * const SkBitmap) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromGenerator (imageGenerator : * mut SkImageGenerator) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromEncoded (encoded : * mut SkData , alphaType : * const SkAlphaType) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromPicture (picture : * mut SkPicture , dimensions : * const SkISize , matrix : * const SkMatrix , paint : * const SkPaint , bitDepth : SkImage_BitDepth , colorSpace : * mut SkColorSpace , props : * const SkSurfaceProps) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeShader (self_ : * const SkImage , tileMode1 : SkTileMode , tileMode2 : SkTileMode , samplingOptions : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkImage_makeRawShader (self_ : * const SkImage , tileMode1 : SkTileMode , tileMode2 : SkTileMode , samplingOptions : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkImage_encodeToData (self_ : * const SkImage , imageFormat : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int) -> * mut SkData ; } extern "C" { pub fn C_SkImage_refEncodedData (self_ : * const SkImage) -> * mut SkData ; } extern "C" { pub fn C_SkImage_makeSubset (self_ : * const SkImage , subset : * const SkIRect , direct : * mut GrDirectContext) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_withDefaultMipmaps (self_ : * const SkImage) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeNonTextureImage (self_ : * const SkImage) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeRasterImage (self_ : * const SkImage , cachingHint : SkImage_CachingHint) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeWithFilter (self_ : * const SkImage , context : * mut GrRecordingContext , filter : * const SkImageFilter , subset : * const SkIRect , clipBounds : * const SkIRect , outSubset : * mut SkIRect , offset : * mut SkIPoint) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeColorSpace (self_ : * const SkImage , target : * mut SkColorSpace , direct : * mut GrDirectContext) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_reinterpretColorSpace (self_ : * const SkImage , newColorSpace : * mut SkColorSpace) -> * mut SkImage ; } extern "C" { pub fn C_SkEncodePixmap (src : * const SkPixmap , format : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int) -> * mut SkData ; } extern "C" { pub fn C_SkEncodeBitmap (src : * const SkBitmap , format : SkEncodedImageFormat , quality : :: std :: os :: raw :: c_int) -> * mut SkData ; } extern "C" { pub fn C_SkData_ref (self_ : * const SkData) ; } extern "C" { pub fn C_SkData_unref (self_ : * const SkData) ; } extern "C" { pub fn C_SkData_unique (self_ : * const SkData) -> bool ; } extern "C" { pub fn C_SkData_MakeWithCopy (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeSubset (src : * const SkData , offset : usize , length : usize) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeUninitialized (length : usize) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeZeroInitialized (length : usize) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeWithCString (cstr : * const :: std :: os :: raw :: c_char) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeWithoutCopy (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkData ; } extern "C" { pub fn C_SkData_MakeEmpty () -> * mut SkData ; } extern "C" { pub fn C_SkPaint_destruct (self_ : * mut SkPaint) ; } extern "C" { pub fn C_SkPaint_copy (self_ : * mut SkPaint , rhs : * const SkPaint) ; } extern "C" { pub fn C_SkPaint_Equals (lhs : * const SkPaint , rhs : * const SkPaint) -> bool ; } extern "C" { pub fn C_SkPaint_getStyle (self_ : * const SkPaint) -> SkPaint_Style ; } extern "C" { pub fn C_SkPaint_getAlpha (self_ : * const SkPaint) -> u8 ; } extern "C" { pub fn C_SkPaint_getStrokeCap (self_ : * const SkPaint) -> SkPaint_Cap ; } extern "C" { pub fn C_SkPaint_getStrokeJoin (self_ : * const SkPaint) -> SkPaint_Join ; } extern "C" { pub fn C_SkPaint_setShader (self_ : * mut SkPaint , shader : * mut SkShader) ; } extern "C" { pub fn C_SkPaint_setColorFilter (self_ : * mut SkPaint , colorFilter : * mut SkColorFilter) ; } extern "C" { pub fn C_SkPaint_asBlendMode (self_ : * const SkPaint , mode : * mut SkBlendMode) -> bool ; } extern "C" { pub fn C_SkPaint_setBlender (self_ : * mut SkPaint , blender : * mut SkBlender) ; } extern "C" { pub fn C_SkPaint_setPathEffect (self_ : * mut SkPaint , pathEffect : * mut SkPathEffect) ; } extern "C" { pub fn C_SkPaint_setMaskFilter (self_ : * mut SkPaint , maskFilter : * mut SkMaskFilter) ; } extern "C" { pub fn C_SkPaint_setImageFilter (self_ : * mut SkPaint , imageFilter : * mut SkImageFilter) ; } extern "C" { pub fn C_SkPath_Construct (uninitialized : * mut SkPath) ; } extern "C" { pub fn C_SkPath_Make (uninitialized : * mut SkPath , pts : * const SkPoint , pointCount : :: std :: os :: raw :: c_int , vbs : * const u8 , verbCount : :: std :: os :: raw :: c_int , ws : * const SkScalar , wCount : :: std :: os :: raw :: c_int , ft : SkPathFillType , isVolatile : bool) ; } extern "C" { pub fn C_SkPath_Rect (uninitialized : * mut SkPath , r : * const SkRect , dir : SkPathDirection) ; } extern "C" { pub fn C_SkPath_Oval (uninitialized : * mut SkPath , r : * const SkRect , dir : SkPathDirection) ; } extern "C" { pub fn C_SkPath_OvalWithStartIndex (uninitialized : * mut SkPath , r : * const SkRect , dir : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) ; } extern "C" { pub fn C_SkPath_Circle (uninitialized : * mut SkPath , x : SkScalar , y : SkScalar , r : SkScalar , dir : SkPathDirection) ; } extern "C" { pub fn C_SkPath_RRect (uninitialized : * mut SkPath , rr : * const SkRRect , dir : SkPathDirection) ; } extern "C" { pub fn C_SkPath_RRectWithStartIndex (uninitialized : * mut SkPath , r : * const SkRRect , dir : SkPathDirection , startIndex : :: std :: os :: raw :: c_uint) ; } extern "C" { pub fn C_SkPath_Polygon (uninitialized : * mut SkPath , pts : * const SkPoint , count : :: std :: os :: raw :: c_int , isClosed : bool , ft : SkPathFillType , isVolatile : bool) ; } extern "C" { pub fn C_SkPath_destruct (self_ : * const SkPath) ; } extern "C" { pub fn C_SkPath_Equals (lhs : * const SkPath , rhs : * const SkPath) -> bool ; } extern "C" { pub fn C_SkPath_serialize (self_ : * const SkPath) -> * mut SkData ; } extern "C" { pub fn C_SkPath_Iter_destruct (self_ : * mut SkPath_Iter) ; } extern "C" { pub fn C_SkPath_Iter_isCloseLine (self_ : * const SkPath_Iter) -> bool ; } extern "C" { pub fn C_SkPath_RawIter_Construct (uninitialized : * mut SkPath_RawIter) ; } extern "C" { pub fn C_SkPath_RawIter_destruct (self_ : * mut SkPath_RawIter) ; } extern "C" { pub fn C_SkPath_RawIter_peek (self_ : * const SkPath_RawIter) -> SkPath_Verb ; } extern "C" { pub fn C_SkPath_getFillType (self_ : * const SkPath) -> SkPathFillType ; } extern "C" { pub fn C_SkPath_getPoint (self_ : * const SkPath , index : :: std :: os :: raw :: c_int) -> SkPoint ; } extern "C" { pub fn C_SkPath_getBounds (self_ : * const SkPath) -> * const SkRect ; } extern "C" { pub fn C_SkPath_computeTightBounds (self_ : * const SkPath) -> SkRect ; } extern "C" { pub fn C_SkPathBuilder_Construct (uninitialized : * mut SkPathBuilder) ; } extern "C" { pub fn C_SkPathBuilder_Construct3 (uninitialized : * mut SkPathBuilder , path : * const SkPath) ; } extern "C" { pub fn C_SkPathBuilder_computeBounds (self_ : * const SkPathBuilder) -> SkRect ; } extern "C" { pub fn C_SkPathBuilder_CopyConstruct (uninitialized : * mut SkPathBuilder , pathBuilder : * const SkPathBuilder) ; } extern "C" { pub fn C_SkPathBuilder_destruct (self_ : * mut SkPathBuilder) ; } extern "C" { pub fn C_SkPathBuilder_snapshot (self_ : * const SkPathBuilder , path : * mut SkPath) ; } extern "C" { pub fn C_SkPathBuilder_detach (self_ : * mut SkPathBuilder , path : * mut SkPath) ; } extern "C" { pub fn C_SkPathMeasure_destruct (self_ : * const SkPathMeasure) ; } extern "C" { pub fn C_SkPathTypes_Types (arg1 : * mut SkPathFillType , arg2 : * mut SkPathDirection , arg3 : * mut SkPathSegmentMask , arg4 : * mut SkPathVerb) ; } extern "C" { pub fn C_SkCanvas_newEmpty () -> * mut SkCanvas ; } extern "C" { pub fn C_SkCanvas_newWidthHeightAndProps (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , props : * const SkSurfaceProps) -> * mut SkCanvas ; } extern "C" { pub fn C_SkCanvas_newFromBitmap (bitmap : * const SkBitmap) -> * mut SkCanvas ; } extern "C" { pub fn C_SkCanvas_newFromBitmapAndProps (bitmap : * const SkBitmap , props : * const SkSurfaceProps) -> * mut SkCanvas ; } extern "C" { pub fn C_SkCanvas_delete (self_ : * const SkCanvas) ; } extern "C" { pub fn C_SkCanvas_MakeRasterDirect (info : * const SkImageInfo , pixels : * mut :: core :: ffi :: c_void , row_bytes : usize , props : * const SkSurfaceProps) -> * mut SkCanvas ; } extern "C" { pub fn C_SkCanvas_imageInfo (self_ : * const SkCanvas , info : * mut SkImageInfo) ; } extern "C" { pub fn C_SkCanvas_getBaseLayerSize (self_ : * const SkCanvas , size : * mut SkISize) ; } extern "C" { pub fn C_SkCanvas_makeSurface (self_ : * mut SkCanvas , info : * const SkImageInfo , props : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkCanvas_clipShader (self_ : * mut SkCanvas , shader : * mut SkShader , op : SkClipOp) ; } extern "C" { pub fn C_SkCanvas_getLocalClipBounds (self_ : * const SkCanvas) -> SkRect ; } extern "C" { pub fn C_SkCanvas_getDeviceClipBounds (self_ : * const SkCanvas) -> SkIRect ; } extern "C" { pub fn C_SkCanvas_isClipEmpty (self_ : * const SkCanvas) -> bool ; } extern "C" { pub fn C_SkCanvas_isClipRect (self_ : * const SkCanvas) -> bool ; } extern "C" { pub fn C_SkCanvas_getLocalToDevice (self_ : * const SkCanvas , uninitialized : * mut SkM44) ; } extern "C" { pub fn C_SkCanvas_getTotalMatrix (self_ : * const SkCanvas , matrix : * mut SkMatrix) ; } extern "C" { pub fn C_SkCanvas_discard (self_ : * mut SkCanvas) ; } extern "C" { pub fn C_SkAutoCanvasRestore_Construct (uninitialized : * mut SkAutoCanvasRestore , canvas : * mut SkCanvas , doSave : bool) ; } extern "C" { pub fn C_SkAutoCanvasRestore_destruct (self_ : * const SkAutoCanvasRestore) ; } extern "C" { pub fn C_SkAutoCanvasRestore_restore (self_ : * mut SkAutoCanvasRestore) ; } extern "C" { pub fn C_SkColorInfo_Construct (uninitialized : * mut SkColorInfo) ; } extern "C" { pub fn C_SkColorInfo_Construct2 (uninitialized : * mut SkColorInfo , ct : SkColorType , at : SkAlphaType , cs : * mut SkColorSpace) ; } extern "C" { pub fn C_SkColorInfo_destruct (self_ : * mut SkColorInfo) ; } extern "C" { pub fn C_SkColorInfo_Copy (from : * const SkColorInfo , to : * mut SkColorInfo) ; } extern "C" { pub fn C_SkColorInfo_Equals (lhs : * const SkColorInfo , rhs : * const SkColorInfo) -> bool ; } extern "C" { pub fn C_SkColorInfo_makeAlphaType (self_ : * const SkColorInfo , newAlphaType : SkAlphaType , uninitialized : * mut SkColorInfo) ; } extern "C" { pub fn C_SkColorInfo_makeColorType (self_ : * const SkColorInfo , newColorType : SkColorType , uninitialized : * mut SkColorInfo) ; } extern "C" { pub fn C_SkColorInfo_makeColorSpace (self_ : * const SkColorInfo , newColorSpace : * mut SkColorSpace , uninitialized : * mut SkColorInfo) ; } extern "C" { pub fn C_SkImageInfo_Construct (uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_destruct (self_ : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_Copy (from : * const SkImageInfo , to : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_Equals (lhs : * const SkImageInfo , rhs : * const SkImageInfo) -> bool ; } extern "C" { pub fn C_SkImageInfo_Make (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , ct : SkColorType , at : SkAlphaType , cs : * mut SkColorSpace , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_MakeN32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , cs : * mut SkColorSpace , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_MakeS32 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , at : SkAlphaType , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_MakeN32Premul (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , cs : * mut SkColorSpace , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_MakeA8 (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_MakeUnknown (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_makeColorSpace (self_ : * const SkImageInfo , cs : * mut SkColorSpace , uninitialized : * mut SkImageInfo) ; } extern "C" { pub fn C_SkImageInfo_reset (self_ : * mut SkImageInfo) ; } extern "C" { pub fn C_SkColorSpace_Types (arg1 : * mut SkColorSpacePrimaries) ; } extern "C" { pub fn C_SkColorSpace_ref (self_ : * const SkColorSpace) ; } extern "C" { pub fn C_SkColorSpace_unref (self_ : * const SkColorSpace) ; } extern "C" { pub fn C_SkColorSpace_unique (self_ : * const SkColorSpace) -> bool ; } extern "C" { pub fn C_SkColorSpace_MakeSRGB () -> * mut SkColorSpace ; } extern "C" { pub fn C_SkColorSpace_MakeSRGBLinear () -> * mut SkColorSpace ; } extern "C" { pub fn C_SkColorSpace_makeLinearGamma (self_ : * const SkColorSpace) -> * mut SkColorSpace ; } extern "C" { pub fn C_SkColorSpace_makeSRGBGamma (self_ : * const SkColorSpace) -> * mut SkColorSpace ; } extern "C" { pub fn C_SkColorSpace_makeColorSpin (self_ : * const SkColorSpace) -> * mut SkColorSpace ; } extern "C" { pub fn C_SkColorSpace_serialize (self_ : * const SkColorSpace) -> * mut SkData ; } extern "C" { pub fn C_SkColorSpace_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkColorSpace ; } extern "C" { pub fn C_SkM44_Types (arg1 : * mut SkV2) ; } extern "C" { pub fn C_SkM44_equals (self_ : * const SkM44 , other : * const SkM44) -> bool ; } extern "C" { pub fn C_SkM44_RectToRect (src : * const SkRect , dst : * const SkRect , uninitialized : * mut SkM44) ; } extern "C" { pub fn C_SkM44_LookAt (eye : * const SkV3 , center : * const SkV3 , up : * const SkV3 , uninitialized : * mut SkM44) ; } extern "C" { pub fn C_SkM44_Perspective (near : f32 , far : f32 , angle : f32 , uninitialized : * mut SkM44) ; } extern "C" { pub fn C_SkM44_transpose (self_ : * const SkM44 , uninitialized : * mut SkM44) ; } extern "C" { pub fn C_SkM44_map (self_ : * const SkM44 , x : f32 , y : f32 , z : f32 , w : f32) -> SkV4 ; } extern "C" { pub fn C_SkMatrix_Equals (self_ : * const SkMatrix , rhs : * const SkMatrix) -> bool ; } extern "C" { pub fn C_SkMatrix_SubscriptMut (self_ : * mut SkMatrix , index : usize) -> * mut SkScalar ; } extern "C" { pub fn C_SkMatrix_getType (self_ : * const SkMatrix) -> SkMatrix_TypeMask ; } extern "C" { pub fn C_SkMatrix_rectStaysRect (self_ : * const SkMatrix) -> bool ; } extern "C" { pub fn C_SkMatrix_hasPerspective (self_ : * const SkMatrix) -> bool ; } extern "C" { pub fn C_SkMatrix_invert (self_ : * const SkMatrix , inverse : * mut SkMatrix) -> bool ; } extern "C" { pub fn C_SkMatrix_setScaleTranslate (self_ : * mut SkMatrix , sx : SkScalar , sy : SkScalar , tx : SkScalar , ty : SkScalar) ; } extern "C" { pub fn C_SkMatrix_isFinite (self_ : * const SkMatrix) -> bool ; } extern "C" { pub fn C_SkMatrix_InvalidMatrix () -> * const SkMatrix ; } extern "C" { pub fn C_SkMatrix_normalizePerspective (self_ : * mut SkMatrix) ; } extern "C" { pub fn C_SkSurfaceProps_Equals (self_ : * const SkSurfaceProps , rhs : * const SkSurfaceProps) -> bool ; } extern "C" { pub fn C_SkBitmap_Construct (uninitialized : * mut SkBitmap) ; } extern "C" { pub fn C_SkBitmap_destruct (self_ : * mut SkBitmap) ; } extern "C" { pub fn C_SkBitmap_Copy (from : * const SkBitmap , to : * mut SkBitmap) ; } extern "C" { pub fn C_SkBitmap_ComputeIsOpaque (self_ : * const SkBitmap) -> bool ; } extern "C" { pub fn C_SkBitmap_tryAllocN32Pixels (self_ : * mut SkBitmap , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , isOpaque : bool) -> bool ; } extern "C" { pub fn C_SkBitmap_tryAllocPixels (self_ : * mut SkBitmap) -> bool ; } extern "C" { pub fn C_SkBitmap_pixelRefOrigin (self_ : * const SkBitmap) -> SkIPoint ; } extern "C" { pub fn C_SkBitmap_setPixelRef (self_ : * mut SkBitmap , pixelRef : * mut SkPixelRef , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn C_SkBitmap_readyToDraw (self_ : * const SkBitmap) -> bool ; } extern "C" { pub fn C_SkBitmap_eraseARGB (self_ : * const SkBitmap , a : U8CPU , r : U8CPU , g : U8CPU , b : U8CPU) ; } extern "C" { pub fn C_SkBitmap_getAlphaf (self_ : * const SkBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> f32 ; } extern "C" { pub fn C_SkBitmap_extractAlpha (self_ : * const SkBitmap , dst : * mut SkBitmap , paint : * const SkPaint , offset : * mut SkIPoint) -> bool ; } extern "C" { pub fn C_SkBitmap_makeShader (self_ : * const SkBitmap , tmx : SkTileMode , tmy : SkTileMode , sampling : * const SkSamplingOptions , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkBitmap_asImage (self_ : * const SkBitmap) -> * mut SkImage ; } extern "C" { pub fn C_SkPicture_MakeFromData (data : * const SkData) -> * mut SkPicture ; } extern "C" { pub fn C_SkPicture_MakeFromData2 (data : * const :: core :: ffi :: c_void , size : usize) -> * mut SkPicture ; } extern "C" { pub fn C_SkPicture_serialize (self_ : * const SkPicture) -> * mut SkData ; } extern "C" { pub fn C_SkPicture_MakePlaceholder (cull : * const SkRect) -> * mut SkPicture ; } extern "C" { pub fn C_SkPicture_playback (self_ : * const SkPicture , canvas : * mut SkCanvas) ; } extern "C" { pub fn C_SkPicture_cullRect (self_ : * const SkPicture) -> SkRect ; } extern "C" { pub fn C_SkPicture_uniqueID (self_ : * const SkPicture) -> u32 ; } extern "C" { pub fn C_SkPicture_approximateOpCount (self_ : * const SkPicture , nested : bool) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkPicture_approximateBytesUsed (self_ : * const SkPicture , out : * mut usize) ; } extern "C" { pub fn C_SkPicture_makeShader (self_ : * const SkPicture , tmx : SkTileMode , tmy : SkTileMode , mode : SkFilterMode , localMatrix : * const SkMatrix , tileRect : * const SkRect) -> * mut SkShader ; } extern "C" { pub fn C_SkRRect_Construct (uninitialized : * mut SkRRect) ; } extern "C" { pub fn C_SkRRect_getType (self_ : * const SkRRect) -> SkRRect_Type ; } extern "C" { pub fn C_SkRRect_setRect (self_ : * mut SkRRect , rect : * const SkRect) ; } extern "C" { pub fn C_SkRRect_dumpToString (self_ : * const SkRRect , asHex : bool , str_ : * mut SkString) ; } extern "C" { pub fn C_SkRRect_Equals (lhs : * const SkRRect , rhs : * const SkRRect) -> bool ; } extern "C" { pub fn C_SkRegion_destruct (region : * mut SkRegion) ; } extern "C" { pub fn C_SkRegion_Equals (lhs : * const SkRegion , rhs : * const SkRegion) -> bool ; } extern "C" { pub fn C_SkRegion_set (self_ : * mut SkRegion , region : * const SkRegion) -> bool ; } extern "C" { pub fn C_SkRegion_quickContains (self_ : * const SkRegion , r : * const SkIRect) -> bool ; } extern "C" { pub fn C_SkRegion_Iterator_Construct (uninitialized : * mut SkRegion_Iterator) ; } extern "C" { pub fn C_SkRegion_Iterator_destruct (self_ : * mut SkRegion_Iterator) ; } extern "C" { pub fn C_SkRegion_Iterator_rgn (self_ : * const SkRegion_Iterator) -> * const SkRegion ; } extern "C" { pub fn C_SkRegion_Cliperator_destruct (self_ : * mut SkRegion_Cliperator) ; } extern "C" { pub fn C_SkRegion_Spanerator_destruct (self_ : * mut SkRegion_Spanerator) ; } extern "C" { pub fn C_SkFontStyle_Construct (uninitialized : * mut SkFontStyle) ; } extern "C" { pub fn C_SkFontStyle_Construct2 (uninitialized : * mut SkFontStyle , weight : :: std :: os :: raw :: c_int , width : :: std :: os :: raw :: c_int , slant : SkFontStyle_Slant) ; } extern "C" { pub fn C_SkFontStyle_Equals (lhs : * const SkFontStyle , rhs : * const SkFontStyle) -> bool ; } extern "C" { pub fn C_SkFontStyle_weight (self_ : * const SkFontStyle) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkFontStyle_width (self_ : * const SkFontStyle) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkFontStyle_slant (self_ : * const SkFontStyle) -> SkFontStyle_Slant ; } extern "C" { pub fn C_SkTextBlob_ref (self_ : * const SkTextBlob) ; } extern "C" { pub fn C_SkTextBlob_unref (self_ : * const SkTextBlob) ; } extern "C" { pub fn C_SkTextBlob_unique (self_ : * const SkTextBlob) -> bool ; } extern "C" { pub fn C_SkTextBlob_MakeFromText (text : * const :: core :: ffi :: c_void , byteLength : usize , font : * const SkFont , encoding : SkTextEncoding) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTextBlob_MakeFromPosTextH (text : * const :: core :: ffi :: c_void , byteLength : usize , xPos : * const SkScalar , constY : SkScalar , font : * const SkFont , encoding : SkTextEncoding) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTextBlob_MakeFromPosText (text : * const :: core :: ffi :: c_void , byteLength : usize , pos : * const SkPoint , font : * const SkFont , encoding : SkTextEncoding) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTextBlob_MakeFromRSXform (text : * const :: core :: ffi :: c_void , byteLength : usize , xform : * const SkRSXform , font : * const SkFont , encoding : SkTextEncoding) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTextBlob_Iter_destruct (self_ : * mut SkTextBlob_Iter) ; } extern "C" { pub fn C_SkTextBlobBuilder_destruct (self_ : * mut SkTextBlobBuilder) ; } extern "C" { pub fn C_SkTextBlobBuilder_make (self_ : * mut SkTextBlobBuilder) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTypeface_isBold (self_ : * const SkTypeface) -> bool ; } extern "C" { pub fn C_SkTypeface_isItalic (self_ : * const SkTypeface) -> bool ; } extern "C" { pub fn C_SkTypeface_MakeDefault () -> * mut SkTypeface ; } extern "C" { pub fn C_SkTypeface_MakeFromName (familyName : * const :: std :: os :: raw :: c_char , fontStyle : SkFontStyle) -> * mut SkTypeface ; } extern "C" { pub fn C_SkTypeface_MakeFromData (data : * mut SkData , index : :: std :: os :: raw :: c_int) -> * mut SkTypeface ; } extern "C" { pub fn C_SkTypeface_makeClone (self_ : * const SkTypeface , arguments : * const SkFontArguments) -> * mut SkTypeface ; } extern "C" { pub fn C_SkTypeface_serialize (self_ : * const SkTypeface , behavior : SkTypeface_SerializeBehavior) -> * mut SkData ; } extern "C" { pub fn C_SkTypeface_MakeDeserialize (stream : * mut SkStream) -> * mut SkTypeface ; } extern "C" { pub fn C_SkTypeface_copyTableData (self_ : * const SkTypeface , tag : SkFontTableTag) -> * mut SkData ; } extern "C" { pub fn C_SkTypeface_openStream (self_ : * const SkTypeface , ttcIndex : * mut :: std :: os :: raw :: c_int) -> * mut SkStreamAsset ; } extern "C" { pub fn C_SkTypeface_getBounds (self_ : * const SkTypeface) -> SkRect ; } extern "C" { pub fn C_SkTypeface_LocalizedStrings_unref (self_ : * mut SkTypeface_LocalizedStrings) ; } extern "C" { pub fn C_SkTypeface_LocalizedStrings_next (self_ : * mut SkTypeface_LocalizedStrings , string : * mut SkString , language : * mut SkString) -> bool ; } extern "C" { pub fn C_SkFlattenable_getTypeName (self_ : * const SkFlattenable) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn C_SkFlattenable_serialize (self_ : * const SkFlattenable) -> * mut SkData ; } extern "C" { pub fn C_SkFont_ConstructFromTypeface (uninitialized : * mut SkFont , typeface : * mut SkTypeface) ; } extern "C" { pub fn C_SkFont_ConstructFromTypefaceWithSize (uninitialized : * mut SkFont , typeface : * mut SkTypeface , size : SkScalar) ; } extern "C" { pub fn C_SkFont_ConstructFromTypefaceWithSizeScaleAndSkew (uninitialized : * mut SkFont , typeface : * mut SkTypeface , size : SkScalar , scaleX : SkScalar , skewX : SkScalar) ; } extern "C" { pub fn C_SkFont_destruct (self_ : * mut SkFont) ; } extern "C" { pub fn C_SkFont_Equals (self_ : * const SkFont , other : * const SkFont) -> bool ; } extern "C" { pub fn C_SkFont_getEdging (self_ : * const SkFont) -> SkFont_Edging ; } extern "C" { pub fn C_SkFont_getHinting (self_ : * const SkFont) -> SkFontHinting ; } extern "C" { pub fn C_SkFont_makeWithSize (self_ : * const SkFont , size : SkScalar , result : * mut SkFont) ; } extern "C" { pub fn C_SkFont_getTypeface (self_ : * mut SkFont) -> * mut SkTypeface ; } extern "C" { pub fn C_SkFont_setTypeface (self_ : * mut SkFont , tf : * mut SkTypeface) ; } extern "C" { pub fn C_SkFont_getIntercepts (self_ : * const SkFont , glyphs : * const SkGlyphID , count : :: std :: os :: raw :: c_int , pos : * const SkPoint , top : SkScalar , bottom : SkScalar , paint : * const SkPaint , vs : * mut VecSink < SkScalar >) ; } extern "C" { pub fn C_SkFontArguments_construct (uninitialized : * mut SkFontArguments) ; } extern "C" { pub fn C_SkFontArguments_destruct (self_ : * mut SkFontArguments) ; } extern "C" { pub fn C_SkFontArguments_setCollectionIndex (self_ : * mut SkFontArguments , collectionIndex : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn C_SkFontArguments_setVariationDesignPosition (self_ : * mut SkFontArguments , position : SkFontArguments_VariationPosition) ; } extern "C" { pub fn C_SkFontArguments_setPalette (self_ : * mut SkFontArguments , palette : SkFontArguments_Palette) ; } extern "C" { pub fn C_SkFontArguments_getVariationDesignPosition (self_ : * const SkFontArguments) -> SkFontArguments_VariationPosition ; } extern "C" { pub fn C_SkFontArguments_getPalette (self_ : * const SkFontArguments) -> SkFontArguments_Palette ; } extern "C" { pub fn C_SkFontStyleSet_count (self_ : * mut SkFontStyleSet) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkFontStyleSet_getStyle (self_ : * mut SkFontStyleSet , index : :: std :: os :: raw :: c_int , fontStyle : * mut SkFontStyle , style : * mut SkString) ; } extern "C" { pub fn C_SkFontStyleSet_createTypeface (self_ : * mut SkFontStyleSet , index : :: std :: os :: raw :: c_int) -> * mut SkTypeface ; } extern "C" { pub fn C_SkFontStyleSet_matchStyle (self_ : * mut SkFontStyleSet , pattern : * const SkFontStyle) -> * mut SkTypeface ; } extern "C" { pub fn C_SkFontMgr_makeFromStream (self_ : * const SkFontMgr , stream : * mut SkStreamAsset , ttcIndex : :: std :: os :: raw :: c_int) -> * mut SkTypeface ; } extern "C" { pub fn C_SkFontMgr_RefDefault () -> * mut SkFontMgr ; } extern "C" { pub fn C_SkFontParameters_Variation_Axis_isHidden (self_ : * const SkFontParameters_Variation_Axis) -> bool ; } extern "C" { pub fn C_SkFontParameters_Variation_Axis_setHidden (self_ : * mut SkFontParameters_Variation_Axis , hidden : bool) ; } extern "C" { pub fn C_SkVertices_ref (self_ : * const SkVertices) ; } extern "C" { pub fn C_SkVertices_unref (self_ : * const SkVertices) ; } extern "C" { pub fn C_SkVertices_unique (self_ : * const SkVertices) -> bool ; } extern "C" { pub fn C_SkVertices_MakeCopy (mode : SkVertices_VertexMode , vertexCount : :: std :: os :: raw :: c_int , positions : * const SkPoint , texs : * const SkPoint , colors : * const SkColor , indexCount : :: std :: os :: raw :: c_int , indices : * const u16) -> * mut SkVertices ; } extern "C" { pub fn C_SkVertices_Builder_destruct (builder : * mut SkVertices_Builder) ; } extern "C" { pub fn C_SkVertices_Builder_detach (builder : * mut SkVertices_Builder) -> * mut SkVertices ; } extern "C" { pub fn C_SkPictureRecorder_Construct (uninitialized : * mut SkPictureRecorder) ; } extern "C" { pub fn C_SkPictureRecorder_destruct (self_ : * mut SkPictureRecorder) ; } extern "C" { pub fn C_SkPictureRecorder_finishRecordingAsPicture (self_ : * mut SkPictureRecorder , cullRect : * const SkRect) -> * mut SkPicture ; } extern "C" { pub fn C_SkPictureRecorder_finishRecordingAsDrawable (self_ : * mut SkPictureRecorder) -> * mut SkDrawable ; } extern "C" { pub fn C_SkPixelRef_width (self_ : * const SkPixelRef) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkPixelRef_height (self_ : * const SkPixelRef) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkPixelRef_pixels (self_ : * const SkPixelRef) -> * mut :: core :: ffi :: c_void ; } extern "C" { pub fn C_SkPixelRef_rowBytes (self_ : * const SkPixelRef) -> usize ; } extern "C" { pub fn C_SkPixelRef_isImmutable (self_ : * const SkPixelRef) -> bool ; } extern "C" { pub fn C_SkPixelRef_notifyAddedToCache (self_ : * mut SkPixelRef) ; } extern "C" { pub fn C_SkPoint_isFinite (self_ : * const SkPoint) -> bool ; } extern "C" { pub fn C_SkIRect_isEmpty (self_ : * const SkIRect) -> bool ; } extern "C" { pub fn C_SkIRect_contains (self_ : * const SkIRect , rect : * const SkRect) -> bool ; } extern "C" { pub fn C_SkRect_round (self_ : * const SkRect , dst : * mut SkIRect) ; } extern "C" { pub fn C_SkRect_roundIn (self_ : * const SkRect , dst : * mut SkIRect) ; } extern "C" { pub fn C_SkRect_roundOut (self_ : * const SkRect , dst : * mut SkIRect) ; } extern "C" { pub fn C_SkRefCntBase_ref (self_ : * const SkRefCntBase) ; } extern "C" { pub fn C_SkRefCntBase_unref (self_ : * const SkRefCntBase) ; } extern "C" { pub fn C_SkRefCntBase_unique (self_ : * const SkRefCntBase) -> bool ; } extern "C" { pub fn C_SkColorFilter_makeComposed (self_ : * const SkColorFilter , inner : * mut SkColorFilter) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilter_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilter_filterColor4f (self_ : * const SkColorFilter , srcColor : * const SkColor4f , srcCS : * mut SkColorSpace , dstCS : * mut SkColorSpace) -> SkColor4f ; } extern "C" { pub fn C_SkColorFilters_Compose (outer : * mut SkColorFilter , inner : * mut SkColorFilter) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_Blend2 (c : * const SkColor4f , colorSpace : * mut SkColorSpace , blendMode : SkBlendMode) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_Blend (c : SkColor , blendMode : SkBlendMode) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_Matrix (colorMatrix : * const SkColorMatrix) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_MatrixRowMajor (array : * const SkScalar) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_HSLAMatrixOfColorMatrix (colorMatrix : * const SkColorMatrix) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_HSLAMatrix (rowMajor : * const f32) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_LinearToSRGBGamma () -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_SRGBToLinearGamma () -> * mut SkColorFilter ; } extern "C" { pub fn C_SkColorFilters_Lerp (t : f32 , dst : * mut SkColorFilter , src : * mut SkColorFilter) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkContourMeasureIter_destruct (self_ : * mut SkContourMeasureIter) ; } extern "C" { pub fn C_SkContourMeasureIter_next (self_ : * mut SkContourMeasureIter) -> * mut SkContourMeasure ; } extern "C" { pub fn C_SkContourMeasure_length (self_ : * const SkContourMeasure) -> SkScalar ; } extern "C" { pub fn C_SkContourMeasure_isClosed (self_ : * const SkContourMeasure) -> bool ; } extern "C" { pub fn C_SkDataTable_count (self_ : * const SkDataTable) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkDataTable_MakeEmpty () -> * mut SkDataTable ; } extern "C" { pub fn C_SkDataTable_MakeCopyArrays (ptrs : * const * const :: core :: ffi :: c_void , sizes : * const usize , count : :: std :: os :: raw :: c_int) -> * mut SkDataTable ; } extern "C" { pub fn C_SkDataTable_MakeCopyArray (array : * const :: core :: ffi :: c_void , elemSize : usize , count : :: std :: os :: raw :: c_int) -> * mut SkDataTable ; } extern "C" { pub fn C_SkDeferredDisplayListRecorder_destruct (self_ : * mut SkDeferredDisplayListRecorder) ; } extern "C" { pub fn C_SkDeferredDisplayListRecorder_detach (self_ : * mut SkDeferredDisplayListRecorder) -> * mut SkDeferredDisplayList ; } extern "C" { pub fn C_SkDeferredDisplayList_ref (self_ : * const SkDeferredDisplayList) ; } extern "C" { pub fn C_SkDeferredDisplayList_unref (self_ : * const SkDeferredDisplayList) ; } extern "C" { pub fn C_SkDeferredDisplayList_unique (self_ : * const SkDeferredDisplayList) -> bool ; } extern "C" { pub fn C_SkDrawable_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkDrawable ; } extern "C" { pub fn C_SkDrawable_getBounds (self_ : * mut SkDrawable) -> SkRect ; } extern "C" { pub fn C_SkImageFilter_computeFastBounds (self_ : * const SkImageFilter , bounds : * const SkRect) -> SkRect ; } extern "C" { pub fn C_SkImageFilter_makeWithLocalMatrix (self_ : * const SkImageFilter , matrix : * const SkMatrix) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilter_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilter_filterBounds (self_ : * const SkImageFilter , src : * const SkIRect , ctm : * const SkMatrix , mapDirection : SkImageFilter_MapDirection , inputRect : * const SkIRect) -> SkIRect ; } extern "C" { pub fn C_SkImageFilter_isColorFilterNode (self_ : * const SkImageFilter , filterPtr : * mut * mut SkColorFilter) -> bool ; } extern "C" { pub fn C_SkImageFilter_countInputs (self_ : * const SkImageFilter) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkImageFilter_getInput (self_ : * const SkImageFilter , i : :: std :: os :: raw :: c_int) -> * const SkImageFilter ; } extern "C" { pub fn C_SkImageGenerator_delete (self_ : * mut SkImageGenerator) ; } extern "C" { pub fn C_SkImageGenerator_refEncodedData (self_ : * mut SkImageGenerator) -> * mut SkData ; } extern "C" { pub fn C_SkImageGenerator_MakeFromEncoded (data : * mut SkData , alphaType : * const SkAlphaType) -> * mut SkImageGenerator ; } extern "C" { pub fn C_SkImageGenerator_MakeFromPicture (size : * const SkISize , picture : * mut SkPicture , matrix : * const SkMatrix , paint : * const SkPaint , bd : SkImage_BitDepth , cs : * mut SkColorSpace , props : * const SkSurfaceProps) -> * mut SkImageGenerator ; } extern "C" { pub fn C_SkString_destruct (self_ : * mut SkString) ; } extern "C" { pub fn C_SkString_c_str_size (self_ : * const SkString , size : * mut usize) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn C_SkStrings_construct (uninitialized : * mut SkStrings , string : * mut SkString , count : usize) ; } extern "C" { pub fn C_SkStrings_destruct (self_ : * mut SkStrings) ; } extern "C" { pub fn C_SkStrings_ptr_count (self_ : * const SkStrings , count : * mut usize) -> * const SkString ; } extern "C" { pub fn C_string_view_ptr_size (self_ : * const std_string_view , size : * mut usize) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn C_string_ptr_size (self_ : * const std_string , size : * mut usize) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn C_SkStrokeRec_destruct (self_ : * mut SkStrokeRec) ; } extern "C" { pub fn C_SkStrokeRec_copy (self_ : * const SkStrokeRec , other : * mut SkStrokeRec) ; } extern "C" { pub fn C_SkStrokeRec_getCap (self_ : * const SkStrokeRec) -> SkPaint_Cap ; } extern "C" { pub fn C_SkStrokeRec_getJoin (self_ : * const SkStrokeRec) -> SkPaint_Join ; } extern "C" { pub fn C_SkStrokeRec_hasEqualEffect (self_ : * const SkStrokeRec , other : * const SkStrokeRec) -> bool ; } extern "C" { pub fn C_SkPathEffect_MakeSum (first : * mut SkPathEffect , second : * mut SkPathEffect) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkPathEffect_MakeCompose (outer : * mut SkPathEffect , inner : * mut SkPathEffect) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkPathEffect_DashInfo_Construct (uninitialized : * mut SkPathEffect_DashInfo) ; } extern "C" { pub fn C_SkPathEffect_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkPixmap_destruct (self_ : * mut SkPixmap) ; } extern "C" { pub fn C_SkPixmap_setColorSpace (self_ : * mut SkPixmap , colorSpace : * mut SkColorSpace) ; } extern "C" { pub fn C_SkMaskFilter_MakeBlur (style : SkBlurStyle , sigma : SkScalar , respectCTM : bool) -> * mut SkMaskFilter ; } extern "C" { pub fn C_SkMaskFilter_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkMaskFilter ; } extern "C" { pub fn C_SkSize_toRound (size : * const SkSize) -> SkISize ; } extern "C" { pub fn C_SkSize_toCeil (size : * const SkSize) -> SkISize ; } extern "C" { pub fn C_SkSize_toFloor (size : * const SkSize) -> SkISize ; } extern "C" { pub fn C_SkShader_isOpaque (self_ : * const SkShader) -> bool ; } extern "C" { pub fn C_SkShader_isAImage (self_ : * const SkShader) -> bool ; } extern "C" { pub fn C_SkShader_asAGradient (self_ : * const SkShader , info : * mut SkShader_GradientInfo) -> SkShader_GradientType ; } extern "C" { pub fn C_SkShader_makeWithLocalMatrix (self_ : * const SkShader , matrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkShader_makeWithColorFilter (self_ : * const SkShader , colorFilter : * mut SkColorFilter) -> * mut SkShader ; } extern "C" { pub fn C_SkShaders_Empty () -> * mut SkShader ; } extern "C" { pub fn C_SkShaders_Color (color : SkColor) -> * mut SkShader ; } extern "C" { pub fn C_SkShaders_Color2 (color : * const SkColor4f , colorSpace : * mut SkColorSpace) -> * mut SkShader ; } extern "C" { pub fn C_SkShaders_Blend (blender : * mut SkBlender , dst : * mut SkShader , src : * mut SkShader) -> * mut SkShader ; } extern "C" { pub fn C_SkShader_Deserialize (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkShader ; } extern "C" { pub fn C_SkStream_delete (stream : * mut SkStream) ; } extern "C" { pub fn C_SkStream_read (stream : * mut SkStream , buffer : * mut :: core :: ffi :: c_void , len : usize) -> usize ; } extern "C" { pub fn C_SkStreamAsset_getLength (self_ : * const SkStreamAsset) -> usize ; } extern "C" { pub fn C_SkWStream_destruct (self_ : * mut SkWStream) ; } extern "C" { pub fn C_SkWStream_write (self_ : * mut SkWStream , buffer : * const :: core :: ffi :: c_void , size : usize) -> bool ; } extern "C" { pub fn C_SkMemoryStream_MakeDirect (data : * const :: core :: ffi :: c_void , length : usize) -> * mut SkMemoryStream ; } extern "C" { pub fn C_SkDynamicMemoryWStream_Construct (uninitialized : * mut SkDynamicMemoryWStream) ; } extern "C" { pub fn C_SkDynamicMemoryWStream_detachAsData (self_ : * mut SkDynamicMemoryWStream) -> * mut SkData ; } extern "C" { pub fn C_SkDynamicMemoryWStream_detachAsStream (self_ : * mut SkDynamicMemoryWStream) -> * mut SkStreamAsset ; } extern "C" { pub fn C_SkYUVAInfo_Construct (uninitialized : * mut SkYUVAInfo) ; } extern "C" { pub fn C_SkYUVAInfo_destruct (self_ : * mut SkYUVAInfo) ; } extern "C" { pub fn C_SkYUVAInfo_SubsamplingFactors (subsampling : SkYUVAInfo_Subsampling , factors : * mut :: std :: os :: raw :: c_int) ; } extern "C" { pub fn C_SkYUVAInfo_PlaneSubsamplingFactors (planeConfig : SkYUVAInfo_PlaneConfig , subsampling : SkYUVAInfo_Subsampling , planeIdx : :: std :: os :: raw :: c_int , factors : * mut :: std :: os :: raw :: c_int) ; } extern "C" { pub fn C_SkYUVAInfo_NumPlanes (planeConfig : SkYUVAInfo_PlaneConfig) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkYUVAInfo_NumChannelsInPlane (planarConfig : SkYUVAInfo_PlaneConfig , i : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkYUVAInfo_equals (a : * const SkYUVAInfo , b : * const SkYUVAInfo) -> bool ; } extern "C" { pub fn C_SkYUVAInfo_makeSubsampling (self_ : * const SkYUVAInfo , subsampling : SkYUVAInfo_Subsampling , uninitialized : * mut SkYUVAInfo) ; } extern "C" { pub fn C_SkYUVAInfo_makeDimensions (self_ : * const SkYUVAInfo , dimensions : * const SkISize , uninitialized : * mut SkYUVAInfo) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_Construct (uninitialized : * mut SkYUVAPixmapInfo) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_destruct (self_ : * mut SkYUVAPixmapInfo) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_equals (a : * const SkYUVAPixmapInfo , b : * const SkYUVAPixmapInfo) -> bool ; } extern "C" { pub fn C_SkYUVAPixmapInfo_rowBytes (self_ : * const SkYUVAPixmapInfo , i : :: std :: os :: raw :: c_int) -> usize ; } extern "C" { pub fn C_SkYUVAPixmapInfo_planeInfo (self_ : * const SkYUVAPixmapInfo , i : :: std :: os :: raw :: c_int) -> * const SkImageInfo ; } extern "C" { pub fn C_SkYUVAPixmapInfo_isValid (self_ : * const SkYUVAPixmapInfo) -> bool ; } extern "C" { pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_Construct (uninitialized : * mut SkYUVAPixmapInfo_SupportedDataTypes) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_destruct (self_ : * mut SkYUVAPixmapInfo_SupportedDataTypes) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_All (uninitialized : * mut SkYUVAPixmapInfo_SupportedDataTypes) ; } extern "C" { pub fn C_SkYUVAPixmapInfo_SupportedDataTypes_supported (self_ : * const SkYUVAPixmapInfo_SupportedDataTypes , pc : SkYUVAPixmapInfo_PlaneConfig , dt : SkYUVAPixmapInfo_DataType) -> bool ; } extern "C" { pub fn C_SkYUVAPixmapInfo_DefaultColorTypeForDataType (dt : SkYUVAPixmapInfo_DataType , numChannels : :: std :: os :: raw :: c_int) -> SkColorType ; } extern "C" { pub fn C_SkYUVAPixmapInfo_NumChannelsAndDataType (colorType : SkColorType , dataType : * mut SkYUVAPixmapInfo_DataType) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_SkYUVAPixmaps_Construct (uninitialized : * mut SkYUVAPixmaps) ; } extern "C" { pub fn C_SkYUVAPixmaps_destruct (self_ : * mut SkYUVAPixmaps) ; } extern "C" { pub fn C_SkYUVAPixmaps_MakeCopy (self_ : * const SkYUVAPixmaps , uninitialized : * mut SkYUVAPixmaps) ; } extern "C" { pub fn C_SkYUVAPixmaps_Allocate (uninitialized : * mut SkYUVAPixmaps , yuvaPixmapInfo : * const SkYUVAPixmapInfo) ; } extern "C" { pub fn C_SkYUVAPixmaps_FromData (uninitialized : * mut SkYUVAPixmaps , yuvaPixmapInfo : * const SkYUVAPixmapInfo , data : * mut SkData) ; } extern "C" { pub fn C_SkYUVAPixmaps_FromExternalMemory (uninitialized : * mut SkYUVAPixmaps , yuvaPixmapInfo : * const SkYUVAPixmapInfo , memory : * mut :: core :: ffi :: c_void) ; } extern "C" { pub fn C_SkYUVAPixmaps_FromExternalPixmaps (uninitialized : * mut SkYUVAPixmaps , yuvaInfo : * const SkYUVAInfo , pixmaps : * const SkPixmap) ; } extern "C" { pub fn C_SkYUVAPixmaps_pixmapsInfo (self_ : * const SkYUVAPixmaps , uninitialized : * mut SkYUVAPixmapInfo) ; } extern "C" { pub fn C_SkYUVAPixmaps_planes (self_ : * const SkYUVAPixmaps) -> * const SkPixmap ; } extern "C" { pub fn C_SkYUVAPixmaps_isValid (self_ : * const SkYUVAPixmaps) -> bool ; } extern "C" { pub fn C_Effects_Types (arg1 : * mut SkTableMaskFilter) ; } extern "C" { pub fn C_SkBlenders_Arithmetic (k1 : f32 , k2 : f32 , k3 : f32 , k4 : f32 , enforcePremul : bool) -> * mut SkBlender ; } extern "C" { pub fn C_SkGradientShader_Types (arg1 : * mut SkGradientShader) ; } extern "C" { pub fn C_SkGradientShader_MakeLinear (pts : * const SkPoint , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeLinear2 (pts : * const SkPoint , colors : * const SkColor4f , colorSpace : * mut SkColorSpace , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeRadial (center : * const SkPoint , radius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeRadial2 (center : * const SkPoint , radius : SkScalar , colors : * const SkColor4f , colorSpace : * mut SkColorSpace , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeTwoPointConical (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeTwoPointConical2 (start : * const SkPoint , startRadius : SkScalar , end : * const SkPoint , endRadius : SkScalar , colors : * const SkColor4f , colorSpace : * mut SkColorSpace , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeSweep (cx : SkScalar , cy : SkScalar , colors : * const SkColor , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkGradientShader_MakeSweep2 (cx : SkScalar , cy : SkScalar , colors : * const SkColor4f , colorSpace : * mut SkColorSpace , pos : * const SkScalar , count : :: std :: os :: raw :: c_int , mode : SkTileMode , startAngle : SkScalar , endAngle : SkScalar , flags : u32 , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkPerlinNoiseShader_MakeFractalNoise (baseFrequencyX : SkScalar , baseFrequencyY : SkScalar , numOctaves : :: std :: os :: raw :: c_int , seed : SkScalar , tileSize : * const SkISize) -> * mut SkShader ; } extern "C" { pub fn C_SkPerlinNoiseShader_MakeTurbulence (baseFrequencyX : SkScalar , baseFrequencyY : SkScalar , numOctaves : :: std :: os :: raw :: c_int , seed : SkScalar , tileSize : * const SkISize) -> * mut SkShader ; } extern "C" { pub fn C_SkPath1DPathEffect_Make (path : * const SkPath , advance : SkScalar , phase : SkScalar , style : SkPath1DPathEffect_Style) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkLine2DPathEffect_Make (width : SkScalar , matrix : * const SkMatrix) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkPath2DPathEffect_Make (matrix : * const SkMatrix , path : * const SkPath) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkColorMatrix_Construct (uninitialized : * mut SkColorMatrix) ; } extern "C" { pub fn C_SkColorMatrix_Construct2 (uninitialized : * mut SkColorMatrix , m00 : f32 , m01 : f32 , m02 : f32 , m03 : f32 , m04 : f32 , m10 : f32 , m11 : f32 , m12 : f32 , m13 : f32 , m14 : f32 , m20 : f32 , m21 : f32 , m22 : f32 , m23 : f32 , m24 : f32 , m30 : f32 , m31 : f32 , m32 : f32 , m33 : f32 , m34 : f32) ; } extern "C" { pub fn C_SkColorMatrix_setRowMajor (self_ : * mut SkColorMatrix , src : * const f32) ; } extern "C" { pub fn C_SkColorMatrix_getRowMajor (self_ : * const SkColorMatrix , dst : * mut f32) ; } extern "C" { pub fn C_SkColorMatrixFilter_MakeLightingFilter (mul : SkColor , add : SkColor) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkCornerPathEffect_Make (radius : SkScalar) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkDashPathEffect_Make (intervals : * const SkScalar , count : :: std :: os :: raw :: c_int , phase : SkScalar) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkDiscretePathEffect_Make (segLength : SkScalar , dev : SkScalar , seedAssist : u32) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkHighContrastFilter_Make (config : * const SkHighContrastConfig) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkLumaColorFilter_Make () -> * mut SkColorFilter ; } extern "C" { pub fn C_SkMergePathEffect_Make (one : * mut SkPathEffect , two : * mut SkPathEffect , op : SkPathOp) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkMatrixPathEffect_MakeTranslate (dx : SkScalar , dy : SkScalar) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkMatrixPathEffect_Make (m : * const SkMatrix) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkStrokePathEffect_Make (width : SkScalar , join : SkPaint_Join , cap : SkPaint_Cap , miter : SkScalar) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkOverdrawColorFilter_MakeWithSkColors (colors : * const SkColor) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkRuntimeEffect_MakeForColorFilter (sksl : * const SkString , options : * const SkRuntimeEffect_Options , error : * mut SkString) -> * mut SkRuntimeEffect ; } extern "C" { pub fn C_SkRuntimeEffect_MakeForShader (sksl : * const SkString , options : * const SkRuntimeEffect_Options , error : * mut SkString) -> * mut SkRuntimeEffect ; } extern "C" { pub fn C_SkRuntimeEffect_MakeForBlender (sksl : * const SkString , options : * const SkRuntimeEffect_Options , error : * mut SkString) -> * mut SkRuntimeEffect ; } extern "C" { pub fn C_SkRuntimeEffect_makeShader (self_ : * const SkRuntimeEffect , uniforms : * const SkData , children : * mut SkRuntimeEffect_ChildPtr , childCount : usize , localMatrix : * const SkMatrix) -> * mut SkShader ; } extern "C" { pub fn C_SkRuntimeEffect_makeImage (self_ : * const SkRuntimeEffect , context : * mut GrRecordingContext , uniforms : * const SkData , children : * mut SkRuntimeEffect_ChildPtr , childCount : usize , localMatrix : * const SkMatrix , resultInfo : * const SkImageInfo , mipmapped : bool) -> * mut SkImage ; } extern "C" { pub fn C_SkRuntimeEffect_makeColorFilter (self_ : * const SkRuntimeEffect , inputs : * const SkData , children : * mut SkRuntimeEffect_ChildPtr , childCount : usize) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkRuntimeEffect_makeBlender (self_ : * const SkRuntimeEffect , uniforms : * const SkData , children : * mut SkRuntimeEffect_ChildPtr , childCount : usize) -> * mut SkBlender ; } extern "C" { pub fn C_SkRuntimeEffect_source (self_ : * const SkRuntimeEffect , len : * mut usize) -> * const :: std :: os :: raw :: c_uchar ; } extern "C" { pub fn C_SkRuntimeEffect_uniforms (self_ : * const SkRuntimeEffect , count : * mut usize) -> * const SkRuntimeEffect_Uniform ; } extern "C" { pub fn C_SkRuntimeEffect_children (self_ : * const SkRuntimeEffect , count : * mut usize) -> * const SkRuntimeEffect_Child ; } extern "C" { pub fn C_SkRuntimeEffect_findUniform (self_ : * const SkRuntimeEffect , name : * const :: std :: os :: raw :: c_char , count : usize) -> * const SkRuntimeEffect_Uniform ; } extern "C" { pub fn C_SkRuntimeEffect_findChild (self_ : * const SkRuntimeEffect , name : * const :: std :: os :: raw :: c_char , count : usize) -> * const SkRuntimeEffect_Child ; } extern "C" { pub fn C_SkRuntimeEffect_allowShader (self_ : * const SkRuntimeEffect) -> bool ; } extern "C" { pub fn C_SkRuntimeEffect_allowColorFilter (self_ : * const SkRuntimeEffect) -> bool ; } extern "C" { pub fn C_SkRuntimeEffect_allowBlender (self_ : * const SkRuntimeEffect) -> bool ; } extern "C" { pub fn C_SkShaderMaskFilter_Make (shader : * mut SkShader) -> * mut SkMaskFilter ; } extern "C" { pub fn C_SkStrokeAndFillePathEffect_Make () -> * mut SkPathEffect ; } extern "C" { pub fn C_SkTableColorFilter_Make (table : * const u8) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkTableColorFilter_MakeARGB (tableA : * const u8 , tableR : * const u8 , tableG : * const u8 , tableB : * const u8) -> * mut SkColorFilter ; } extern "C" { pub fn C_SkTrimPathEffect_Make (startT : SkScalar , stopT : SkScalar , mode : SkTrimPathEffect_Mode) -> * mut SkPathEffect ; } extern "C" { pub fn C_SkImageFilters_AlphaThreshold (region : * const SkRegion , innerMin : SkScalar , outerMax : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Arithmetic (k1 : f32 , k2 : f32 , k3 : f32 , k4 : f32 , enforcePMColor : bool , background : * mut SkImageFilter , foreground : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Blend (blender : * mut SkBlender , background : * mut SkImageFilter , foreground : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Blur (sigmaX : SkScalar , sigmaY : SkScalar , tileMode : SkTileMode , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_ColorFilter (cf : * mut SkColorFilter , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Compose (outer : * mut SkImageFilter , inner : * mut SkImageFilter) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_DisplacementMap (xChannelSelector : SkColorChannel , yChannelSelector : SkColorChannel , scale : SkScalar , displacement : * mut SkImageFilter , color : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_DropShadow (dx : SkScalar , dy : SkScalar , sigmaX : SkScalar , sigmaY : SkScalar , color : SkColor , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_DropShadowOnly (dx : SkScalar , dy : SkScalar , sigmaX : SkScalar , sigmaY : SkScalar , color : SkColor , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Image (image : * mut SkImage , srcRect : * const SkRect , dstRect : * const SkRect , sampling : * const SkSamplingOptions) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Magnifier (srcRect : * const SkRect , inset : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_MatrixConvolution (kernelSize : * const SkISize , kernel : * const SkScalar , gain : SkScalar , bias : SkScalar , kernelOffset : * const SkIPoint , tileMode : SkTileMode , convolveAlpha : bool , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_MatrixTransform (matrix : * const SkMatrix , sampling : * const SkSamplingOptions , input : * mut SkImageFilter) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Merge (filters : * const * mut SkImageFilter , count : :: std :: os :: raw :: c_int , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Offset (dx : SkScalar , dy : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Paint (paint : * const SkPaint , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Picture (pic : * mut SkPicture , targetRect : * const SkRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Shader (shader : * mut SkShader , dither : SkImageFilters_Dither , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Tile (src : * const SkRect , dst : * const SkRect , input : * mut SkImageFilter) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Dilate (radiusX : SkScalar , radiusY : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_Erode (radiusX : SkScalar , radiusY : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_DistantLitDiffuse (direction : * const SkPoint3 , lightColor : SkColor , surfaceScale : SkScalar , kd : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_PointLitDiffuse (direction : * const SkPoint3 , lightColor : SkColor , surfaceScale : SkScalar , kd : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_SpotLitDiffuse (location : * const SkPoint3 , target : * const SkPoint3 , specularExponent : SkScalar , cutoffAngle : SkScalar , lightColor : SkColor , surfaceScale : SkScalar , kd : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_ImageFilters_DistantLitSpecular (direction : * const SkPoint3 , lightColor : SkColor , surfaceScale : SkScalar , ks : SkScalar , shininess : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_PointLitSpecular (location : * const SkPoint3 , lightColor : SkColor , surfaceScale : SkScalar , ks : SkScalar , shininess : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkImageFilters_SpotLitSpecular (location : * const SkPoint3 , target : * const SkPoint3 , specularExponent : SkScalar , cutoffAngle : SkScalar , lightColor : SkColor , surfaceScale : SkScalar , ks : SkScalar , shininess : SkScalar , input : * mut SkImageFilter , cropRect : * const SkImageFilters_CropRect) -> * mut SkImageFilter ; } extern "C" { pub fn C_SkPDF_AttributeList_destruct (self_ : * mut SkPDF_AttributeList) ; } extern "C" { pub fn C_SkPDF_AttributeList_appendFloatArray (self_ : * mut SkPDF_AttributeList , owner : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , value : * const f32 , len : usize) ; } extern "C" { pub fn C_SkPDF_StructureElementNode_New () -> * mut SkPDF_StructureElementNode ; } extern "C" { pub fn C_SkPDF_StructureElementNode_delete (self_ : * mut SkPDF_StructureElementNode) ; } extern "C" { pub fn C_SkPDF_StructureElementNode_setChildVector (self_ : * mut SkPDF_StructureElementNode , nodes : * mut * mut SkPDF_StructureElementNode , len : usize) ; } extern "C" { pub fn C_SkPDF_StructElementNode_appendChild (self_ : * mut SkPDF_StructureElementNode , node : * mut SkPDF_StructureElementNode) ; } extern "C" { pub fn C_SkPDF_StructureElementNode_getChildVector (self_ : * const SkPDF_StructureElementNode , nodes : * mut * mut SkPDF_StructureElementNode) -> usize ; } extern "C" { pub fn C_SkPDF_Metadata_Construct (uninitialized : * mut SkPDF_Metadata) ; } extern "C" { pub fn C_SkPDF_Metadata_destruct (self_ : * mut SkPDF_Metadata) ; } extern "C" { pub fn C_SkPDF_MakeDocument (stream : * mut SkWStream , metadata : * const SkPDF_Metadata) -> * mut SkDocument ; } extern "C" { pub fn C_SkOpBuilder_Construct (uninitialized : * mut SkOpBuilder) ; } extern "C" { pub fn C_SkOpBuilder_destruct (self_ : * mut SkOpBuilder) ; } extern "C" { pub fn C_SVG_Types (arg1 : * mut SkSVGCanvas) ; } extern "C" { pub fn C_SkSVGCanvas_Make (bounds : * const SkRect , writer : * mut SkWStream , flags : u32) -> * mut SkCanvas ; } extern "C" { pub fn C_Utils_Types (arg1 : * mut SkShadowFlags , arg2 : * mut SkShadowUtils , arg3 : * mut SkTextUtils , arg4 : * mut SkParsePath , arg5 : * mut SkCustomTypefaceBuilder) ; } extern "C" { pub fn C_Sk3DView_new () -> * mut Sk3DView ; } extern "C" { pub fn C_Sk3DView_delete (self_ : * mut Sk3DView) ; } extern "C" { pub fn C_SkCustomTypefaceBuilder_destruct (self_ : * mut SkCustomTypefaceBuilder) ; } extern "C" { pub fn C_SkCustomTypefaceBuilder_detach (self_ : * mut SkCustomTypefaceBuilder) -> * mut SkTypeface ; } extern "C" { pub fn C_SkCustomTypefaceBuilder_setGlyph (self_ : * mut SkCustomTypefaceBuilder , glyph : SkGlyphID , advance : f32 , drawable : * mut SkDrawable , bounds : * const SkRect) ; } extern "C" { pub fn C_SkMakeNullCanvas () -> * mut SkCanvas ; } extern "C" { pub fn C_SkOrderedFontMgr_new () -> * mut SkOrderedFontMgr ; } extern "C" { pub fn C_SkOrderedFontMgr_append (self_ : * mut SkOrderedFontMgr , fontMgr : * mut SkFontMgr) ; } # [repr (C)] # [derive (Debug)] pub struct RustStream { pub _base : SkStream , pub m_data : * mut :: core :: ffi :: c_void , pub m_length : usize , pub m_isEof : bool , pub m_read : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : * mut :: core :: ffi :: c_void , arg3 : usize) -> usize > , pub m_seekAbsolute : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : usize) -> bool > , pub m_seekRelative : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : :: std :: os :: raw :: c_long) -> bool > , } # [test] fn bindgen_test_layout_RustStream () { assert_eq ! (:: core :: mem :: size_of :: < RustStream > () , 56usize , concat ! ("Size of: " , stringify ! (RustStream))) ; assert_eq ! (:: core :: mem :: align_of :: < RustStream > () , 8usize , concat ! ("Alignment of " , stringify ! (RustStream))) ; fn test_field_m_data () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_data) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_data))) ; } test_field_m_data () ; fn test_field_m_length () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_length) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_length))) ; } test_field_m_length () ; fn test_field_m_isEof () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_isEof) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_isEof))) ; } test_field_m_isEof () ; fn test_field_m_read () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_read) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_read))) ; } test_field_m_read () ; fn test_field_m_seekAbsolute () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_seekAbsolute) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_seekAbsolute))) ; } test_field_m_seekAbsolute () ; fn test_field_m_seekRelative () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustStream > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . m_seekRelative) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (RustStream) , "::" , stringify ! (m_seekRelative))) ; } test_field_m_seekRelative () ; } extern "C" { # [link_name = "\u{1}??0RustStream@@QEAA@PEAX_KP6A_K001@ZP6A_N01@ZP6A_N0J@Z@Z"] pub fn RustStream_RustStream (this : * mut RustStream , data : * mut :: core :: ffi :: c_void , length : usize , read : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : * mut :: core :: ffi :: c_void , arg3 : usize) -> usize > , seekAbsolute : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : usize) -> bool > , seekRelative : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : :: std :: os :: raw :: c_long) -> bool >) ; } impl RustStream { # [inline] pub unsafe fn new (data : * mut :: core :: ffi :: c_void , length : usize , read : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : * mut :: core :: ffi :: c_void , arg3 : usize) -> usize > , seekAbsolute : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : usize) -> bool > , seekRelative : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : :: std :: os :: raw :: c_long) -> bool >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; RustStream_RustStream (__bindgen_tmp . as_mut_ptr () , data , length , read , seekAbsolute , seekRelative) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?read@RustStream@@UEAA_KPEAX_K@Z"] pub fn RustStream_read (this : * mut :: core :: ffi :: c_void , buffer : * mut :: core :: ffi :: c_void , count : usize) -> usize ; } extern "C" { # [link_name = "\u{1}?rewind@RustStream@@UEAA_NXZ"] pub fn RustStream_rewind (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?seek@RustStream@@UEAA_N_K@Z"] pub fn RustStream_seek (this : * mut :: core :: ffi :: c_void , pos : usize) -> bool ; } extern "C" { # [link_name = "\u{1}?move@RustStream@@UEAA_NJ@Z"] pub fn RustStream_move (this : * mut :: core :: ffi :: c_void , offset : :: std :: os :: raw :: c_long) -> bool ; } extern "C" { # [link_name = "\u{1}?isAtEnd@RustStream@@UEBA_NXZ"] pub fn RustStream_isAtEnd (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?hasLength@RustStream@@UEBA_NXZ"] pub fn RustStream_hasLength (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?getLength@RustStream@@UEBA_KXZ"] pub fn RustStream_getLength (this : * mut :: core :: ffi :: c_void) -> usize ; } extern "C" { pub fn C_RustStream_construct (out : * mut RustStream , data : * mut :: core :: ffi :: c_void , length : usize , read : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : * mut :: core :: ffi :: c_void , arg3 : usize) -> usize > , seekAbsolute : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : usize) -> bool > , seekRelative : :: core :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: core :: ffi :: c_void , arg2 : :: std :: os :: raw :: c_long) -> bool >) ; } extern "C" { pub fn C_RustStream_destruct (stream : * mut RustStream) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrBackendDrawableInfo { pub fIsValid : bool , pub fBackend : GrBackendApi , pub fVkInfo : GrVkDrawableInfo , } # [test] fn bindgen_test_layout_GrBackendDrawableInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrBackendDrawableInfo > () , 48usize , concat ! ("Size of: " , stringify ! (GrBackendDrawableInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrBackendDrawableInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrBackendDrawableInfo))) ; fn test_field_fIsValid () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsValid) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrBackendDrawableInfo) , "::" , stringify ! (fIsValid))) ; } test_field_fIsValid () ; fn test_field_fBackend () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackend) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (GrBackendDrawableInfo) , "::" , stringify ! (fBackend))) ; } test_field_fBackend () ; fn test_field_fVkInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrBackendDrawableInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkInfo) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrBackendDrawableInfo) , "::" , stringify ! (fVkInfo))) ; } test_field_fVkInfo () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrDirectContextPriv { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct GrDirectContext { pub _bindgen_opaque_blob : [u64 ; 22usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrDirectContext_DirectContextID { pub fID : u32 , } # [test] fn bindgen_test_layout_GrDirectContext_DirectContextID () { assert_eq ! (:: core :: mem :: size_of :: < GrDirectContext_DirectContextID > () , 4usize , concat ! ("Size of: " , stringify ! (GrDirectContext_DirectContextID))) ; assert_eq ! (:: core :: mem :: align_of :: < GrDirectContext_DirectContextID > () , 4usize , concat ! ("Alignment of " , stringify ! (GrDirectContext_DirectContextID))) ; fn test_field_fID () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrDirectContext_DirectContextID > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fID) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrDirectContext_DirectContextID) , "::" , stringify ! (fID))) ; } test_field_fID () ; } extern "C" { # [link_name = "\u{1}?Next@DirectContextID@GrDirectContext@@SA?AV12@XZ"] pub fn GrDirectContext_DirectContextID_Next () -> GrDirectContext_DirectContextID ; } impl GrDirectContext_DirectContextID { # [inline] pub unsafe fn Next () -> GrDirectContext_DirectContextID { GrDirectContext_DirectContextID_Next () } } pub type GrDirectContext_INHERITED = GrRecordingContext ; # [test] fn bindgen_test_layout_GrDirectContext () { assert_eq ! (:: core :: mem :: size_of :: < GrDirectContext > () , 176usize , concat ! ("Size of: " , stringify ! (GrDirectContext))) ; assert_eq ! (:: core :: mem :: align_of :: < GrDirectContext > () , 8usize , concat ! ("Alignment of " , stringify ! (GrDirectContext))) ; } extern "C" { # [link_name = "\u{1}?MakeVulkan@GrDirectContext@@SA?AV?$sk_sp@VGrDirectContext@@@@AEBUGrVkBackendContext@@AEBUGrContextOptions@@@Z"] pub fn GrDirectContext_MakeVulkan (arg1 : * const GrVkBackendContext , arg2 : * const GrContextOptions) -> sk_sp < GrDirectContext > ; } extern "C" { # [link_name = "\u{1}?MakeVulkan@GrDirectContext@@SA?AV?$sk_sp@VGrDirectContext@@@@AEBUGrVkBackendContext@@@Z"] pub fn GrDirectContext_MakeVulkan1 (arg1 : * const GrVkBackendContext) -> sk_sp < GrDirectContext > ; } extern "C" { # [link_name = "\u{1}?MakeMock@GrDirectContext@@SA?AV?$sk_sp@VGrDirectContext@@@@PEBUGrMockOptions@@AEBUGrContextOptions@@@Z"] pub fn GrDirectContext_MakeMock (arg1 : * const GrMockOptions , arg2 : * const GrContextOptions) -> sk_sp < GrDirectContext > ; } extern "C" { # [link_name = "\u{1}?MakeMock@GrDirectContext@@SA?AV?$sk_sp@VGrDirectContext@@@@PEBUGrMockOptions@@@Z"] pub fn GrDirectContext_MakeMock1 (arg1 : * const GrMockOptions) -> sk_sp < GrDirectContext > ; } extern "C" { # [link_name = "\u{1}?resetContext@GrDirectContext@@QEAAXI@Z"] pub fn GrDirectContext_resetContext (this : * mut GrDirectContext , state : u32) ; } extern "C" { # [link_name = "\u{1}?resetGLTextureBindings@GrDirectContext@@QEAAXXZ"] pub fn GrDirectContext_resetGLTextureBindings (this : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?threadSafeProxy@GrDirectContext@@QEAA?AV?$sk_sp@VGrContextThreadSafeProxy@@@@XZ"] pub fn GrDirectContext_threadSafeProxy (this : * mut GrDirectContext) -> sk_sp < GrContextThreadSafeProxy > ; } extern "C" { # [link_name = "\u{1}?oomed@GrDirectContext@@QEAA_NXZ"] pub fn GrDirectContext_oomed (this : * mut GrDirectContext) -> bool ; } extern "C" { # [link_name = "\u{1}?releaseResourcesAndAbandonContext@GrDirectContext@@QEAAXXZ"] pub fn GrDirectContext_releaseResourcesAndAbandonContext (this : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?getResourceCacheLimits@GrDirectContext@@QEBAXPEAHPEA_K@Z"] pub fn GrDirectContext_getResourceCacheLimits (this : * const GrDirectContext , maxResources : * mut :: std :: os :: raw :: c_int , maxResourceBytes : * mut usize) ; } extern "C" { # [link_name = "\u{1}?getResourceCacheLimit@GrDirectContext@@QEBA_KXZ"] pub fn GrDirectContext_getResourceCacheLimit (this : * const GrDirectContext) -> usize ; } extern "C" { # [link_name = "\u{1}?getResourceCacheUsage@GrDirectContext@@QEBAXPEAHPEA_K@Z"] pub fn GrDirectContext_getResourceCacheUsage (this : * const GrDirectContext , resourceCount : * mut :: std :: os :: raw :: c_int , resourceBytes : * mut usize) ; } extern "C" { # [link_name = "\u{1}?getResourceCachePurgeableBytes@GrDirectContext@@QEBA_KXZ"] pub fn GrDirectContext_getResourceCachePurgeableBytes (this : * const GrDirectContext) -> usize ; } extern "C" { # [link_name = "\u{1}?setResourceCacheLimits@GrDirectContext@@QEAAXH_K@Z"] pub fn GrDirectContext_setResourceCacheLimits (this : * mut GrDirectContext , maxResources : :: std :: os :: raw :: c_int , maxResourceBytes : usize) ; } extern "C" { # [link_name = "\u{1}?setResourceCacheLimit@GrDirectContext@@QEAAX_K@Z"] pub fn GrDirectContext_setResourceCacheLimit (this : * mut GrDirectContext , maxResourceBytes : usize) ; } extern "C" { # [link_name = "\u{1}?freeGpuResources@GrDirectContext@@QEAAXXZ"] pub fn GrDirectContext_freeGpuResources (this : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?performDeferredCleanup@GrDirectContext@@QEAAXV?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_N@Z"] pub fn GrDirectContext_performDeferredCleanup (this : * mut GrDirectContext , msNotUsed : std_chrono_milliseconds , scratchResourcesOnly : bool) ; } extern "C" { # [link_name = "\u{1}?purgeUnlockedResources@GrDirectContext@@QEAAX_K_N@Z"] pub fn GrDirectContext_purgeUnlockedResources (this : * mut GrDirectContext , bytesToPurge : usize , preferScratchResources : bool) ; } extern "C" { # [link_name = "\u{1}?purgeUnlockedResources@GrDirectContext@@QEAAX_N@Z"] pub fn GrDirectContext_purgeUnlockedResources1 (this : * mut GrDirectContext , scratchResourcesOnly : bool) ; } extern "C" { # [link_name = "\u{1}?wait@GrDirectContext@@QEAA_NHPEBVGrBackendSemaphore@@_N@Z"] pub fn GrDirectContext_wait (this : * mut GrDirectContext , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore , deleteSemaphoresAfterWait : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?flush@GrDirectContext@@QEAA?AW4GrSemaphoresSubmitted@@AEBUGrFlushInfo@@@Z"] pub fn GrDirectContext_flush (this : * mut GrDirectContext , info : * const GrFlushInfo) -> GrSemaphoresSubmitted ; } extern "C" { # [link_name = "\u{1}?submit@GrDirectContext@@QEAA_N_N@Z"] pub fn GrDirectContext_submit (this : * mut GrDirectContext , syncCpu : bool) -> bool ; } extern "C" { # [link_name = "\u{1}?checkAsyncWorkCompletion@GrDirectContext@@QEAAXXZ"] pub fn GrDirectContext_checkAsyncWorkCompletion (this : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?dumpMemoryStatistics@GrDirectContext@@QEBAXPEAVSkTraceMemoryDump@@@Z"] pub fn GrDirectContext_dumpMemoryStatistics (this : * const GrDirectContext , traceMemoryDump : * mut SkTraceMemoryDump) ; } extern "C" { # [link_name = "\u{1}?supportsDistanceFieldText@GrDirectContext@@QEBA_NXZ"] pub fn GrDirectContext_supportsDistanceFieldText (this : * const GrDirectContext) -> bool ; } extern "C" { # [link_name = "\u{1}?storeVkPipelineCacheData@GrDirectContext@@QEAAXXZ"] pub fn GrDirectContext_storeVkPipelineCacheData (this : * mut GrDirectContext) ; } extern "C" { # [link_name = "\u{1}?createBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHAEBVGrBackendFormat@@W4GrMipmapped@@W4GrRenderable@@W4GrProtected@@@Z"] pub fn GrDirectContext_createBackendTexture (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHW4SkColorType@@W4GrMipmapped@@W4GrRenderable@@W4GrProtected@@@Z"] pub fn GrDirectContext_createBackendTexture1 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkColorType , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHAEBVGrBackendFormat@@AEBU?$SkRGBA4f@$02@@W4GrMipmapped@@W4GrRenderable@@W4GrProtected@@P6AXPEAX@Z5@Z"] pub fn GrDirectContext_createBackendTexture2 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHW4SkColorType@@AEBU?$SkRGBA4f@$02@@W4GrMipmapped@@W4GrRenderable@@W4GrProtected@@P6AXPEAX@Z5@Z"] pub fn GrDirectContext_createBackendTexture3 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkColorType , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@QEBVSkPixmap@@HW4GrSurfaceOrigin@@W4GrRenderable@@W4GrProtected@@P6AXPEAX@Z4@Z"] pub fn GrDirectContext_createBackendTexture4 (this : * mut GrDirectContext , srcData : * const SkPixmap , numLevels : :: std :: os :: raw :: c_int , arg1 : GrSurfaceOrigin , arg2 : GrRenderable , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?updateBackendTexture@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@AEBU?$SkRGBA4f@$02@@P6AXPEAX@Z2@Z"] pub fn GrDirectContext_updateBackendTexture (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?updateBackendTexture@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@W4SkColorType@@AEBU?$SkRGBA4f@$02@@P6AXPEAX@Z3@Z"] pub fn GrDirectContext_updateBackendTexture1 (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , skColorType : SkColorType , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?updateBackendTexture@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@QEBVSkPixmap@@HW4GrSurfaceOrigin@@P6AXPEAX@Z3@Z"] pub fn GrDirectContext_updateBackendTexture2 (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , srcData : * const SkPixmap , numLevels : :: std :: os :: raw :: c_int , arg2 : GrSurfaceOrigin , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?createCompressedBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHAEBVGrBackendFormat@@AEBU?$SkRGBA4f@$02@@W4GrMipmapped@@W4GrProtected@@P6AXPEAX@Z4@Z"] pub fn GrDirectContext_createCompressedBackendTexture (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createCompressedBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHW4CompressionType@SkImage@@AEBU?$SkRGBA4f@$02@@W4GrMipmapped@@W4GrProtected@@P6AXPEAX@Z4@Z"] pub fn GrDirectContext_createCompressedBackendTexture1 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkImage_CompressionType , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createCompressedBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHAEBVGrBackendFormat@@PEBX_KW4GrMipmapped@@W4GrProtected@@P6AXPEAX@Z5@Z"] pub fn GrDirectContext_createCompressedBackendTexture2 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , data : * const :: core :: ffi :: c_void , dataSize : usize , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?createCompressedBackendTexture@GrDirectContext@@QEAA?AVGrBackendTexture@@HHW4CompressionType@SkImage@@PEBX_KW4GrMipmapped@@W4GrProtected@@P6AXPEAX@Z5@Z"] pub fn GrDirectContext_createCompressedBackendTexture3 (this : * mut GrDirectContext , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkImage_CompressionType , data : * const :: core :: ffi :: c_void , dataSize : usize , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture ; } extern "C" { # [link_name = "\u{1}?updateCompressedBackendTexture@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@AEBU?$SkRGBA4f@$02@@P6AXPEAX@Z2@Z"] pub fn GrDirectContext_updateCompressedBackendTexture (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?updateCompressedBackendTexture@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@PEBX_KP6AXPEAX@Z3@Z"] pub fn GrDirectContext_updateCompressedBackendTexture1 (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , data : * const :: core :: ffi :: c_void , dataSize : usize , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?setBackendTextureState@GrDirectContext@@QEAA_NAEBVGrBackendTexture@@AEBVGrBackendSurfaceMutableState@@PEAV3@P6AXPEAX@Z3@Z"] pub fn GrDirectContext_setBackendTextureState (this : * mut GrDirectContext , arg1 : * const GrBackendTexture , arg2 : * const GrBackendSurfaceMutableState , previousState : * mut GrBackendSurfaceMutableState , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?setBackendRenderTargetState@GrDirectContext@@QEAA_NAEBVGrBackendRenderTarget@@AEBVGrBackendSurfaceMutableState@@PEAV3@P6AXPEAX@Z3@Z"] pub fn GrDirectContext_setBackendRenderTargetState (this : * mut GrDirectContext , arg1 : * const GrBackendRenderTarget , arg2 : * const GrBackendSurfaceMutableState , previousState : * mut GrBackendSurfaceMutableState , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool ; } extern "C" { # [link_name = "\u{1}?deleteBackendTexture@GrDirectContext@@QEAAXVGrBackendTexture@@@Z"] pub fn GrDirectContext_deleteBackendTexture (this : * mut GrDirectContext , arg1 : GrBackendTexture) ; } extern "C" { # [link_name = "\u{1}?precompileShader@GrDirectContext@@QEAA_NAEBVSkData@@0@Z"] pub fn GrDirectContext_precompileShader (this : * mut GrDirectContext , key : * const SkData , data : * const SkData) -> bool ; } extern "C" { # [link_name = "\u{1}?onGetSmallPathAtlasMgr@GrDirectContext@@IEAAPEAVSmallPathAtlasMgr@v1@skgpu@@XZ"] pub fn GrDirectContext_onGetSmallPathAtlasMgr (this : * mut GrDirectContext) -> * mut skgpu_v1_SmallPathAtlasMgr ; } extern "C" { # [link_name = "\u{1}??0GrDirectContext@@IEAA@W4GrBackendApi@@AEBUGrContextOptions@@@Z"] pub fn GrDirectContext_GrDirectContext (this : * mut GrDirectContext , backend : GrBackendApi , options : * const GrContextOptions) ; } impl GrDirectContext { # [inline] pub unsafe fn MakeVulkan (arg1 : * const GrVkBackendContext , arg2 : * const GrContextOptions) -> sk_sp < GrDirectContext > { GrDirectContext_MakeVulkan (arg1 , arg2) } # [inline] pub unsafe fn MakeVulkan1 (arg1 : * const GrVkBackendContext) -> sk_sp < GrDirectContext > { GrDirectContext_MakeVulkan1 (arg1) } # [inline] pub unsafe fn MakeMock (arg1 : * const GrMockOptions , arg2 : * const GrContextOptions) -> sk_sp < GrDirectContext > { GrDirectContext_MakeMock (arg1 , arg2) } # [inline] pub unsafe fn MakeMock1 (arg1 : * const GrMockOptions) -> sk_sp < GrDirectContext > { GrDirectContext_MakeMock1 (arg1) } # [inline] pub unsafe fn resetContext (& mut self , state : u32) { GrDirectContext_resetContext (self , state) } # [inline] pub unsafe fn resetGLTextureBindings (& mut self) { GrDirectContext_resetGLTextureBindings (self) } # [inline] pub unsafe fn threadSafeProxy (& mut self) -> sk_sp < GrContextThreadSafeProxy > { GrDirectContext_threadSafeProxy (self) } # [inline] pub unsafe fn oomed (& mut self) -> bool { GrDirectContext_oomed (self) } # [inline] pub unsafe fn releaseResourcesAndAbandonContext (& mut self) { GrDirectContext_releaseResourcesAndAbandonContext (self) } # [inline] pub unsafe fn getResourceCacheLimits (& self , maxResources : * mut :: std :: os :: raw :: c_int , maxResourceBytes : * mut usize) { GrDirectContext_getResourceCacheLimits (self , maxResources , maxResourceBytes) } # [inline] pub unsafe fn getResourceCacheLimit (& self) -> usize { GrDirectContext_getResourceCacheLimit (self) } # [inline] pub unsafe fn getResourceCacheUsage (& self , resourceCount : * mut :: std :: os :: raw :: c_int , resourceBytes : * mut usize) { GrDirectContext_getResourceCacheUsage (self , resourceCount , resourceBytes) } # [inline] pub unsafe fn getResourceCachePurgeableBytes (& self) -> usize { GrDirectContext_getResourceCachePurgeableBytes (self) } # [inline] pub unsafe fn setResourceCacheLimits (& mut self , maxResources : :: std :: os :: raw :: c_int , maxResourceBytes : usize) { GrDirectContext_setResourceCacheLimits (self , maxResources , maxResourceBytes) } # [inline] pub unsafe fn setResourceCacheLimit (& mut self , maxResourceBytes : usize) { GrDirectContext_setResourceCacheLimit (self , maxResourceBytes) } # [inline] pub unsafe fn freeGpuResources (& mut self) { GrDirectContext_freeGpuResources (self) } # [inline] pub unsafe fn performDeferredCleanup (& mut self , msNotUsed : std_chrono_milliseconds , scratchResourcesOnly : bool) { GrDirectContext_performDeferredCleanup (self , msNotUsed , scratchResourcesOnly) } # [inline] pub unsafe fn purgeUnlockedResources (& mut self , bytesToPurge : usize , preferScratchResources : bool) { GrDirectContext_purgeUnlockedResources (self , bytesToPurge , preferScratchResources) } # [inline] pub unsafe fn purgeUnlockedResources1 (& mut self , scratchResourcesOnly : bool) { GrDirectContext_purgeUnlockedResources1 (self , scratchResourcesOnly) } # [inline] pub unsafe fn wait (& mut self , numSemaphores : :: std :: os :: raw :: c_int , waitSemaphores : * const GrBackendSemaphore , deleteSemaphoresAfterWait : bool) -> bool { GrDirectContext_wait (self , numSemaphores , waitSemaphores , deleteSemaphoresAfterWait) } # [inline] pub unsafe fn flush (& mut self , info : * const GrFlushInfo) -> GrSemaphoresSubmitted { GrDirectContext_flush (self , info) } # [inline] pub unsafe fn submit (& mut self , syncCpu : bool) -> bool { GrDirectContext_submit (self , syncCpu) } # [inline] pub unsafe fn checkAsyncWorkCompletion (& mut self) { GrDirectContext_checkAsyncWorkCompletion (self) } # [inline] pub unsafe fn dumpMemoryStatistics (& self , traceMemoryDump : * mut SkTraceMemoryDump) { GrDirectContext_dumpMemoryStatistics (self , traceMemoryDump) } # [inline] pub unsafe fn supportsDistanceFieldText (& self) -> bool { GrDirectContext_supportsDistanceFieldText (self) } # [inline] pub unsafe fn storeVkPipelineCacheData (& mut self) { GrDirectContext_storeVkPipelineCacheData (self) } # [inline] pub unsafe fn createBackendTexture (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected) -> GrBackendTexture { GrDirectContext_createBackendTexture (self , width , height , arg1 , arg2 , arg3 , arg4) } # [inline] pub unsafe fn createBackendTexture1 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkColorType , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected) -> GrBackendTexture { GrDirectContext_createBackendTexture1 (self , width , height , arg1 , arg2 , arg3 , arg4) } # [inline] pub unsafe fn createBackendTexture2 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createBackendTexture2 (self , width , height , arg1 , color , arg2 , arg3 , arg4 , finishedProc , finishedContext) } # [inline] pub unsafe fn createBackendTexture3 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkColorType , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrRenderable , arg4 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createBackendTexture3 (self , width , height , arg1 , color , arg2 , arg3 , arg4 , finishedProc , finishedContext) } # [inline] pub unsafe fn createBackendTexture4 (& mut self , srcData : * const SkPixmap , numLevels : :: std :: os :: raw :: c_int , arg1 : GrSurfaceOrigin , arg2 : GrRenderable , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createBackendTexture4 (self , srcData , numLevels , arg1 , arg2 , arg3 , finishedProc , finishedContext) } # [inline] pub unsafe fn updateBackendTexture (& mut self , arg1 : * const GrBackendTexture , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_updateBackendTexture (self , arg1 , color , finishedProc , finishedContext) } # [inline] pub unsafe fn updateBackendTexture1 (& mut self , arg1 : * const GrBackendTexture , skColorType : SkColorType , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_updateBackendTexture1 (self , arg1 , skColorType , color , finishedProc , finishedContext) } # [inline] pub unsafe fn updateBackendTexture2 (& mut self , arg1 : * const GrBackendTexture , srcData : * const SkPixmap , numLevels : :: std :: os :: raw :: c_int , arg2 : GrSurfaceOrigin , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_updateBackendTexture2 (self , arg1 , srcData , numLevels , arg2 , finishedProc , finishedContext) } # [inline] pub unsafe fn createCompressedBackendTexture (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createCompressedBackendTexture (self , width , height , arg1 , color , arg2 , arg3 , finishedProc , finishedContext) } # [inline] pub unsafe fn createCompressedBackendTexture1 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkImage_CompressionType , color : * const SkColor4f , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createCompressedBackendTexture1 (self , width , height , arg1 , color , arg2 , arg3 , finishedProc , finishedContext) } # [inline] pub unsafe fn createCompressedBackendTexture2 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : * const GrBackendFormat , data : * const :: core :: ffi :: c_void , dataSize : usize , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createCompressedBackendTexture2 (self , width , height , arg1 , data , dataSize , arg2 , arg3 , finishedProc , finishedContext) } # [inline] pub unsafe fn createCompressedBackendTexture3 (& mut self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , arg1 : SkImage_CompressionType , data : * const :: core :: ffi :: c_void , dataSize : usize , arg2 : GrMipmapped , arg3 : GrProtected , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> GrBackendTexture { GrDirectContext_createCompressedBackendTexture3 (self , width , height , arg1 , data , dataSize , arg2 , arg3 , finishedProc , finishedContext) } # [inline] pub unsafe fn updateCompressedBackendTexture (& mut self , arg1 : * const GrBackendTexture , color : * const SkColor4f , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_updateCompressedBackendTexture (self , arg1 , color , finishedProc , finishedContext) } # [inline] pub unsafe fn updateCompressedBackendTexture1 (& mut self , arg1 : * const GrBackendTexture , data : * const :: core :: ffi :: c_void , dataSize : usize , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_updateCompressedBackendTexture1 (self , arg1 , data , dataSize , finishedProc , finishedContext) } # [inline] pub unsafe fn setBackendTextureState (& mut self , arg1 : * const GrBackendTexture , arg2 : * const GrBackendSurfaceMutableState , previousState : * mut GrBackendSurfaceMutableState , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_setBackendTextureState (self , arg1 , arg2 , previousState , finishedProc , finishedContext) } # [inline] pub unsafe fn setBackendRenderTargetState (& mut self , arg1 : * const GrBackendRenderTarget , arg2 : * const GrBackendSurfaceMutableState , previousState : * mut GrBackendSurfaceMutableState , finishedProc : GrGpuFinishedProc , finishedContext : GrGpuFinishedContext) -> bool { GrDirectContext_setBackendRenderTargetState (self , arg1 , arg2 , previousState , finishedProc , finishedContext) } # [inline] pub unsafe fn deleteBackendTexture (& mut self , arg1 : GrBackendTexture) { GrDirectContext_deleteBackendTexture (self , arg1) } # [inline] pub unsafe fn precompileShader (& mut self , key : * const SkData , data : * const SkData) -> bool { GrDirectContext_precompileShader (self , key , data) } # [inline] pub unsafe fn onGetSmallPathAtlasMgr (& mut self) -> * mut skgpu_v1_SmallPathAtlasMgr { GrDirectContext_onGetSmallPathAtlasMgr (self) } # [inline] pub unsafe fn new (backend : GrBackendApi , options : * const GrContextOptions) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrDirectContext_GrDirectContext (__bindgen_tmp . as_mut_ptr () , backend , options) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?abandonContext@GrDirectContext@@UEAAXXZ"] pub fn GrDirectContext_abandonContext (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?abandoned@GrDirectContext@@UEAA_NXZ"] pub fn GrDirectContext_abandoned (this : * mut :: core :: ffi :: c_void) -> bool ; } extern "C" { # [link_name = "\u{1}?init@GrDirectContext@@MEAA_NXZ"] pub fn GrDirectContext_init (this : * mut :: core :: ffi :: c_void) -> bool ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct GrVkMemoryAllocator { pub _bindgen_opaque_blob : [u64 ; 2usize] , } pub const GrVkMemoryAllocator_AllocationPropertyFlags_kNone : GrVkMemoryAllocator_AllocationPropertyFlags = 0 ; pub const GrVkMemoryAllocator_AllocationPropertyFlags_kDedicatedAllocation : GrVkMemoryAllocator_AllocationPropertyFlags = 1 ; pub const GrVkMemoryAllocator_AllocationPropertyFlags_kLazyAllocation : GrVkMemoryAllocator_AllocationPropertyFlags = 2 ; pub const GrVkMemoryAllocator_AllocationPropertyFlags_kPersistentlyMapped : GrVkMemoryAllocator_AllocationPropertyFlags = 4 ; pub const GrVkMemoryAllocator_AllocationPropertyFlags_kProtected : GrVkMemoryAllocator_AllocationPropertyFlags = 8 ; pub type GrVkMemoryAllocator_AllocationPropertyFlags = :: std :: os :: raw :: c_int ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum GrVkMemoryAllocator_BufferUsage { kGpuOnly = 0 , kCpuWritesGpuReads = 1 , kTransfersFromCpuToGpu = 2 , kTransfersFromGpuToCpu = 3 , } # [test] fn bindgen_test_layout_GrVkMemoryAllocator () { assert_eq ! (:: core :: mem :: size_of :: < GrVkMemoryAllocator > () , 16usize , concat ! ("Size of: " , stringify ! (GrVkMemoryAllocator))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkMemoryAllocator > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkMemoryAllocator))) ; } pub const GrVkExtensionFlags_kEXT_debug_report_GrVkExtensionFlag : GrVkExtensionFlags = 1 ; pub const GrVkExtensionFlags_kNV_glsl_shader_GrVkExtensionFlag : GrVkExtensionFlags = 2 ; pub const GrVkExtensionFlags_kKHR_surface_GrVkExtensionFlag : GrVkExtensionFlags = 4 ; pub const GrVkExtensionFlags_kKHR_swapchain_GrVkExtensionFlag : GrVkExtensionFlags = 8 ; pub const GrVkExtensionFlags_kKHR_win32_surface_GrVkExtensionFlag : GrVkExtensionFlags = 16 ; pub const GrVkExtensionFlags_kKHR_android_surface_GrVkExtensionFlag : GrVkExtensionFlags = 32 ; pub const GrVkExtensionFlags_kKHR_xcb_surface_GrVkExtensionFlag : GrVkExtensionFlags = 64 ; pub type GrVkExtensionFlags = :: std :: os :: raw :: c_int ; pub const GrVkFeatureFlags_kGeometryShader_GrVkFeatureFlag : GrVkFeatureFlags = 1 ; pub const GrVkFeatureFlags_kDualSrcBlend_GrVkFeatureFlag : GrVkFeatureFlags = 2 ; pub const GrVkFeatureFlags_kSampleRateShading_GrVkFeatureFlag : GrVkFeatureFlags = 4 ; pub type GrVkFeatureFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug)] pub struct GrVkBackendContext { pub fInstance : VkInstance , pub fPhysicalDevice : VkPhysicalDevice , pub fDevice : VkDevice , pub fQueue : VkQueue , pub fGraphicsQueueIndex : u32 , pub fMinAPIVersion : u32 , pub fInstanceVersion : u32 , pub fMaxAPIVersion : u32 , pub fExtensions : u32 , pub fVkExtensions : * const GrVkExtensions , pub fFeatures : u32 , pub fDeviceFeatures : * const VkPhysicalDeviceFeatures , pub fDeviceFeatures2 : * const VkPhysicalDeviceFeatures2 , pub fMemoryAllocator : sk_sp < GrVkMemoryAllocator > , pub fGetProc : GrVkGetProc , pub fOwnsInstanceAndDevice : bool , pub fProtectedContext : GrProtected , } # [test] fn bindgen_test_layout_GrVkBackendContext () { assert_eq ! (:: core :: mem :: size_of :: < GrVkBackendContext > () , 168usize , concat ! ("Size of: " , stringify ! (GrVkBackendContext))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkBackendContext > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkBackendContext))) ; fn test_field_fInstance () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInstance) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fInstance))) ; } test_field_fInstance () ; fn test_field_fPhysicalDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPhysicalDevice) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fPhysicalDevice))) ; } test_field_fPhysicalDevice () ; fn test_field_fDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDevice) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fDevice))) ; } test_field_fDevice () ; fn test_field_fQueue () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fQueue) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fQueue))) ; } test_field_fQueue () ; fn test_field_fGraphicsQueueIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGraphicsQueueIndex) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fGraphicsQueueIndex))) ; } test_field_fGraphicsQueueIndex () ; fn test_field_fMinAPIVersion () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMinAPIVersion) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fMinAPIVersion))) ; } test_field_fMinAPIVersion () ; fn test_field_fInstanceVersion () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fInstanceVersion) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fInstanceVersion))) ; } test_field_fInstanceVersion () ; fn test_field_fMaxAPIVersion () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxAPIVersion) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fMaxAPIVersion))) ; } test_field_fMaxAPIVersion () ; fn test_field_fExtensions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExtensions) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fExtensions))) ; } test_field_fExtensions () ; fn test_field_fVkExtensions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVkExtensions) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fVkExtensions))) ; } test_field_fVkExtensions () ; fn test_field_fFeatures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFeatures) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fFeatures))) ; } test_field_fFeatures () ; fn test_field_fDeviceFeatures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDeviceFeatures) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fDeviceFeatures))) ; } test_field_fDeviceFeatures () ; fn test_field_fDeviceFeatures2 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDeviceFeatures2) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fDeviceFeatures2))) ; } test_field_fDeviceFeatures2 () ; fn test_field_fMemoryAllocator () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMemoryAllocator) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fMemoryAllocator))) ; } test_field_fMemoryAllocator () ; fn test_field_fGetProc () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGetProc) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fGetProc))) ; } test_field_fGetProc () ; fn test_field_fOwnsInstanceAndDevice () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOwnsInstanceAndDevice) as usize - ptr as usize } , 160usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fOwnsInstanceAndDevice))) ; } test_field_fOwnsInstanceAndDevice () ; fn test_field_fProtectedContext () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkBackendContext > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fProtectedContext) as usize - ptr as usize } , 161usize , concat ! ("Offset of field: " , stringify ! (GrVkBackendContext) , "::" , stringify ! (fProtectedContext))) ; } test_field_fProtectedContext () ; } # [repr (C)] # [derive (Debug)] pub struct GrVkExtensions { pub fExtensions : [u64 ; 2usize] , } # [repr (C)] # [derive (Debug)] pub struct GrVkExtensions_Info { pub fName : SkString , pub fSpecVersion : u32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct GrVkExtensions_Info_Less { pub _address : u8 , } # [test] fn bindgen_test_layout_GrVkExtensions_Info_Less () { assert_eq ! (:: core :: mem :: size_of :: < GrVkExtensions_Info_Less > () , 1usize , concat ! ("Size of: " , stringify ! (GrVkExtensions_Info_Less))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkExtensions_Info_Less > () , 1usize , concat ! ("Alignment of " , stringify ! (GrVkExtensions_Info_Less))) ; } # [test] fn bindgen_test_layout_GrVkExtensions_Info () { assert_eq ! (:: core :: mem :: size_of :: < GrVkExtensions_Info > () , 16usize , concat ! ("Size of: " , stringify ! (GrVkExtensions_Info))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkExtensions_Info > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkExtensions_Info))) ; fn test_field_fName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkExtensions_Info > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fName) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkExtensions_Info) , "::" , stringify ! (fName))) ; } test_field_fName () ; fn test_field_fSpecVersion () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkExtensions_Info > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSpecVersion) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (GrVkExtensions_Info) , "::" , stringify ! (fSpecVersion))) ; } test_field_fSpecVersion () ; } # [test] fn bindgen_test_layout_GrVkExtensions () { assert_eq ! (:: core :: mem :: size_of :: < GrVkExtensions > () , 16usize , concat ! ("Size of: " , stringify ! (GrVkExtensions))) ; assert_eq ! (:: core :: mem :: align_of :: < GrVkExtensions > () , 8usize , concat ! ("Alignment of " , stringify ! (GrVkExtensions))) ; fn test_field_fExtensions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrVkExtensions > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExtensions) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrVkExtensions) , "::" , stringify ! (fExtensions))) ; } test_field_fExtensions () ; } extern "C" { # [link_name = "\u{1}?init@GrVkExtensions@@QEAAXV?$function@$$A6AP6AXXZPEBDPEAUVkInstance_T@@PEAUVkDevice_T@@@Z@std@@PEAUVkInstance_T@@PEAUVkPhysicalDevice_T@@IPEBQEBDI3@Z"] pub fn GrVkExtensions_init (this : * mut GrVkExtensions , arg1 : GrVkGetProc , arg2 : VkInstance , arg3 : VkPhysicalDevice , instanceExtensionCount : u32 , instanceExtensions : * const * const :: std :: os :: raw :: c_char , deviceExtensionCount : u32 , deviceExtensions : * const * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?hasExtension@GrVkExtensions@@QEBA_NQEBDI@Z"] pub fn GrVkExtensions_hasExtension (this : * const GrVkExtensions , arg1 : * const :: std :: os :: raw :: c_char , minVersion : u32) -> bool ; } impl GrVkExtensions { # [inline] pub unsafe fn init (& mut self , arg1 : GrVkGetProc , arg2 : VkInstance , arg3 : VkPhysicalDevice , instanceExtensionCount : u32 , instanceExtensions : * const * const :: std :: os :: raw :: c_char , deviceExtensionCount : u32 , deviceExtensions : * const * const :: std :: os :: raw :: c_char) { GrVkExtensions_init (self , arg1 , arg2 , arg3 , instanceExtensionCount , instanceExtensions , deviceExtensionCount , deviceExtensions) } # [inline] pub unsafe fn hasExtension (& self , arg1 : * const :: std :: os :: raw :: c_char , minVersion : u32) -> bool { GrVkExtensions_hasExtension (self , arg1 , minVersion) } } extern "C" { pub fn C_GrVkTypes (arg1 : * mut GrVkSurfaceInfo) ; } extern "C" { pub fn C_GrBackendFormat_ConstructVk (uninitialized : * mut GrBackendFormat , format : VkFormat , willUseDRMFormatModifiers : bool) ; } extern "C" { pub fn C_GrBackendFormat_ConstructVk2 (uninitialized : * mut GrBackendFormat , ycbcrInfo : * const GrVkYcbcrConversionInfo , willUseDRMFormatModifiers : bool) ; } extern "C" { pub fn C_GrBackendTexture_ConstructVk (uninitialized : * mut GrBackendTexture , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo , label : * const :: std :: os :: raw :: c_char , labelCount : usize) ; } extern "C" { pub fn C_GrBackendRenderTarget_ConstructVk (uninitialized : * mut GrBackendRenderTarget , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , sampleCnt : :: std :: os :: raw :: c_int , vkInfo : * const GrVkImageInfo) ; } extern "C" { pub fn C_GrBackendDrawableInfo_getVkDrawableInfo (self_ : * const GrBackendDrawableInfo , info : * mut GrVkDrawableInfo) -> bool ; } extern "C" { pub fn C_GPU_VK_Types (arg1 : * mut GrVkExtensionFlags , arg2 : * mut GrVkFeatureFlags , arg3 : * mut VkBuffer) ; } pub type GetProcFnVoidPtr = :: core :: option :: Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , instance : VkInstance , device : VkDevice) -> * const :: core :: ffi :: c_void > ; extern "C" { pub fn C_GrVkBackendContext_New (instance : * mut :: core :: ffi :: c_void , physicalDevice : * mut :: core :: ffi :: c_void , device : * mut :: core :: ffi :: c_void , queue : * mut :: core :: ffi :: c_void , graphicsQueueIndex : u32 , getProc : GetProcFnVoidPtr , instanceExtensions : * const * const :: std :: os :: raw :: c_char , instanceExtensionCount : usize , deviceExtensions : * const * const :: std :: os :: raw :: c_char , deviceExtensionCount : usize) -> * mut :: core :: ffi :: c_void ; } extern "C" { pub fn C_GrVkBackendContext_Delete (vkBackendContext : * mut :: core :: ffi :: c_void) ; } extern "C" { pub fn C_GrVkBackendContext_setProtectedContext (self_ : * mut GrVkBackendContext , protectedContext : GrProtected) ; } extern "C" { pub fn C_GrVkBackendContext_setMaxAPIVersion (self_ : * mut GrVkBackendContext , maxAPIVersion : u32) ; } extern "C" { pub fn C_GrDirectContext_MakeVulkan (vkBackendContext : * const GrVkBackendContext , options : * const GrContextOptions) -> * mut GrDirectContext ; } extern "C" { pub fn C_GrVkAlloc_Equals (lhs : * const GrVkAlloc , rhs : * const GrVkAlloc) -> bool ; } extern "C" { pub fn C_GrVkYcbcrConversionInfo_Equals (lhs : * const GrVkYcbcrConversionInfo , rhs : * const GrVkYcbcrConversionInfo) -> bool ; } extern "C" { pub fn C_GrBackendSurfaceMutableState_ConstructVK (uninitialized : * mut GrBackendSurfaceMutableState , layout : VkImageLayout , queueFamilyIndex : u32) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct GrYUVABackendTextureInfo { pub fYUVAInfo : SkYUVAInfo , pub fPlaneFormats : [GrBackendFormat ; 4usize] , pub fMipmapped : GrMipmapped , pub fTextureOrigin : GrSurfaceOrigin , } pub const GrYUVABackendTextureInfo_kMaxPlanes : :: std :: os :: raw :: c_int = 4 ; # [test] fn bindgen_test_layout_GrYUVABackendTextureInfo () { assert_eq ! (:: core :: mem :: size_of :: < GrYUVABackendTextureInfo > () , 328usize , concat ! ("Size of: " , stringify ! (GrYUVABackendTextureInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < GrYUVABackendTextureInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (GrYUVABackendTextureInfo))) ; fn test_field_fYUVAInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYUVAInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextureInfo) , "::" , stringify ! (fYUVAInfo))) ; } test_field_fYUVAInfo () ; fn test_field_fPlaneFormats () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPlaneFormats) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextureInfo) , "::" , stringify ! (fPlaneFormats))) ; } test_field_fPlaneFormats () ; fn test_field_fMipmapped () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMipmapped) as usize - ptr as usize } , 320usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextureInfo) , "::" , stringify ! (fMipmapped))) ; } test_field_fMipmapped () ; fn test_field_fTextureOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextureInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextureOrigin) as usize - ptr as usize } , 324usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextureInfo) , "::" , stringify ! (fTextureOrigin))) ; } test_field_fTextureOrigin () ; } extern "C" { # [link_name = "\u{1}?toYUVALocations@GrYUVABackendTextureInfo@@QEBA?AV?$array@UYUVALocation@SkYUVAInfo@@$03@std@@XZ"] pub fn GrYUVABackendTextureInfo_toYUVALocations (this : * const GrYUVABackendTextureInfo) -> SkYUVAInfo_YUVALocations ; } extern "C" { # [link_name = "\u{1}??0GrYUVABackendTextureInfo@@QEAA@AEBVSkYUVAInfo@@QEBVGrBackendFormat@@W4GrMipmapped@@W4GrSurfaceOrigin@@@Z"] pub fn GrYUVABackendTextureInfo_GrYUVABackendTextureInfo (this : * mut GrYUVABackendTextureInfo , arg1 : * const SkYUVAInfo , arg2 : * const GrBackendFormat , arg3 : GrMipmapped , arg4 : GrSurfaceOrigin) ; } impl GrYUVABackendTextureInfo { # [inline] pub unsafe fn toYUVALocations (& self) -> SkYUVAInfo_YUVALocations { GrYUVABackendTextureInfo_toYUVALocations (self) } # [inline] pub unsafe fn new (arg1 : * const SkYUVAInfo , arg2 : * const GrBackendFormat , arg3 : GrMipmapped , arg4 : GrSurfaceOrigin) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrYUVABackendTextureInfo_GrYUVABackendTextureInfo (__bindgen_tmp . as_mut_ptr () , arg1 , arg2 , arg3 , arg4) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct GrYUVABackendTextures { pub fYUVAInfo : SkYUVAInfo , pub fTextures : [u64 ; 108usize] , pub fTextureOrigin : GrSurfaceOrigin , } # [test] fn bindgen_test_layout_GrYUVABackendTextures () { assert_eq ! (:: core :: mem :: size_of :: < GrYUVABackendTextures > () , 904usize , concat ! ("Size of: " , stringify ! (GrYUVABackendTextures))) ; assert_eq ! (:: core :: mem :: align_of :: < GrYUVABackendTextures > () , 8usize , concat ! ("Alignment of " , stringify ! (GrYUVABackendTextures))) ; fn test_field_fYUVAInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextures > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fYUVAInfo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextures) , "::" , stringify ! (fYUVAInfo))) ; } test_field_fYUVAInfo () ; fn test_field_fTextures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextures > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextures) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextures) , "::" , stringify ! (fTextures))) ; } test_field_fTextures () ; fn test_field_fTextureOrigin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < GrYUVABackendTextures > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextureOrigin) as usize - ptr as usize } , 896usize , concat ! ("Offset of field: " , stringify ! (GrYUVABackendTextures) , "::" , stringify ! (fTextureOrigin))) ; } test_field_fTextureOrigin () ; } extern "C" { # [link_name = "\u{1}?toYUVALocations@GrYUVABackendTextures@@QEBA?AV?$array@UYUVALocation@SkYUVAInfo@@$03@std@@XZ"] pub fn GrYUVABackendTextures_toYUVALocations (this : * const GrYUVABackendTextures) -> SkYUVAInfo_YUVALocations ; } extern "C" { # [link_name = "\u{1}??0GrYUVABackendTextures@@QEAA@AEBVSkYUVAInfo@@QEBVGrBackendTexture@@W4GrSurfaceOrigin@@@Z"] pub fn GrYUVABackendTextures_GrYUVABackendTextures (this : * mut GrYUVABackendTextures , arg1 : * const SkYUVAInfo , arg2 : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin) ; } impl GrYUVABackendTextures { # [inline] pub unsafe fn toYUVALocations (& self) -> SkYUVAInfo_YUVALocations { GrYUVABackendTextures_toYUVALocations (self) } # [inline] pub unsafe fn new (arg1 : * const SkYUVAInfo , arg2 : * const GrBackendTexture , textureOrigin : GrSurfaceOrigin) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; GrYUVABackendTextures_GrYUVABackendTextures (__bindgen_tmp . as_mut_ptr () , arg1 , arg2 , textureOrigin) ; __bindgen_tmp . assume_init () } } extern "C" { pub fn C_SkSurface_MakeFromBackendTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , sampleCnt : :: std :: os :: raw :: c_int , colorType : SkColorType , colorSpace : * mut SkColorSpace , surfaceProps : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeFromBackendRenderTarget (context : * mut GrRecordingContext , backendRenderTarget : * const GrBackendRenderTarget , origin : GrSurfaceOrigin , colorType : SkColorType , colorSpace : * mut SkColorSpace , surfaceProps : * const SkSurfaceProps) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeRenderTarget (context : * mut GrRecordingContext , budgeted : SkBudgeted , imageInfo : * const SkImageInfo , sampleCount : :: std :: os :: raw :: c_int , surfaceOrigin : GrSurfaceOrigin , surfaceProps : * const SkSurfaceProps , shouldCreateWithMips : bool) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_MakeRenderTarget2 (context : * mut GrRecordingContext , characterization : * const SkSurfaceCharacterization , budgeted : SkBudgeted) -> * mut SkSurface ; } extern "C" { pub fn C_SkSurface_getBackendTexture (self_ : * mut SkSurface , handleAccess : SkSurface_BackendHandleAccess , backendTexture : * mut GrBackendTexture) ; } extern "C" { pub fn C_SkSurface_getBackendRenderTarget (self_ : * mut SkSurface , handleAccess : SkSurface_BackendHandleAccess , backendRenderTarget : * mut GrBackendRenderTarget) ; } extern "C" { pub fn C_SkSurfaceCharacterization_createResized (self_ : * const SkSurfaceCharacterization , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , uninitialized : * mut SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkSurfaceCharacterization_createBackendFormat (self_ : * const SkSurfaceCharacterization , colorType : SkColorType , backendFormat : * const GrBackendFormat , uninitialized : * mut SkSurfaceCharacterization) ; } extern "C" { pub fn C_SkSurfaceCharacterization_imageInfo (self_ : * const SkSurfaceCharacterization) -> * const SkImageInfo ; } extern "C" { pub fn C_SkImageGenerator_isValid (self_ : * const SkImageGenerator , context : * mut GrRecordingContext) -> bool ; } extern "C" { pub fn C_GrBackendRenderTarget_Construct (uninitialized : * mut GrBackendRenderTarget) ; } extern "C" { pub fn C_GrBackendRenderTarget_CopyConstruct (uninitialized : * mut GrBackendRenderTarget , renderTarget : * const GrBackendRenderTarget) ; } extern "C" { pub fn C_GrBackendRenderTarget_destruct (self_ : * mut GrBackendRenderTarget) ; } extern "C" { pub fn C_GrBackendRenderTarget_getBackendFormat (self_ : * const GrBackendRenderTarget , uninitialized : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrBackendTexture_Construct (uninitialized : * mut GrBackendTexture) ; } extern "C" { pub fn C_GrBackendTexture_CopyConstruct (uninitialized : * mut GrBackendTexture , texture : * const GrBackendTexture) ; } extern "C" { pub fn C_GrBackendTexture_destruct (self_ : * const GrBackendTexture) ; } extern "C" { pub fn C_GrBackendTexture_getBackendFormat (self_ : * const GrBackendTexture , format : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrBackendFormat_Construct (uninitialized : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrBackendFormat_destruct (self_ : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrBackendFormat_Equals (lhs : * const GrBackendFormat , rhs : * const GrBackendFormat) -> bool ; } extern "C" { pub fn C_GrBackendFormat_makeTexture2D (self_ : * const GrBackendFormat , format : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrBackendSurfaceMutableState_Construct (uninitialized : * mut GrBackendSurfaceMutableState) ; } extern "C" { pub fn C_GrBackendSurfaceMutableState_destruct (self_ : * mut GrBackendSurfaceMutableState) ; } extern "C" { pub fn C_GrRecordingContext_asDirectContext (self_ : * mut GrRecordingContext) -> * mut GrDirectContext ; } extern "C" { pub fn C_GrRecordingContext_backend (self_ : * const GrRecordingContext) -> GrBackendApi ; } extern "C" { pub fn C_GrRecordingContext_defaultBackendFormat (self_ : * const GrRecordingContext , ct : SkColorType , renderable : GrRenderable , result : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrRecordingContext_compressedBackendFormat (self_ : * const GrRecordingContext , compressionType : SkImage_CompressionType , backendFormat : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrRecordingContext_abandoned (self_ : * mut GrRecordingContext) -> bool ; } extern "C" { pub fn C_GrRecordingContext_maxSurfaceSampleCountForColorType (self_ : * const GrRecordingContext , colorType : SkColorType) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_GrDirectContext_flushAndSubmit (self_ : * mut GrDirectContext) ; } extern "C" { pub fn C_GrDirectContext_compressedBackendFormat (self_ : * const GrDirectContext , compression : SkImage_CompressionType , result : * mut GrBackendFormat) ; } extern "C" { pub fn C_GrDirectContext_directContextId (self_ : * const GrDirectContext , r : * mut GrDirectContext_DirectContextID) ; } extern "C" { pub fn C_GrDirectContext_performDeferredCleanup (self_ : * mut GrDirectContext , msNotUsed : :: std :: os :: raw :: c_long , scratchResourcesOnly : bool) ; } extern "C" { pub fn C_GrContextOptions_Construct (uninitialized : * mut GrContextOptions) ; } extern "C" { pub fn C_GrRecordingContext_colorTypeSupportedAsSurface (self_ : * const GrRecordingContext , colorType : SkColorType) -> bool ; } extern "C" { pub fn C_GrBackendDrawableInfo_Construct (uninitialized : * mut GrBackendDrawableInfo) ; } extern "C" { pub fn C_GrBackendDrawableInfo_Construct2 (uninitialized : * mut GrBackendDrawableInfo , info : * const GrVkDrawableInfo) ; } extern "C" { pub fn C_GrBackendDrawableInfo_destruct (self_ : * mut GrBackendDrawableInfo) ; } extern "C" { pub fn C_GrBackendDrawableInfo_isValid (self_ : * const GrBackendDrawableInfo) -> bool ; } extern "C" { pub fn C_GrBackendDrawableInfo_backend (self_ : * const GrBackendDrawableInfo) -> GrBackendApi ; } extern "C" { pub fn C_GrYUVABackendTextureInfo_destruct (self_ : * mut GrYUVABackendTextureInfo) ; } extern "C" { pub fn C_GrYUVABackendTextureInfo_CopyConstruct (uninitialized : * mut GrYUVABackendTextureInfo , src : * const GrYUVABackendTextureInfo) ; } extern "C" { pub fn C_GrYUVABackendTextureInfo_equals (a : * const GrYUVABackendTextureInfo , b : * const GrYUVABackendTextureInfo) -> bool ; } extern "C" { pub fn C_GrYUVABackendTextures_destruct (self_ : * mut GrYUVABackendTextures) ; } extern "C" { pub fn C_GrYUVABackendTextures_textures (self_ : * const GrYUVABackendTextures) -> * const GrBackendTexture ; } extern "C" { pub fn C_SkCanvas_recordingContext (self_ : * mut SkCanvas) -> * mut GrRecordingContext ; } extern "C" { pub fn C_SkDrawable_snapGpuDrawHandler (self_ : * mut SkDrawable , backendApi : GrBackendApi , matrix : * const SkMatrix , clipBounds : * const SkIRect , bufferInfo : * const SkImageInfo) -> * mut SkDrawable_GpuDrawHandler ; } extern "C" { pub fn C_SkDrawable_GpuDrawHandler_delete (self_ : * mut SkDrawable_GpuDrawHandler) ; } extern "C" { pub fn C_SkDrawable_GpuDrawHandler_draw (self_ : * mut SkDrawable_GpuDrawHandler , info : * const GrBackendDrawableInfo) ; } extern "C" { pub fn C_SkImage_MakeTextureFromCompressed (context : * mut GrDirectContext , data : * mut SkData , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , type_ : SkImage_CompressionType , mipMapped : GrMipMapped , prot : GrProtected) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_getBackendTexture (self_ : * const SkImage , flushPendingGrContextIO : bool , origin : * mut GrSurfaceOrigin , result : * mut GrBackendTexture) ; } extern "C" { pub fn C_SkImage_MakeFromTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : * mut SkColorSpace) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeCrossContextFromPixmap (context : * mut GrDirectContext , pixmap : * const SkPixmap , buildMips : bool , limitToMaxTextureSize : bool) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromAdoptedTexture (context : * mut GrRecordingContext , backendTexture : * const GrBackendTexture , origin : GrSurfaceOrigin , colorType : SkColorType , alphaType : SkAlphaType , colorSpace : * mut SkColorSpace) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromYUVATextures (context : * mut GrRecordingContext , yuvaTextures : * const GrYUVABackendTextures , imageColorSpace : * mut SkColorSpace) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_MakeFromYUVAPixmaps (context : * mut GrRecordingContext , pixmaps : * const SkYUVAPixmaps , buildMips : GrMipmapped , limitToMaxTextureSize : bool , imageColorSpace : * mut SkColorSpace) -> * mut SkImage ; } extern "C" { pub fn C_SkImage_makeTextureImage (self_ : * const SkImage , context : * mut GrDirectContext , mipMapped : GrMipMapped , budgeted : SkBudgeted) -> * mut SkImage ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkUnicode { _unused : [u8 ; 0] , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper { pub _bindgen_opaque_blob : u64 , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_RunIterator { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkShaper_RunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_RunIterator > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_RunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_RunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_RunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_FontRunIterator { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkShaper_FontRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_FontRunIterator > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_FontRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_FontRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_FontRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_BiDiRunIterator { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkShaper_BiDiRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_BiDiRunIterator > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_BiDiRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_BiDiRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_BiDiRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_ScriptRunIterator { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkShaper_ScriptRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_ScriptRunIterator > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_ScriptRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_ScriptRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_ScriptRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_LanguageRunIterator { pub _bindgen_opaque_blob : u64 , } # [test] fn bindgen_test_layout_SkShaper_LanguageRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_LanguageRunIterator > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_LanguageRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_LanguageRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_LanguageRunIterator))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShaper_Feature { pub tag : SkFourByteTag , pub value : u32 , pub start : usize , pub end : usize , } # [test] fn bindgen_test_layout_SkShaper_Feature () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_Feature > () , 24usize , concat ! ("Size of: " , stringify ! (SkShaper_Feature))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_Feature > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_Feature))) ; fn test_field_tag () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_Feature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . tag) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkShaper_Feature) , "::" , stringify ! (tag))) ; } test_field_tag () ; fn test_field_value () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_Feature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . value) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (SkShaper_Feature) , "::" , stringify ! (value))) ; } test_field_value () ; fn test_field_start () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_Feature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . start) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkShaper_Feature) , "::" , stringify ! (start))) ; } test_field_start () ; fn test_field_end () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_Feature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . end) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkShaper_Feature) , "::" , stringify ! (end))) ; } test_field_end () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShaper_TrivialRunIterator < RunIteratorSubclass > { pub _base : RunIteratorSubclass , pub fEnd : usize , pub fAtEnd : bool , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < RunIteratorSubclass > > , } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_TrivialFontRunIterator { pub _bindgen_opaque_blob : [u64 ; 6usize] , } # [test] fn bindgen_test_layout_SkShaper_TrivialFontRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_TrivialFontRunIterator > () , 48usize , concat ! ("Size of: " , stringify ! (SkShaper_TrivialFontRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_TrivialFontRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_TrivialFontRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_TrivialBiDiRunIterator { pub _bindgen_opaque_blob : [u64 ; 4usize] , } # [test] fn bindgen_test_layout_SkShaper_TrivialBiDiRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_TrivialBiDiRunIterator > () , 32usize , concat ! ("Size of: " , stringify ! (SkShaper_TrivialBiDiRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_TrivialBiDiRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_TrivialBiDiRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_TrivialScriptRunIterator { pub _bindgen_opaque_blob : [u64 ; 4usize] , } # [test] fn bindgen_test_layout_SkShaper_TrivialScriptRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_TrivialScriptRunIterator > () , 32usize , concat ! ("Size of: " , stringify ! (SkShaper_TrivialScriptRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_TrivialScriptRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_TrivialScriptRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_TrivialLanguageRunIterator { pub _bindgen_opaque_blob : [u64 ; 4usize] , } # [test] fn bindgen_test_layout_SkShaper_TrivialLanguageRunIterator () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_TrivialLanguageRunIterator > () , 32usize , concat ! ("Size of: " , stringify ! (SkShaper_TrivialLanguageRunIterator))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_TrivialLanguageRunIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_TrivialLanguageRunIterator))) ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct SkShaper_RunHandler { pub _bindgen_opaque_blob : u64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShaper_RunHandler_Range { pub fBegin : usize , pub fSize : usize , } # [test] fn bindgen_test_layout_SkShaper_RunHandler_Range () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_RunHandler_Range > () , 16usize , concat ! ("Size of: " , stringify ! (SkShaper_RunHandler_Range))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_RunHandler_Range > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_RunHandler_Range))) ; fn test_field_fBegin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Range > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBegin) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Range) , "::" , stringify ! (fBegin))) ; } test_field_fBegin () ; fn test_field_fSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Range > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fSize) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Range) , "::" , stringify ! (fSize))) ; } test_field_fSize () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShaper_RunHandler_RunInfo { pub fFont : * const SkFont , pub fBidiLevel : u8 , pub fAdvance : SkVector , pub glyphCount : usize , pub utf8Range : SkShaper_RunHandler_Range , } # [test] fn bindgen_test_layout_SkShaper_RunHandler_RunInfo () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_RunHandler_RunInfo > () , 48usize , concat ! ("Size of: " , stringify ! (SkShaper_RunHandler_RunInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_RunHandler_RunInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_RunHandler_RunInfo))) ; fn test_field_fFont () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_RunInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFont) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_RunInfo) , "::" , stringify ! (fFont))) ; } test_field_fFont () ; fn test_field_fBidiLevel () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_RunInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBidiLevel) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_RunInfo) , "::" , stringify ! (fBidiLevel))) ; } test_field_fBidiLevel () ; fn test_field_fAdvance () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_RunInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAdvance) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_RunInfo) , "::" , stringify ! (fAdvance))) ; } test_field_fAdvance () ; fn test_field_glyphCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_RunInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . glyphCount) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_RunInfo) , "::" , stringify ! (glyphCount))) ; } test_field_glyphCount () ; fn test_field_utf8Range () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_RunInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . utf8Range) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_RunInfo) , "::" , stringify ! (utf8Range))) ; } test_field_utf8Range () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkShaper_RunHandler_Buffer { pub glyphs : * mut SkGlyphID , pub positions : * mut SkPoint , pub offsets : * mut SkPoint , pub clusters : * mut u32 , pub point : SkPoint , } # [test] fn bindgen_test_layout_SkShaper_RunHandler_Buffer () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_RunHandler_Buffer > () , 40usize , concat ! ("Size of: " , stringify ! (SkShaper_RunHandler_Buffer))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_RunHandler_Buffer > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_RunHandler_Buffer))) ; fn test_field_glyphs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Buffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . glyphs) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Buffer) , "::" , stringify ! (glyphs))) ; } test_field_glyphs () ; fn test_field_positions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Buffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . positions) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Buffer) , "::" , stringify ! (positions))) ; } test_field_positions () ; fn test_field_offsets () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Buffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . offsets) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Buffer) , "::" , stringify ! (offsets))) ; } test_field_offsets () ; fn test_field_clusters () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Buffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . clusters) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Buffer) , "::" , stringify ! (clusters))) ; } test_field_clusters () ; fn test_field_point () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkShaper_RunHandler_Buffer > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . point) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkShaper_RunHandler_Buffer) , "::" , stringify ! (point))) ; } test_field_point () ; } # [test] fn bindgen_test_layout_SkShaper_RunHandler () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper_RunHandler > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper_RunHandler))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper_RunHandler > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper_RunHandler))) ; } # [test] fn bindgen_test_layout_SkShaper () { assert_eq ! (:: core :: mem :: size_of :: < SkShaper > () , 8usize , concat ! ("Size of: " , stringify ! (SkShaper))) ; assert_eq ! (:: core :: mem :: align_of :: < SkShaper > () , 8usize , concat ! ("Alignment of " , stringify ! (SkShaper))) ; } extern "C" { # [link_name = "\u{1}?MakePrimitive@SkShaper@@SA?AV?$unique_ptr@VSkShaper@@U?$default_delete@VSkShaper@@@std@@@std@@XZ"] pub fn SkShaper_MakePrimitive () -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeShaperDrivenWrapper@SkShaper@@SA?AV?$unique_ptr@VSkShaper@@U?$default_delete@VSkShaper@@@std@@@std@@V?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkShaper_MakeShaperDrivenWrapper (arg1 : sk_sp < SkFontMgr >) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeShapeThenWrap@SkShaper@@SA?AV?$unique_ptr@VSkShaper@@U?$default_delete@VSkShaper@@@std@@@std@@V?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkShaper_MakeShapeThenWrap (arg1 : sk_sp < SkFontMgr >) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeShapeDontWrapOrReorder@SkShaper@@SA?AV?$unique_ptr@VSkShaper@@U?$default_delete@VSkShaper@@@std@@@std@@V?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkShaper_MakeShapeDontWrapOrReorder (arg1 : sk_sp < SkFontMgr >) -> u64 ; } extern "C" { # [link_name = "\u{1}?PurgeHarfBuzzCache@SkShaper@@SAXXZ"] pub fn SkShaper_PurgeHarfBuzzCache () ; } extern "C" { # [link_name = "\u{1}?Make@SkShaper@@SA?AV?$unique_ptr@VSkShaper@@U?$default_delete@VSkShaper@@@std@@@std@@V?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkShaper_Make (arg1 : sk_sp < SkFontMgr >) -> u64 ; } extern "C" { # [link_name = "\u{1}?PurgeCaches@SkShaper@@SAXXZ"] pub fn SkShaper_PurgeCaches () ; } extern "C" { # [link_name = "\u{1}?MakeFontMgrRunIterator@SkShaper@@SA?AV?$unique_ptr@VFontRunIterator@SkShaper@@U?$default_delete@VFontRunIterator@SkShaper@@@std@@@std@@PEBD_KAEBVSkFont@@V?$sk_sp@VSkFontMgr@@@@@Z"] pub fn SkShaper_MakeFontMgrRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , font : * const SkFont , fallback : sk_sp < SkFontMgr >) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeFontMgrRunIterator@SkShaper@@SA?AV?$unique_ptr@VFontRunIterator@SkShaper@@U?$default_delete@VFontRunIterator@SkShaper@@@std@@@std@@PEBD_KAEBVSkFont@@V?$sk_sp@VSkFontMgr@@@@0VSkFontStyle@@PEBVLanguageRunIterator@1@@Z"] pub fn SkShaper_MakeFontMgrRunIterator1 (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , font : * const SkFont , fallback : sk_sp < SkFontMgr > , requestName : * const :: std :: os :: raw :: c_char , requestStyle : SkFontStyle , arg1 : * const SkShaper_LanguageRunIterator) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeBiDiRunIterator@SkShaper@@SA?AV?$unique_ptr@VBiDiRunIterator@SkShaper@@U?$default_delete@VBiDiRunIterator@SkShaper@@@std@@@std@@PEBD_KE@Z"] pub fn SkShaper_MakeBiDiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeSkUnicodeBidiRunIterator@SkShaper@@SA?AV?$unique_ptr@VBiDiRunIterator@SkShaper@@U?$default_delete@VBiDiRunIterator@SkShaper@@@std@@@std@@PEAVSkUnicode@@PEBD_KE@Z"] pub fn SkShaper_MakeSkUnicodeBidiRunIterator (unicode : * mut SkUnicode , utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeIcuBiDiRunIterator@SkShaper@@SA?AV?$unique_ptr@VBiDiRunIterator@SkShaper@@U?$default_delete@VBiDiRunIterator@SkShaper@@@std@@@std@@PEBD_KE@Z"] pub fn SkShaper_MakeIcuBiDiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeScriptRunIterator@SkShaper@@SA?AV?$unique_ptr@VScriptRunIterator@SkShaper@@U?$default_delete@VScriptRunIterator@SkShaper@@@std@@@std@@PEBD_KI@Z"] pub fn SkShaper_MakeScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , script : SkFourByteTag) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeSkUnicodeHbScriptRunIterator@SkShaper@@SA?AV?$unique_ptr@VScriptRunIterator@SkShaper@@U?$default_delete@VScriptRunIterator@SkShaper@@@std@@@std@@PEBD_K@Z"] pub fn SkShaper_MakeSkUnicodeHbScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeSkUnicodeHbScriptRunIterator@SkShaper@@SA?AV?$unique_ptr@VScriptRunIterator@SkShaper@@U?$default_delete@VScriptRunIterator@SkShaper@@@std@@@std@@PEBD_KI@Z"] pub fn SkShaper_MakeSkUnicodeHbScriptRunIterator1 (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , script : SkFourByteTag) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeHbIcuScriptRunIterator@SkShaper@@SA?AV?$unique_ptr@VScriptRunIterator@SkShaper@@U?$default_delete@VScriptRunIterator@SkShaper@@@std@@@std@@PEBD_K@Z"] pub fn SkShaper_MakeHbIcuScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 ; } extern "C" { # [link_name = "\u{1}?MakeStdLanguageRunIterator@SkShaper@@SA?AV?$unique_ptr@VLanguageRunIterator@SkShaper@@U?$default_delete@VLanguageRunIterator@SkShaper@@@std@@@std@@PEBD_K@Z"] pub fn SkShaper_MakeStdLanguageRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 ; } extern "C" { # [link_name = "\u{1}??0SkShaper@@QEAA@XZ"] pub fn SkShaper_SkShaper (this : * mut SkShaper) ; } impl SkShaper { # [inline] pub unsafe fn MakePrimitive () -> u64 { SkShaper_MakePrimitive () } # [inline] pub unsafe fn MakeShaperDrivenWrapper (arg1 : sk_sp < SkFontMgr >) -> u64 { SkShaper_MakeShaperDrivenWrapper (arg1) } # [inline] pub unsafe fn MakeShapeThenWrap (arg1 : sk_sp < SkFontMgr >) -> u64 { SkShaper_MakeShapeThenWrap (arg1) } # [inline] pub unsafe fn MakeShapeDontWrapOrReorder (arg1 : sk_sp < SkFontMgr >) -> u64 { SkShaper_MakeShapeDontWrapOrReorder (arg1) } # [inline] pub unsafe fn PurgeHarfBuzzCache () { SkShaper_PurgeHarfBuzzCache () } # [inline] pub unsafe fn Make (arg1 : sk_sp < SkFontMgr >) -> u64 { SkShaper_Make (arg1) } # [inline] pub unsafe fn PurgeCaches () { SkShaper_PurgeCaches () } # [inline] pub unsafe fn MakeFontMgrRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , font : * const SkFont , fallback : sk_sp < SkFontMgr >) -> u64 { SkShaper_MakeFontMgrRunIterator (utf8 , utf8Bytes , font , fallback) } # [inline] pub unsafe fn MakeFontMgrRunIterator1 (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , font : * const SkFont , fallback : sk_sp < SkFontMgr > , requestName : * const :: std :: os :: raw :: c_char , requestStyle : SkFontStyle , arg1 : * const SkShaper_LanguageRunIterator) -> u64 { SkShaper_MakeFontMgrRunIterator1 (utf8 , utf8Bytes , font , fallback , requestName , requestStyle , arg1) } # [inline] pub unsafe fn MakeBiDiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 { SkShaper_MakeBiDiRunIterator (utf8 , utf8Bytes , bidiLevel) } # [inline] pub unsafe fn MakeSkUnicodeBidiRunIterator (unicode : * mut SkUnicode , utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 { SkShaper_MakeSkUnicodeBidiRunIterator (unicode , utf8 , utf8Bytes , bidiLevel) } # [inline] pub unsafe fn MakeIcuBiDiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> u64 { SkShaper_MakeIcuBiDiRunIterator (utf8 , utf8Bytes , bidiLevel) } # [inline] pub unsafe fn MakeScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , script : SkFourByteTag) -> u64 { SkShaper_MakeScriptRunIterator (utf8 , utf8Bytes , script) } # [inline] pub unsafe fn MakeSkUnicodeHbScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 { SkShaper_MakeSkUnicodeHbScriptRunIterator (utf8 , utf8Bytes) } # [inline] pub unsafe fn MakeSkUnicodeHbScriptRunIterator1 (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , script : SkFourByteTag) -> u64 { SkShaper_MakeSkUnicodeHbScriptRunIterator1 (utf8 , utf8Bytes , script) } # [inline] pub unsafe fn MakeHbIcuScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 { SkShaper_MakeHbIcuScriptRunIterator (utf8 , utf8Bytes) } # [inline] pub unsafe fn MakeStdLanguageRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> u64 { SkShaper_MakeStdLanguageRunIterator (utf8 , utf8Bytes) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkShaper_SkShaper (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug)] pub struct SkTextBlobBuilderRunHandler { pub _base : SkShaper_RunHandler , pub fBuilder : SkTextBlobBuilder , pub fUtf8Text : * const :: std :: os :: raw :: c_char , pub fClusters : * mut u32 , pub fClusterOffset : :: std :: os :: raw :: c_int , pub fGlyphCount : :: std :: os :: raw :: c_int , pub fMaxRunAscent : SkScalar , pub fMaxRunDescent : SkScalar , pub fMaxRunLeading : SkScalar , pub fCurrentPosition : SkPoint , pub fOffset : SkPoint , } # [test] fn bindgen_test_layout_SkTextBlobBuilderRunHandler () { assert_eq ! (:: core :: mem :: size_of :: < SkTextBlobBuilderRunHandler > () , 152usize , concat ! ("Size of: " , stringify ! (SkTextBlobBuilderRunHandler))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTextBlobBuilderRunHandler > () , 8usize , concat ! ("Alignment of " , stringify ! (SkTextBlobBuilderRunHandler))) ; fn test_field_fBuilder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBuilder) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fBuilder))) ; } test_field_fBuilder () ; fn test_field_fUtf8Text () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUtf8Text) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fUtf8Text))) ; } test_field_fUtf8Text () ; fn test_field_fClusters () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fClusters) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fClusters))) ; } test_field_fClusters () ; fn test_field_fClusterOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fClusterOffset) as usize - ptr as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fClusterOffset))) ; } test_field_fClusterOffset () ; fn test_field_fGlyphCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fGlyphCount) as usize - ptr as usize } , 116usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fGlyphCount))) ; } test_field_fGlyphCount () ; fn test_field_fMaxRunAscent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxRunAscent) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fMaxRunAscent))) ; } test_field_fMaxRunAscent () ; fn test_field_fMaxRunDescent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxRunDescent) as usize - ptr as usize } , 124usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fMaxRunDescent))) ; } test_field_fMaxRunDescent () ; fn test_field_fMaxRunLeading () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxRunLeading) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fMaxRunLeading))) ; } test_field_fMaxRunLeading () ; fn test_field_fCurrentPosition () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCurrentPosition) as usize - ptr as usize } , 132usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fCurrentPosition))) ; } test_field_fCurrentPosition () ; fn test_field_fOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkTextBlobBuilderRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOffset) as usize - ptr as usize } , 140usize , concat ! ("Offset of field: " , stringify ! (SkTextBlobBuilderRunHandler) , "::" , stringify ! (fOffset))) ; } test_field_fOffset () ; } extern "C" { # [link_name = "\u{1}?makeBlob@SkTextBlobBuilderRunHandler@@QEAA?AV?$sk_sp@VSkTextBlob@@@@XZ"] pub fn SkTextBlobBuilderRunHandler_makeBlob (this : * mut SkTextBlobBuilderRunHandler) -> sk_sp < SkTextBlob > ; } impl SkTextBlobBuilderRunHandler { # [inline] pub unsafe fn makeBlob (& mut self) -> sk_sp < SkTextBlob > { SkTextBlobBuilderRunHandler_makeBlob (self) } } extern "C" { # [link_name = "\u{1}?beginLine@SkTextBlobBuilderRunHandler@@UEAAXXZ"] pub fn SkTextBlobBuilderRunHandler_beginLine (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?runInfo@SkTextBlobBuilderRunHandler@@UEAAXAEBURunInfo@RunHandler@SkShaper@@@Z"] pub fn SkTextBlobBuilderRunHandler_runInfo (this : * mut :: core :: ffi :: c_void , arg1 : * const SkShaper_RunHandler_RunInfo) ; } extern "C" { # [link_name = "\u{1}?commitRunInfo@SkTextBlobBuilderRunHandler@@UEAAXXZ"] pub fn SkTextBlobBuilderRunHandler_commitRunInfo (this : * mut :: core :: ffi :: c_void) ; } extern "C" { # [link_name = "\u{1}?runBuffer@SkTextBlobBuilderRunHandler@@UEAA?AUBuffer@RunHandler@SkShaper@@AEBURunInfo@34@@Z"] pub fn SkTextBlobBuilderRunHandler_runBuffer (this : * mut :: core :: ffi :: c_void , arg1 : * const SkShaper_RunHandler_RunInfo) -> SkShaper_RunHandler_Buffer ; } extern "C" { # [link_name = "\u{1}?commitRunBuffer@SkTextBlobBuilderRunHandler@@UEAAXAEBURunInfo@RunHandler@SkShaper@@@Z"] pub fn SkTextBlobBuilderRunHandler_commitRunBuffer (this : * mut :: core :: ffi :: c_void , arg1 : * const SkShaper_RunHandler_RunInfo) ; } extern "C" { # [link_name = "\u{1}?commitLine@SkTextBlobBuilderRunHandler@@UEAAXXZ"] pub fn SkTextBlobBuilderRunHandler_commitLine (this : * mut :: core :: ffi :: c_void) ; } extern "C" { pub fn C_SetICU (arg1 : * const :: core :: ffi :: c_void) ; } extern "C" { pub fn C_SkShaper_MakePrimitive () -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_MakeShaperDrivenWrapper (fontMgr : * mut SkFontMgr) -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_MakeShapeThenWrap (fontMgr : * mut SkFontMgr) -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_MakeShapeDontWrapOrReorder (fontMgr : * mut SkFontMgr) -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_MakeCoreText () -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_Make (fontMgr : * mut SkFontMgr) -> * mut SkShaper ; } extern "C" { pub fn C_SkShaper_delete (self_ : * mut SkShaper) ; } extern "C" { pub fn C_SkShaper_RunIterator_delete (self_ : * mut SkShaper_RunIterator) ; } extern "C" { pub fn C_SkShaper_RunIterator_consume (self_ : * mut SkShaper_RunIterator) ; } extern "C" { pub fn C_SkShaper_RunIterator_endOfCurrentRun (self_ : * const SkShaper_RunIterator) -> usize ; } extern "C" { pub fn C_SkShaper_RunIterator_atEnd (self_ : * const SkShaper_RunIterator) -> bool ; } extern "C" { pub fn C_SkShaper_FontRunIterator_currentFont (self_ : * const SkShaper_FontRunIterator) -> * const SkFont ; } extern "C" { pub fn C_SkShaper_MakeFontMgrRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , font : * const SkFont , fallback : * mut SkFontMgr) -> * mut SkShaper_FontRunIterator ; } extern "C" { pub fn C_SkShaper_TrivialFontRunIterator_new (font : * const SkFont , utf8Bytes : usize) -> * mut SkShaper_FontRunIterator ; } extern "C" { pub fn C_SkShaper_BiDiRunIterator_currentLevel (self_ : * const SkShaper_BiDiRunIterator) -> u8 ; } extern "C" { pub fn C_SkShaper_MakeBidiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> * mut SkShaper_BiDiRunIterator ; } extern "C" { pub fn C_SkShaper_MakeIcuBidiRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , bidiLevel : u8) -> * mut SkShaper_BiDiRunIterator ; } extern "C" { pub fn C_SkShaper_TrivialBidiRunIterator_new (bidiLevel : u8 , utf8Bytes : usize) -> * mut SkShaper_BiDiRunIterator ; } extern "C" { pub fn C_SkShaper_ScriptRunIterator_currentScript (self_ : * const SkShaper_ScriptRunIterator) -> SkFourByteTag ; } extern "C" { pub fn C_SkShaper_MakeScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , script : SkFourByteTag) -> * mut SkShaper_ScriptRunIterator ; } extern "C" { pub fn C_SkShaper_MakeHbIcuScriptRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> * mut SkShaper_ScriptRunIterator ; } extern "C" { pub fn C_SkShaper_TrivialScriptRunIterator_new (bidiLevel : u8 , utf8Bytes : usize) -> * mut SkShaper_ScriptRunIterator ; } extern "C" { pub fn C_SkShaper_LanguageRunIterator_currentLanguage (self_ : * const SkShaper_LanguageRunIterator) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn C_SkShaper_MakeStdLanguageRunIterator (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> * mut SkShaper_LanguageRunIterator ; } extern "C" { pub fn C_SkShaper_TrivialLanguageRunIterator_new (utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize) -> * mut SkShaper_LanguageRunIterator ; } extern "C" { pub fn C_SkShaper_RunHandler_delete (self_ : * mut SkShaper_RunHandler) ; } pub type RunHandler_BeginLine = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject) > ; pub type RunHandler_RunInfo = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject , arg2 : * const SkShaper_RunHandler_RunInfo) > ; pub type RunHandler_CommitRunInfo = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject) > ; pub type RunHandler_RunBuffer = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject , arg2 : * const SkShaper_RunHandler_RunInfo) -> SkShaper_RunHandler_Buffer > ; pub type RunHandler_CommitRunBuffer = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject , arg2 : * const SkShaper_RunHandler_RunInfo) > ; pub type RunHandler_CommitLine = :: core :: option :: Option < unsafe extern "C" fn (arg1 : TraitObject) > ; # [repr (C)] # [derive (Debug)] pub struct RustRunHandler { pub _base : SkShaper_RunHandler , pub _param : RustRunHandler_Param , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct RustRunHandler_Param { pub trait_ : TraitObject , pub beginLine : RunHandler_BeginLine , pub runInfo : RunHandler_RunInfo , pub commitRunInfo : RunHandler_CommitRunInfo , pub runBuffer : RunHandler_RunBuffer , pub commitRunBuffer : RunHandler_CommitRunBuffer , pub commitLine : RunHandler_CommitLine , } # [test] fn bindgen_test_layout_RustRunHandler_Param () { assert_eq ! (:: core :: mem :: size_of :: < RustRunHandler_Param > () , 64usize , concat ! ("Size of: " , stringify ! (RustRunHandler_Param))) ; assert_eq ! (:: core :: mem :: align_of :: < RustRunHandler_Param > () , 8usize , concat ! ("Alignment of " , stringify ! (RustRunHandler_Param))) ; fn test_field_trait () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . trait_) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (trait_))) ; } test_field_trait () ; fn test_field_beginLine () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . beginLine) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (beginLine))) ; } test_field_beginLine () ; fn test_field_runInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . runInfo) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (runInfo))) ; } test_field_runInfo () ; fn test_field_commitRunInfo () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . commitRunInfo) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (commitRunInfo))) ; } test_field_commitRunInfo () ; fn test_field_runBuffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . runBuffer) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (runBuffer))) ; } test_field_runBuffer () ; fn test_field_commitRunBuffer () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . commitRunBuffer) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (commitRunBuffer))) ; } test_field_commitRunBuffer () ; fn test_field_commitLine () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler_Param > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . commitLine) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler_Param) , "::" , stringify ! (commitLine))) ; } test_field_commitLine () ; } # [test] fn bindgen_test_layout_RustRunHandler () { assert_eq ! (:: core :: mem :: size_of :: < RustRunHandler > () , 72usize , concat ! ("Size of: " , stringify ! (RustRunHandler))) ; assert_eq ! (:: core :: mem :: align_of :: < RustRunHandler > () , 8usize , concat ! ("Alignment of " , stringify ! (RustRunHandler))) ; fn test_field__param () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < RustRunHandler > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . _param) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (RustRunHandler) , "::" , stringify ! (_param))) ; } test_field__param () ; } extern "C" { pub fn C_RustRunHandler_construct (uninitialized : * mut RustRunHandler , param : * const RustRunHandler_Param) ; } extern "C" { pub fn C_SkShaper_shape (self_ : * const SkShaper , utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , srcFont : * const SkFont , leftToRight : bool , width : SkScalar , runHandler : * mut SkShaper_RunHandler) ; } extern "C" { pub fn C_SkShaper_shape2 (self_ : * const SkShaper , utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , fontRunIterator : * mut SkShaper_FontRunIterator , bidiRunIterator : * mut SkShaper_BiDiRunIterator , scriptRunIterator : * mut SkShaper_ScriptRunIterator , languageRunIterator : * mut SkShaper_LanguageRunIterator , width : SkScalar , runHandler : * mut SkShaper_RunHandler) ; } extern "C" { pub fn C_SkShaper_shape3 (self_ : * const SkShaper , utf8 : * const :: std :: os :: raw :: c_char , utf8Bytes : usize , fontRunIterator : * mut SkShaper_FontRunIterator , bidiRunIterator : * mut SkShaper_BiDiRunIterator , scriptRunIterator : * mut SkShaper_ScriptRunIterator , languageRunIterator : * mut SkShaper_LanguageRunIterator , features : * const SkShaper_Feature , featuresSize : usize , width : SkScalar , runHandler : * mut SkShaper_RunHandler) ; } extern "C" { pub fn C_SkTextBlobBuilderRunHandler_construct (uninitialized : * mut SkTextBlobBuilderRunHandler , utf8Text : * const :: std :: os :: raw :: c_char , offset : * const SkPoint) ; } extern "C" { pub fn C_SkTextBlobBuilderRunHandler_makeBlob (self_ : * mut SkTextBlobBuilderRunHandler) -> * mut SkTextBlob ; } extern "C" { pub fn C_SkTextBlobBuilderRunHandler_endPoint (self_ : * mut SkTextBlobBuilderRunHandler) -> SkPoint ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_Affinity { Upstream = 0 , Downstream = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_RectHeightStyle { Tight = 0 , Max = 1 , IncludeLineSpacingMiddle = 2 , IncludeLineSpacingTop = 3 , IncludeLineSpacingBottom = 4 , Strut = 5 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_RectWidthStyle { Tight = 0 , Max = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextAlign { Left = 0 , Right = 1 , Center = 2 , Justify = 3 , Start = 4 , End = 5 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextDirection { RTL = 0 , LTR = 1 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_PositionWithAffinity { pub position : i32 , pub affinity : skia_textlayout_Affinity , } # [test] fn bindgen_test_layout_skia_textlayout_PositionWithAffinity () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_PositionWithAffinity > () , 8usize , concat ! ("Size of: " , stringify ! (skia_textlayout_PositionWithAffinity))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_PositionWithAffinity > () , 4usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_PositionWithAffinity))) ; fn test_field_position () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PositionWithAffinity > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . position) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PositionWithAffinity) , "::" , stringify ! (position))) ; } test_field_position () ; fn test_field_affinity () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PositionWithAffinity > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . affinity) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PositionWithAffinity) , "::" , stringify ! (affinity))) ; } test_field_affinity () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_TextBox { pub rect : SkRect , pub direction : skia_textlayout_TextDirection , } # [test] fn bindgen_test_layout_skia_textlayout_TextBox () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_TextBox > () , 20usize , concat ! ("Size of: " , stringify ! (skia_textlayout_TextBox))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_TextBox > () , 4usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_TextBox))) ; fn test_field_rect () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextBox > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . rect) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextBox) , "::" , stringify ! (rect))) ; } test_field_rect () ; fn test_field_direction () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextBox > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . direction) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextBox) , "::" , stringify ! (direction))) ; } test_field_direction () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_SkRange < T > { pub start : T , pub end : T , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } pub type skia_textlayout_SkRange_SignedT = std_make_signed_t ; # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextBaseline { Alphabetic = 0 , Ideographic = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextHeightBehavior { All = 0 , DisableFirstAscent = 1 , DisableLastDescent = 2 , DisableAll = 3 , } # [repr (C)] pub struct skia_textlayout_FontArguments { pub fCollectionIndex : :: std :: os :: raw :: c_int , pub fCoordinates : [u64 ; 3usize] , pub fPaletteIndex : :: std :: os :: raw :: c_int , pub fPaletteOverrides : [u64 ; 3usize] , } # [test] fn bindgen_test_layout_skia_textlayout_FontArguments () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_FontArguments > () , 64usize , concat ! ("Size of: " , stringify ! (skia_textlayout_FontArguments))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_FontArguments > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_FontArguments))) ; fn test_field_fCollectionIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCollectionIndex) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontArguments) , "::" , stringify ! (fCollectionIndex))) ; } test_field_fCollectionIndex () ; fn test_field_fCoordinates () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCoordinates) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontArguments) , "::" , stringify ! (fCoordinates))) ; } test_field_fCoordinates () ; fn test_field_fPaletteIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaletteIndex) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontArguments) , "::" , stringify ! (fPaletteIndex))) ; } test_field_fPaletteIndex () ; fn test_field_fPaletteOverrides () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontArguments > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaletteOverrides) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontArguments) , "::" , stringify ! (fPaletteOverrides))) ; } test_field_fPaletteOverrides () ; } extern "C" { # [link_name = "\u{1}?CloneTypeface@FontArguments@textlayout@skia@@QEBA?AV?$sk_sp@VSkTypeface@@@@V4@@Z"] pub fn skia_textlayout_FontArguments_CloneTypeface (this : * const skia_textlayout_FontArguments , typeface : sk_sp < SkTypeface >) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}??0FontArguments@textlayout@skia@@QEAA@AEBUSkFontArguments@@@Z"] pub fn skia_textlayout_FontArguments_FontArguments (this : * mut skia_textlayout_FontArguments , arg1 : * const SkFontArguments) ; } impl skia_textlayout_FontArguments { # [inline] pub unsafe fn CloneTypeface (& self , typeface : sk_sp < SkTypeface >) -> sk_sp < SkTypeface > { skia_textlayout_FontArguments_CloneTypeface (self , typeface) } # [inline] pub unsafe fn new (arg1 : * const SkFontArguments) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_FontArguments_FontArguments (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_ParagraphImpl { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_ParagraphCacheKey { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_ParagraphCacheValue { _unused : [u8 ; 0] , } # [repr (C)] pub struct skia_textlayout_ParagraphCache { pub fParagraphMutex : SkMutex , pub fChecker : [u64 ; 8usize] , pub fLRUCacheMap : [u64 ; 5usize] , pub fCacheIsOn : bool , pub fLastCachedValue : * mut skia_textlayout_ParagraphCacheValue , pub fTotalRequests : :: std :: os :: raw :: c_int , pub fCacheMisses : :: std :: os :: raw :: c_int , pub fHashMisses : :: std :: os :: raw :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_ParagraphCache_Entry { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_ParagraphCache_KeyHash { pub _address : u8 , } # [test] fn bindgen_test_layout_skia_textlayout_ParagraphCache_KeyHash () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_ParagraphCache_KeyHash > () , 1usize , concat ! ("Size of: " , stringify ! (skia_textlayout_ParagraphCache_KeyHash))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_ParagraphCache_KeyHash > () , 1usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_ParagraphCache_KeyHash))) ; } pub const skia_textlayout_ParagraphCache_kMaxEntries : :: std :: os :: raw :: c_int = 128 ; # [test] fn bindgen_test_layout_skia_textlayout_ParagraphCache () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_ParagraphCache > () , 152usize , concat ! ("Size of: " , stringify ! (skia_textlayout_ParagraphCache))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_ParagraphCache > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_ParagraphCache))) ; fn test_field_fParagraphMutex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fParagraphMutex) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fParagraphMutex))) ; } test_field_fParagraphMutex () ; fn test_field_fChecker () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fChecker) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fChecker))) ; } test_field_fChecker () ; fn test_field_fLRUCacheMap () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLRUCacheMap) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fLRUCacheMap))) ; } test_field_fLRUCacheMap () ; fn test_field_fCacheIsOn () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCacheIsOn) as usize - ptr as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fCacheIsOn))) ; } test_field_fCacheIsOn () ; fn test_field_fLastCachedValue () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLastCachedValue) as usize - ptr as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fLastCachedValue))) ; } test_field_fLastCachedValue () ; fn test_field_fTotalRequests () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTotalRequests) as usize - ptr as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fTotalRequests))) ; } test_field_fTotalRequests () ; fn test_field_fCacheMisses () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCacheMisses) as usize - ptr as usize } , 140usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fCacheMisses))) ; } test_field_fCacheMisses () ; fn test_field_fHashMisses () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphCache > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHashMisses) as usize - ptr as usize } , 144usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphCache) , "::" , stringify ! (fHashMisses))) ; } test_field_fHashMisses () ; } extern "C" { # [link_name = "\u{1}?abandon@ParagraphCache@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_ParagraphCache_abandon (this : * mut skia_textlayout_ParagraphCache) ; } extern "C" { # [link_name = "\u{1}?reset@ParagraphCache@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_ParagraphCache_reset (this : * mut skia_textlayout_ParagraphCache) ; } extern "C" { # [link_name = "\u{1}?updateParagraph@ParagraphCache@textlayout@skia@@QEAA_NPEAVParagraphImpl@23@@Z"] pub fn skia_textlayout_ParagraphCache_updateParagraph (this : * mut skia_textlayout_ParagraphCache , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool ; } extern "C" { # [link_name = "\u{1}?findParagraph@ParagraphCache@textlayout@skia@@QEAA_NPEAVParagraphImpl@23@@Z"] pub fn skia_textlayout_ParagraphCache_findParagraph (this : * mut skia_textlayout_ParagraphCache , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool ; } extern "C" { # [link_name = "\u{1}?printStatistics@ParagraphCache@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_ParagraphCache_printStatistics (this : * mut skia_textlayout_ParagraphCache) ; } extern "C" { # [link_name = "\u{1}?isPossiblyTextEditing@ParagraphCache@textlayout@skia@@QEAA_NPEAVParagraphImpl@23@@Z"] pub fn skia_textlayout_ParagraphCache_isPossiblyTextEditing (this : * mut skia_textlayout_ParagraphCache , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool ; } extern "C" { # [link_name = "\u{1}??0ParagraphCache@textlayout@skia@@QEAA@XZ"] pub fn skia_textlayout_ParagraphCache_ParagraphCache (this : * mut skia_textlayout_ParagraphCache) ; } impl skia_textlayout_ParagraphCache { # [inline] pub unsafe fn abandon (& mut self) { skia_textlayout_ParagraphCache_abandon (self) } # [inline] pub unsafe fn reset (& mut self) { skia_textlayout_ParagraphCache_reset (self) } # [inline] pub unsafe fn updateParagraph (& mut self , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool { skia_textlayout_ParagraphCache_updateParagraph (self , paragraph) } # [inline] pub unsafe fn findParagraph (& mut self , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool { skia_textlayout_ParagraphCache_findParagraph (self , paragraph) } # [inline] pub unsafe fn printStatistics (& mut self) { skia_textlayout_ParagraphCache_printStatistics (self) } # [inline] pub unsafe fn isPossiblyTextEditing (& mut self , paragraph : * mut skia_textlayout_ParagraphImpl) -> bool { skia_textlayout_ParagraphCache_isPossiblyTextEditing (self , paragraph) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_ParagraphCache_ParagraphCache (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_TextShadow { pub fColor : SkColor , pub fOffset : SkPoint , pub fBlurSigma : f64 , } # [test] fn bindgen_test_layout_skia_textlayout_TextShadow () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_TextShadow > () , 24usize , concat ! ("Size of: " , stringify ! (skia_textlayout_TextShadow))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_TextShadow > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_TextShadow))) ; fn test_field_fColor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextShadow > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColor) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextShadow) , "::" , stringify ! (fColor))) ; } test_field_fColor () ; fn test_field_fOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextShadow > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fOffset) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextShadow) , "::" , stringify ! (fOffset))) ; } test_field_fOffset () ; fn test_field_fBlurSigma () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextShadow > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBlurSigma) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextShadow) , "::" , stringify ! (fBlurSigma))) ; } test_field_fBlurSigma () ; } extern "C" { # [link_name = "\u{1}?hasShadow@TextShadow@textlayout@skia@@QEBA_NXZ"] pub fn skia_textlayout_TextShadow_hasShadow (this : * const skia_textlayout_TextShadow) -> bool ; } extern "C" { # [link_name = "\u{1}??0TextShadow@textlayout@skia@@QEAA@XZ"] pub fn skia_textlayout_TextShadow_TextShadow (this : * mut skia_textlayout_TextShadow) ; } extern "C" { # [link_name = "\u{1}??0TextShadow@textlayout@skia@@QEAA@IUSkPoint@@N@Z"] pub fn skia_textlayout_TextShadow_TextShadow1 (this : * mut skia_textlayout_TextShadow , color : SkColor , offset : SkPoint , blurSigma : f64) ; } impl skia_textlayout_TextShadow { # [inline] pub unsafe fn hasShadow (& self) -> bool { skia_textlayout_TextShadow_hasShadow (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_TextShadow_TextShadow (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new1 (color : SkColor , offset : SkPoint , blurSigma : f64) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_TextShadow_TextShadow1 (__bindgen_tmp . as_mut_ptr () , color , offset , blurSigma) ; __bindgen_tmp . assume_init () } } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextDecoration { kNoDecoration = 0 , kUnderline = 1 , kOverline = 2 , kLineThrough = 4 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextDecorationStyle { Solid = 0 , Double = 1 , Dotted = 2 , Dashed = 3 , Wavy = 4 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_TextDecorationMode { Gaps = 0 , Through = 1 , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_StyleType { None = 0 , AllAttributes = 1 , Font = 2 , Foreground = 3 , Background = 4 , Shadow = 5 , Decorations = 6 , LetterSpacing = 7 , WordSpacing = 8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_Decoration { pub fType : skia_textlayout_TextDecoration , pub fMode : skia_textlayout_TextDecorationMode , pub fColor : SkColor , pub fStyle : skia_textlayout_TextDecorationStyle , pub fThicknessMultiplier : SkScalar , } # [test] fn bindgen_test_layout_skia_textlayout_Decoration () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_Decoration > () , 20usize , concat ! ("Size of: " , stringify ! (skia_textlayout_Decoration))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_Decoration > () , 4usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_Decoration))) ; fn test_field_fType () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Decoration > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fType) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Decoration) , "::" , stringify ! (fType))) ; } test_field_fType () ; fn test_field_fMode () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Decoration > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMode) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Decoration) , "::" , stringify ! (fMode))) ; } test_field_fMode () ; fn test_field_fColor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Decoration > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColor) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Decoration) , "::" , stringify ! (fColor))) ; } test_field_fColor () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Decoration > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Decoration) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; fn test_field_fThicknessMultiplier () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Decoration > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fThicknessMultiplier) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Decoration) , "::" , stringify ! (fThicknessMultiplier))) ; } test_field_fThicknessMultiplier () ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum skia_textlayout_PlaceholderAlignment { Baseline = 0 , AboveBaseline = 1 , BelowBaseline = 2 , Top = 3 , Bottom = 4 , Middle = 5 , } # [repr (C)] # [derive (Debug)] pub struct skia_textlayout_FontFeature { pub fName : SkString , pub fValue : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_skia_textlayout_FontFeature () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_FontFeature > () , 16usize , concat ! ("Size of: " , stringify ! (skia_textlayout_FontFeature))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_FontFeature > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_FontFeature))) ; fn test_field_fName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontFeature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fName) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontFeature) , "::" , stringify ! (fName))) ; } test_field_fName () ; fn test_field_fValue () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontFeature > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fValue) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontFeature) , "::" , stringify ! (fValue))) ; } test_field_fValue () ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_PlaceholderStyle { pub fWidth : SkScalar , pub fHeight : SkScalar , pub fAlignment : skia_textlayout_PlaceholderAlignment , pub fBaseline : skia_textlayout_TextBaseline , pub fBaselineOffset : SkScalar , } # [test] fn bindgen_test_layout_skia_textlayout_PlaceholderStyle () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_PlaceholderStyle > () , 20usize , concat ! ("Size of: " , stringify ! (skia_textlayout_PlaceholderStyle))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_PlaceholderStyle > () , 4usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_PlaceholderStyle))) ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PlaceholderStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PlaceholderStyle) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PlaceholderStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PlaceholderStyle) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fAlignment () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PlaceholderStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlignment) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PlaceholderStyle) , "::" , stringify ! (fAlignment))) ; } test_field_fAlignment () ; fn test_field_fBaseline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PlaceholderStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBaseline) as usize - ptr as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PlaceholderStyle) , "::" , stringify ! (fBaseline))) ; } test_field_fBaseline () ; fn test_field_fBaselineOffset () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_PlaceholderStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBaselineOffset) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_PlaceholderStyle) , "::" , stringify ! (fBaselineOffset))) ; } test_field_fBaselineOffset () ; } extern "C" { # [link_name = "\u{1}?equals@PlaceholderStyle@textlayout@skia@@QEBA_NAEBU123@@Z"] pub fn skia_textlayout_PlaceholderStyle_equals (this : * const skia_textlayout_PlaceholderStyle , arg1 : * const skia_textlayout_PlaceholderStyle) -> bool ; } impl skia_textlayout_PlaceholderStyle { # [inline] pub unsafe fn equals (& self , arg1 : * const skia_textlayout_PlaceholderStyle) -> bool { skia_textlayout_PlaceholderStyle_equals (self , arg1) } } # [repr (C)] pub struct skia_textlayout_TextStyle { pub fDecoration : skia_textlayout_Decoration , pub fFontStyle : SkFontStyle , pub fFontFamilies : [u64 ; 3usize] , pub fFontSize : SkScalar , pub fHeight : SkScalar , pub fHeightOverride : bool , pub fBaselineShift : SkScalar , pub fHalfLeading : bool , pub fLocale : SkString , pub fLetterSpacing : SkScalar , pub fWordSpacing : SkScalar , pub fTextBaseline : skia_textlayout_TextBaseline , pub fColor : SkColor , pub fHasBackground : bool , pub fBackground : SkPaint , pub fHasForeground : bool , pub fForeground : SkPaint , pub fTextShadows : [u64 ; 3usize] , pub fTypeface : sk_sp < SkTypeface > , pub fIsPlaceholder : bool , pub fFontFeatures : [u64 ; 3usize] , pub fFontArguments : [u64 ; 9usize] , } extern "C" { # [link_name = "\u{1}?kDefaultFontFamilies@TextStyle@textlayout@skia@@0PEBV?$vector@VSkString@@V?$allocator@VSkString@@@std@@@std@@EB"] pub static mut skia_textlayout_TextStyle_kDefaultFontFamilies : * const [u64 ; 3usize] ; } # [test] fn bindgen_test_layout_skia_textlayout_TextStyle () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_TextStyle > () , 408usize , concat ! ("Size of: " , stringify ! (skia_textlayout_TextStyle))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_TextStyle > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_TextStyle))) ; fn test_field_fDecoration () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDecoration) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fDecoration))) ; } test_field_fDecoration () ; fn test_field_fFontStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontStyle) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fFontStyle))) ; } test_field_fFontStyle () ; fn test_field_fFontFamilies () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontFamilies) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fFontFamilies))) ; } test_field_fFontFamilies () ; fn test_field_fFontSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontSize) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fFontSize))) ; } test_field_fFontSize () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fHeightOverride () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeightOverride) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fHeightOverride))) ; } test_field_fHeightOverride () ; fn test_field_fBaselineShift () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBaselineShift) as usize - ptr as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fBaselineShift))) ; } test_field_fBaselineShift () ; fn test_field_fHalfLeading () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHalfLeading) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fHalfLeading))) ; } test_field_fHalfLeading () ; fn test_field_fLocale () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLocale) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fLocale))) ; } test_field_fLocale () ; fn test_field_fLetterSpacing () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLetterSpacing) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fLetterSpacing))) ; } test_field_fLetterSpacing () ; fn test_field_fWordSpacing () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWordSpacing) as usize - ptr as usize } , 84usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fWordSpacing))) ; } test_field_fWordSpacing () ; fn test_field_fTextBaseline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextBaseline) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fTextBaseline))) ; } test_field_fTextBaseline () ; fn test_field_fColor () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fColor) as usize - ptr as usize } , 92usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fColor))) ; } test_field_fColor () ; fn test_field_fHasBackground () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHasBackground) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fHasBackground))) ; } test_field_fHasBackground () ; fn test_field_fBackground () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBackground) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fBackground))) ; } test_field_fBackground () ; fn test_field_fHasForeground () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHasForeground) as usize - ptr as usize } , 184usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fHasForeground))) ; } test_field_fHasForeground () ; fn test_field_fForeground () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fForeground) as usize - ptr as usize } , 192usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fForeground))) ; } test_field_fForeground () ; fn test_field_fTextShadows () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextShadows) as usize - ptr as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fTextShadows))) ; } test_field_fTextShadows () ; fn test_field_fTypeface () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTypeface) as usize - ptr as usize } , 296usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fTypeface))) ; } test_field_fTypeface () ; fn test_field_fIsPlaceholder () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIsPlaceholder) as usize - ptr as usize } , 304usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fIsPlaceholder))) ; } test_field_fIsPlaceholder () ; fn test_field_fFontFeatures () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontFeatures) as usize - ptr as usize } , 312usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fFontFeatures))) ; } test_field_fFontFeatures () ; fn test_field_fFontArguments () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TextStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontArguments) as usize - ptr as usize } , 336usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TextStyle) , "::" , stringify ! (fFontArguments))) ; } test_field_fFontArguments () ; } extern "C" { # [link_name = "\u{1}?cloneForPlaceholder@TextStyle@textlayout@skia@@QEAA?AV123@XZ"] pub fn skia_textlayout_TextStyle_cloneForPlaceholder (this : * mut skia_textlayout_TextStyle) -> skia_textlayout_TextStyle ; } extern "C" { # [link_name = "\u{1}?equals@TextStyle@textlayout@skia@@QEBA_NAEBV123@@Z"] pub fn skia_textlayout_TextStyle_equals (this : * const skia_textlayout_TextStyle , other : * const skia_textlayout_TextStyle) -> bool ; } extern "C" { # [link_name = "\u{1}?equalsByFonts@TextStyle@textlayout@skia@@QEBA_NAEBV123@@Z"] pub fn skia_textlayout_TextStyle_equalsByFonts (this : * const skia_textlayout_TextStyle , that : * const skia_textlayout_TextStyle) -> bool ; } extern "C" { # [link_name = "\u{1}?matchOneAttribute@TextStyle@textlayout@skia@@QEBA_NW4StyleType@23@AEBV123@@Z"] pub fn skia_textlayout_TextStyle_matchOneAttribute (this : * const skia_textlayout_TextStyle , styleType : skia_textlayout_StyleType , other : * const skia_textlayout_TextStyle) -> bool ; } extern "C" { # [link_name = "\u{1}?setFontArguments@TextStyle@textlayout@skia@@QEAAXAEBV?$optional@USkFontArguments@@@std@@@Z"] pub fn skia_textlayout_TextStyle_setFontArguments (this : * mut skia_textlayout_TextStyle , args : * const [u64 ; 7usize]) ; } extern "C" { # [link_name = "\u{1}?getFontMetrics@TextStyle@textlayout@skia@@QEBAXPEAUSkFontMetrics@@@Z"] pub fn skia_textlayout_TextStyle_getFontMetrics (this : * const skia_textlayout_TextStyle , metrics : * mut SkFontMetrics) ; } impl skia_textlayout_TextStyle { # [inline] pub unsafe fn cloneForPlaceholder (& mut self) -> skia_textlayout_TextStyle { skia_textlayout_TextStyle_cloneForPlaceholder (self) } # [inline] pub unsafe fn equals (& self , other : * const skia_textlayout_TextStyle) -> bool { skia_textlayout_TextStyle_equals (self , other) } # [inline] pub unsafe fn equalsByFonts (& self , that : * const skia_textlayout_TextStyle) -> bool { skia_textlayout_TextStyle_equalsByFonts (self , that) } # [inline] pub unsafe fn matchOneAttribute (& self , styleType : skia_textlayout_StyleType , other : * const skia_textlayout_TextStyle) -> bool { skia_textlayout_TextStyle_matchOneAttribute (self , styleType , other) } # [inline] pub unsafe fn setFontArguments (& mut self , args : * const [u64 ; 7usize]) { skia_textlayout_TextStyle_setFontArguments (self , args) } # [inline] pub unsafe fn getFontMetrics (& self , metrics : * mut SkFontMetrics) { skia_textlayout_TextStyle_getFontMetrics (self , metrics) } } pub type skia_textlayout_TextRange = skia_textlayout_SkRange < usize > ; # [repr (C)] pub struct skia_textlayout_Block { pub fRange : skia_textlayout_TextRange , pub fStyle : skia_textlayout_TextStyle , } # [test] fn bindgen_test_layout_skia_textlayout_Block () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_Block > () , 424usize , concat ! ("Size of: " , stringify ! (skia_textlayout_Block))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_Block > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_Block))) ; fn test_field_fRange () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Block > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRange) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Block) , "::" , stringify ! (fRange))) ; } test_field_fRange () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Block > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Block) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; } pub type skia_textlayout_BlockRange = skia_textlayout_SkRange < usize > ; # [repr (C)] pub struct skia_textlayout_Placeholder { pub fRange : skia_textlayout_TextRange , pub fStyle : skia_textlayout_PlaceholderStyle , pub fTextStyle : skia_textlayout_TextStyle , pub fBlocksBefore : skia_textlayout_BlockRange , pub fTextBefore : skia_textlayout_TextRange , } # [test] fn bindgen_test_layout_skia_textlayout_Placeholder () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_Placeholder > () , 480usize , concat ! ("Size of: " , stringify ! (skia_textlayout_Placeholder))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_Placeholder > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_Placeholder))) ; fn test_field_fRange () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Placeholder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRange) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Placeholder) , "::" , stringify ! (fRange))) ; } test_field_fRange () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Placeholder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Placeholder) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; fn test_field_fTextStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Placeholder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextStyle) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Placeholder) , "::" , stringify ! (fTextStyle))) ; } test_field_fTextStyle () ; fn test_field_fBlocksBefore () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Placeholder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBlocksBefore) as usize - ptr as usize } , 448usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Placeholder) , "::" , stringify ! (fBlocksBefore))) ; } test_field_fBlocksBefore () ; fn test_field_fTextBefore () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Placeholder > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextBefore) as usize - ptr as usize } , 464usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Placeholder) , "::" , stringify ! (fTextBefore))) ; } test_field_fTextBefore () ; } # [repr (C)] # [repr (align (8))] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_FontCollection { pub _bindgen_opaque_blob : [u64 ; 31usize] , } # [repr (C)] pub struct skia_textlayout_FontCollection_FamilyKey { pub fFamilyNames : [u64 ; 3usize] , pub fFontStyle : SkFontStyle , pub fFontArguments : [u64 ; 9usize] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_FontCollection_FamilyKey_Hasher { pub _address : u8 , } # [test] fn bindgen_test_layout_skia_textlayout_FontCollection_FamilyKey_Hasher () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_FontCollection_FamilyKey_Hasher > () , 1usize , concat ! ("Size of: " , stringify ! (skia_textlayout_FontCollection_FamilyKey_Hasher))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_FontCollection_FamilyKey_Hasher > () , 1usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_FontCollection_FamilyKey_Hasher))) ; } # [test] fn bindgen_test_layout_skia_textlayout_FontCollection_FamilyKey () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_FontCollection_FamilyKey > () , 104usize , concat ! ("Size of: " , stringify ! (skia_textlayout_FontCollection_FamilyKey))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_FontCollection_FamilyKey > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_FontCollection_FamilyKey))) ; fn test_field_fFamilyNames () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontCollection_FamilyKey > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFamilyNames) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontCollection_FamilyKey) , "::" , stringify ! (fFamilyNames))) ; } test_field_fFamilyNames () ; fn test_field_fFontStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontCollection_FamilyKey > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontStyle) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontCollection_FamilyKey) , "::" , stringify ! (fFontStyle))) ; } test_field_fFontStyle () ; fn test_field_fFontArguments () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_FontCollection_FamilyKey > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontArguments) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_FontCollection_FamilyKey) , "::" , stringify ! (fFontArguments))) ; } test_field_fFontArguments () ; } # [test] fn bindgen_test_layout_skia_textlayout_FontCollection () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_FontCollection > () , 248usize , concat ! ("Size of: " , stringify ! (skia_textlayout_FontCollection))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_FontCollection > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_FontCollection))) ; } extern "C" { # [link_name = "\u{1}?getFontManagersCount@FontCollection@textlayout@skia@@QEBA_KXZ"] pub fn skia_textlayout_FontCollection_getFontManagersCount (this : * const skia_textlayout_FontCollection) -> usize ; } extern "C" { # [link_name = "\u{1}?setAssetFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@@Z"] pub fn skia_textlayout_FontCollection_setAssetFontManager (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr >) ; } extern "C" { # [link_name = "\u{1}?setDynamicFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@@Z"] pub fn skia_textlayout_FontCollection_setDynamicFontManager (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr >) ; } extern "C" { # [link_name = "\u{1}?setTestFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@@Z"] pub fn skia_textlayout_FontCollection_setTestFontManager (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr >) ; } extern "C" { # [link_name = "\u{1}?setDefaultFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@@Z"] pub fn skia_textlayout_FontCollection_setDefaultFontManager (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr >) ; } extern "C" { # [link_name = "\u{1}?setDefaultFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@QEBD@Z"] pub fn skia_textlayout_FontCollection_setDefaultFontManager1 (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr > , defaultFamilyName : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [link_name = "\u{1}?setDefaultFontManager@FontCollection@textlayout@skia@@QEAAXV?$sk_sp@VSkFontMgr@@@@AEBV?$vector@VSkString@@V?$allocator@VSkString@@@std@@@std@@@Z"] pub fn skia_textlayout_FontCollection_setDefaultFontManager2 (this : * mut skia_textlayout_FontCollection , fontManager : sk_sp < SkFontMgr > , defaultFamilyNames : * const [u64 ; 3usize]) ; } extern "C" { # [link_name = "\u{1}?findTypefaces@FontCollection@textlayout@skia@@QEAA?AV?$vector@V?$sk_sp@VSkTypeface@@@@V?$allocator@V?$sk_sp@VSkTypeface@@@@@std@@@std@@AEBV?$vector@VSkString@@V?$allocator@VSkString@@@std@@@5@VSkFontStyle@@@Z"] pub fn skia_textlayout_FontCollection_findTypefaces (this : * mut skia_textlayout_FontCollection , familyNames : * const [u64 ; 3usize] , fontStyle : SkFontStyle) -> [u64 ; 3usize] ; } extern "C" { # [link_name = "\u{1}?findTypefaces@FontCollection@textlayout@skia@@QEAA?AV?$vector@V?$sk_sp@VSkTypeface@@@@V?$allocator@V?$sk_sp@VSkTypeface@@@@@std@@@std@@AEBV?$vector@VSkString@@V?$allocator@VSkString@@@std@@@5@VSkFontStyle@@AEBV?$optional@VFontArguments@textlayout@skia@@@5@@Z"] pub fn skia_textlayout_FontCollection_findTypefaces1 (this : * mut skia_textlayout_FontCollection , familyNames : * const [u64 ; 3usize] , fontStyle : SkFontStyle , fontArgs : * const [u64 ; 9usize]) -> [u64 ; 3usize] ; } extern "C" { # [link_name = "\u{1}?defaultFallback@FontCollection@textlayout@skia@@QEAA?AV?$sk_sp@VSkTypeface@@@@HVSkFontStyle@@AEBVSkString@@@Z"] pub fn skia_textlayout_FontCollection_defaultFallback (this : * mut skia_textlayout_FontCollection , unicode : SkUnichar , fontStyle : SkFontStyle , locale : * const SkString) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?defaultFallback@FontCollection@textlayout@skia@@QEAA?AV?$sk_sp@VSkTypeface@@@@XZ"] pub fn skia_textlayout_FontCollection_defaultFallback1 (this : * mut skia_textlayout_FontCollection) -> sk_sp < SkTypeface > ; } extern "C" { # [link_name = "\u{1}?disableFontFallback@FontCollection@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_FontCollection_disableFontFallback (this : * mut skia_textlayout_FontCollection) ; } extern "C" { # [link_name = "\u{1}?enableFontFallback@FontCollection@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_FontCollection_enableFontFallback (this : * mut skia_textlayout_FontCollection) ; } extern "C" { # [link_name = "\u{1}?clearCaches@FontCollection@textlayout@skia@@QEAAXXZ"] pub fn skia_textlayout_FontCollection_clearCaches (this : * mut skia_textlayout_FontCollection) ; } extern "C" { # [link_name = "\u{1}??0FontCollection@textlayout@skia@@QEAA@XZ"] pub fn skia_textlayout_FontCollection_FontCollection (this : * mut skia_textlayout_FontCollection) ; } impl skia_textlayout_FontCollection { # [inline] pub unsafe fn getFontManagersCount (& self) -> usize { skia_textlayout_FontCollection_getFontManagersCount (self) } # [inline] pub unsafe fn setAssetFontManager (& mut self , fontManager : sk_sp < SkFontMgr >) { skia_textlayout_FontCollection_setAssetFontManager (self , fontManager) } # [inline] pub unsafe fn setDynamicFontManager (& mut self , fontManager : sk_sp < SkFontMgr >) { skia_textlayout_FontCollection_setDynamicFontManager (self , fontManager) } # [inline] pub unsafe fn setTestFontManager (& mut self , fontManager : sk_sp < SkFontMgr >) { skia_textlayout_FontCollection_setTestFontManager (self , fontManager) } # [inline] pub unsafe fn setDefaultFontManager (& mut self , fontManager : sk_sp < SkFontMgr >) { skia_textlayout_FontCollection_setDefaultFontManager (self , fontManager) } # [inline] pub unsafe fn setDefaultFontManager1 (& mut self , fontManager : sk_sp < SkFontMgr > , defaultFamilyName : * const :: std :: os :: raw :: c_char) { skia_textlayout_FontCollection_setDefaultFontManager1 (self , fontManager , defaultFamilyName) } # [inline] pub unsafe fn setDefaultFontManager2 (& mut self , fontManager : sk_sp < SkFontMgr > , defaultFamilyNames : * const [u64 ; 3usize]) { skia_textlayout_FontCollection_setDefaultFontManager2 (self , fontManager , defaultFamilyNames) } # [inline] pub unsafe fn findTypefaces (& mut self , familyNames : * const [u64 ; 3usize] , fontStyle : SkFontStyle) -> [u64 ; 3usize] { skia_textlayout_FontCollection_findTypefaces (self , familyNames , fontStyle) } # [inline] pub unsafe fn findTypefaces1 (& mut self , familyNames : * const [u64 ; 3usize] , fontStyle : SkFontStyle , fontArgs : * const [u64 ; 9usize]) -> [u64 ; 3usize] { skia_textlayout_FontCollection_findTypefaces1 (self , familyNames , fontStyle , fontArgs) } # [inline] pub unsafe fn defaultFallback (& mut self , unicode : SkUnichar , fontStyle : SkFontStyle , locale : * const SkString) -> sk_sp < SkTypeface > { skia_textlayout_FontCollection_defaultFallback (self , unicode , fontStyle , locale) } # [inline] pub unsafe fn defaultFallback1 (& mut self) -> sk_sp < SkTypeface > { skia_textlayout_FontCollection_defaultFallback1 (self) } # [inline] pub unsafe fn disableFontFallback (& mut self) { skia_textlayout_FontCollection_disableFontFallback (self) } # [inline] pub unsafe fn enableFontFallback (& mut self) { skia_textlayout_FontCollection_enableFontFallback (self) } # [inline] pub unsafe fn clearCaches (& mut self) { skia_textlayout_FontCollection_clearCaches (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_FontCollection_FontCollection (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_StyleMetrics { pub text_style : * const skia_textlayout_TextStyle , pub font_metrics : SkFontMetrics , } # [test] fn bindgen_test_layout_skia_textlayout_StyleMetrics () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_StyleMetrics > () , 72usize , concat ! ("Size of: " , stringify ! (skia_textlayout_StyleMetrics))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_StyleMetrics > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_StyleMetrics))) ; fn test_field_text_style () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StyleMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . text_style) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StyleMetrics) , "::" , stringify ! (text_style))) ; } test_field_text_style () ; fn test_field_font_metrics () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StyleMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . font_metrics) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StyleMetrics) , "::" , stringify ! (font_metrics))) ; } test_field_font_metrics () ; } # [repr (C)] pub struct skia_textlayout_LineMetrics { pub fStartIndex : usize , pub fEndIndex : usize , pub fEndExcludingWhitespaces : usize , pub fEndIncludingNewline : usize , pub fHardBreak : bool , pub fAscent : f64 , pub fDescent : f64 , pub fUnscaledAscent : f64 , pub fHeight : f64 , pub fWidth : f64 , pub fLeft : f64 , pub fBaseline : f64 , pub fLineNumber : usize , pub fLineMetrics : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_skia_textlayout_LineMetrics () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_LineMetrics > () , 120usize , concat ! ("Size of: " , stringify ! (skia_textlayout_LineMetrics))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_LineMetrics > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_LineMetrics))) ; fn test_field_fStartIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStartIndex) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fStartIndex))) ; } test_field_fStartIndex () ; fn test_field_fEndIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEndIndex) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fEndIndex))) ; } test_field_fEndIndex () ; fn test_field_fEndExcludingWhitespaces () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEndExcludingWhitespaces) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fEndExcludingWhitespaces))) ; } test_field_fEndExcludingWhitespaces () ; fn test_field_fEndIncludingNewline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEndIncludingNewline) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fEndIncludingNewline))) ; } test_field_fEndIncludingNewline () ; fn test_field_fHardBreak () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHardBreak) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fHardBreak))) ; } test_field_fHardBreak () ; fn test_field_fAscent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAscent) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fAscent))) ; } test_field_fAscent () ; fn test_field_fDescent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDescent) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fDescent))) ; } test_field_fDescent () ; fn test_field_fUnscaledAscent () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fUnscaledAscent) as usize - ptr as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fUnscaledAscent))) ; } test_field_fUnscaledAscent () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fLeft () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeft) as usize - ptr as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fLeft))) ; } test_field_fLeft () ; fn test_field_fBaseline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fBaseline) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fBaseline))) ; } test_field_fBaseline () ; fn test_field_fLineNumber () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLineNumber) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fLineNumber))) ; } test_field_fLineNumber () ; fn test_field_fLineMetrics () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_LineMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLineMetrics) as usize - ptr as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_LineMetrics) , "::" , stringify ! (fLineMetrics))) ; } test_field_fLineMetrics () ; } # [repr (C)] pub struct skia_textlayout_StrutStyle { pub fFontFamilies : [u64 ; 3usize] , pub fFontStyle : SkFontStyle , pub fFontSize : SkScalar , pub fHeight : SkScalar , pub fLeading : SkScalar , pub fForceHeight : bool , pub fEnabled : bool , pub fHeightOverride : bool , pub fHalfLeading : bool , } # [test] fn bindgen_test_layout_skia_textlayout_StrutStyle () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_StrutStyle > () , 48usize , concat ! ("Size of: " , stringify ! (skia_textlayout_StrutStyle))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_StrutStyle > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_StrutStyle))) ; fn test_field_fFontFamilies () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontFamilies) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fFontFamilies))) ; } test_field_fFontFamilies () ; fn test_field_fFontStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontStyle) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fFontStyle))) ; } test_field_fFontStyle () ; fn test_field_fFontSize () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontSize) as usize - ptr as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fFontSize))) ; } test_field_fFontSize () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fLeading () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLeading) as usize - ptr as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fLeading))) ; } test_field_fLeading () ; fn test_field_fForceHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fForceHeight) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fForceHeight))) ; } test_field_fForceHeight () ; fn test_field_fEnabled () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEnabled) as usize - ptr as usize } , 41usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fEnabled))) ; } test_field_fEnabled () ; fn test_field_fHeightOverride () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeightOverride) as usize - ptr as usize } , 42usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fHeightOverride))) ; } test_field_fHeightOverride () ; fn test_field_fHalfLeading () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_StrutStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHalfLeading) as usize - ptr as usize } , 43usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_StrutStyle) , "::" , stringify ! (fHalfLeading))) ; } test_field_fHalfLeading () ; } extern "C" { # [link_name = "\u{1}??0StrutStyle@textlayout@skia@@QEAA@XZ"] pub fn skia_textlayout_StrutStyle_StrutStyle (this : * mut skia_textlayout_StrutStyle) ; } impl skia_textlayout_StrutStyle { # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_StrutStyle_StrutStyle (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct skia_textlayout_ParagraphStyle { pub fStrutStyle : skia_textlayout_StrutStyle , pub fDefaultTextStyle : skia_textlayout_TextStyle , pub fTextAlign : skia_textlayout_TextAlign , pub fTextDirection : skia_textlayout_TextDirection , pub fLinesLimit : usize , pub fEllipsisUtf16 : std_u16string , pub fEllipsis : SkString , pub fHeight : SkScalar , pub fTextHeightBehavior : skia_textlayout_TextHeightBehavior , pub fHintingIsOn : bool , pub fReplaceTabCharacters : bool , } # [test] fn bindgen_test_layout_skia_textlayout_ParagraphStyle () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_ParagraphStyle > () , 528usize , concat ! ("Size of: " , stringify ! (skia_textlayout_ParagraphStyle))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_ParagraphStyle > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_ParagraphStyle))) ; fn test_field_fStrutStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStrutStyle) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fStrutStyle))) ; } test_field_fStrutStyle () ; fn test_field_fDefaultTextStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fDefaultTextStyle) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fDefaultTextStyle))) ; } test_field_fDefaultTextStyle () ; fn test_field_fTextAlign () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextAlign) as usize - ptr as usize } , 456usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fTextAlign))) ; } test_field_fTextAlign () ; fn test_field_fTextDirection () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextDirection) as usize - ptr as usize } , 460usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fTextDirection))) ; } test_field_fTextDirection () ; fn test_field_fLinesLimit () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLinesLimit) as usize - ptr as usize } , 464usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fLinesLimit))) ; } test_field_fLinesLimit () ; fn test_field_fEllipsisUtf16 () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEllipsisUtf16) as usize - ptr as usize } , 472usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fEllipsisUtf16))) ; } test_field_fEllipsisUtf16 () ; fn test_field_fEllipsis () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fEllipsis) as usize - ptr as usize } , 504usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fEllipsis))) ; } test_field_fEllipsis () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 512usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fTextHeightBehavior () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fTextHeightBehavior) as usize - ptr as usize } , 516usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fTextHeightBehavior))) ; } test_field_fTextHeightBehavior () ; fn test_field_fHintingIsOn () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHintingIsOn) as usize - ptr as usize } , 520usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fHintingIsOn))) ; } test_field_fHintingIsOn () ; fn test_field_fReplaceTabCharacters () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_ParagraphStyle > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fReplaceTabCharacters) as usize - ptr as usize } , 521usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_ParagraphStyle) , "::" , stringify ! (fReplaceTabCharacters))) ; } test_field_fReplaceTabCharacters () ; } extern "C" { # [link_name = "\u{1}?effective_align@ParagraphStyle@textlayout@skia@@QEBA?AW4TextAlign@23@XZ"] pub fn skia_textlayout_ParagraphStyle_effective_align (this : * const skia_textlayout_ParagraphStyle) -> skia_textlayout_TextAlign ; } extern "C" { # [link_name = "\u{1}??0ParagraphStyle@textlayout@skia@@QEAA@XZ"] pub fn skia_textlayout_ParagraphStyle_ParagraphStyle (this : * mut skia_textlayout_ParagraphStyle) ; } impl skia_textlayout_ParagraphStyle { # [inline] pub unsafe fn effective_align (& self) -> skia_textlayout_TextAlign { skia_textlayout_ParagraphStyle_effective_align (self) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_ParagraphStyle_ParagraphStyle (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct skia_textlayout_Paragraph__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] pub struct skia_textlayout_Paragraph { pub vtable_ : * const skia_textlayout_Paragraph__bindgen_vtable , pub fFontCollection : sk_sp < skia_textlayout_FontCollection > , pub fParagraphStyle : skia_textlayout_ParagraphStyle , pub fAlphabeticBaseline : SkScalar , pub fIdeographicBaseline : SkScalar , pub fHeight : SkScalar , pub fWidth : SkScalar , pub fMaxIntrinsicWidth : SkScalar , pub fMinIntrinsicWidth : SkScalar , pub fLongestLine : SkScalar , pub fExceededMaxLines : bool , } pub const skia_textlayout_Paragraph_VisitorFlags_kWhiteSpace_VisitorFlag : skia_textlayout_Paragraph_VisitorFlags = 1 ; pub type skia_textlayout_Paragraph_VisitorFlags = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct skia_textlayout_Paragraph_VisitorInfo { pub font : * const SkFont , pub origin : SkPoint , pub advanceX : SkScalar , pub count : :: std :: os :: raw :: c_int , pub glyphs : * const u16 , pub positions : * const SkPoint , pub utf8Starts : * const u32 , pub flags : :: std :: os :: raw :: c_uint , } # [test] fn bindgen_test_layout_skia_textlayout_Paragraph_VisitorInfo () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_Paragraph_VisitorInfo > () , 56usize , concat ! ("Size of: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_Paragraph_VisitorInfo > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_Paragraph_VisitorInfo))) ; fn test_field_font () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . font) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (font))) ; } test_field_font () ; fn test_field_origin () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . origin) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (origin))) ; } test_field_origin () ; fn test_field_advanceX () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . advanceX) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (advanceX))) ; } test_field_advanceX () ; fn test_field_count () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . count) as usize - ptr as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (count))) ; } test_field_count () ; fn test_field_glyphs () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . glyphs) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (glyphs))) ; } test_field_glyphs () ; fn test_field_positions () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . positions) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (positions))) ; } test_field_positions () ; fn test_field_utf8Starts () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . utf8Starts) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (utf8Starts))) ; } test_field_utf8Starts () ; fn test_field_flags () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph_VisitorInfo > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . flags) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph_VisitorInfo) , "::" , stringify ! (flags))) ; } test_field_flags () ; } pub type skia_textlayout_Paragraph_Visitor = u8 ; # [test] fn bindgen_test_layout_skia_textlayout_Paragraph () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_Paragraph > () , 576usize , concat ! ("Size of: " , stringify ! (skia_textlayout_Paragraph))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_Paragraph > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_Paragraph))) ; fn test_field_fFontCollection () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFontCollection) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fFontCollection))) ; } test_field_fFontCollection () ; fn test_field_fParagraphStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fParagraphStyle) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fParagraphStyle))) ; } test_field_fParagraphStyle () ; fn test_field_fAlphabeticBaseline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlphabeticBaseline) as usize - ptr as usize } , 544usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fAlphabeticBaseline))) ; } test_field_fAlphabeticBaseline () ; fn test_field_fIdeographicBaseline () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fIdeographicBaseline) as usize - ptr as usize } , 548usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fIdeographicBaseline))) ; } test_field_fIdeographicBaseline () ; fn test_field_fHeight () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fHeight) as usize - ptr as usize } , 552usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fHeight))) ; } test_field_fHeight () ; fn test_field_fWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fWidth) as usize - ptr as usize } , 556usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fWidth))) ; } test_field_fWidth () ; fn test_field_fMaxIntrinsicWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMaxIntrinsicWidth) as usize - ptr as usize } , 560usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fMaxIntrinsicWidth))) ; } test_field_fMaxIntrinsicWidth () ; fn test_field_fMinIntrinsicWidth () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fMinIntrinsicWidth) as usize - ptr as usize } , 564usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fMinIntrinsicWidth))) ; } test_field_fMinIntrinsicWidth () ; fn test_field_fLongestLine () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fLongestLine) as usize - ptr as usize } , 568usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fLongestLine))) ; } test_field_fLongestLine () ; fn test_field_fExceededMaxLines () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_Paragraph > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fExceededMaxLines) as usize - ptr as usize } , 572usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_Paragraph) , "::" , stringify ! (fExceededMaxLines))) ; } test_field_fExceededMaxLines () ; } extern "C" { # [link_name = "\u{1}??0Paragraph@textlayout@skia@@QEAA@UParagraphStyle@12@V?$sk_sp@VFontCollection@textlayout@skia@@@@@Z"] pub fn skia_textlayout_Paragraph_Paragraph (this : * mut skia_textlayout_Paragraph , style : skia_textlayout_ParagraphStyle , fonts : sk_sp < skia_textlayout_FontCollection >) ; } impl skia_textlayout_Paragraph { # [inline] pub unsafe fn new (style : skia_textlayout_ParagraphStyle , fonts : sk_sp < skia_textlayout_FontCollection >) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_Paragraph_Paragraph (__bindgen_tmp . as_mut_ptr () , style , fonts) ; __bindgen_tmp . assume_init () } } # [repr (C)] pub struct skia_textlayout_ParagraphBuilder__bindgen_vtable (:: core :: ffi :: c_void) ; # [repr (C)] # [derive (Debug)] pub struct skia_textlayout_ParagraphBuilder { pub vtable_ : * const skia_textlayout_ParagraphBuilder__bindgen_vtable , } # [test] fn bindgen_test_layout_skia_textlayout_ParagraphBuilder () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_ParagraphBuilder > () , 8usize , concat ! ("Size of: " , stringify ! (skia_textlayout_ParagraphBuilder))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_ParagraphBuilder > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_ParagraphBuilder))) ; } extern "C" { # [link_name = "\u{1}?make@ParagraphBuilder@textlayout@skia@@SA?AV?$unique_ptr@VParagraphBuilder@textlayout@skia@@U?$default_delete@VParagraphBuilder@textlayout@skia@@@std@@@std@@AEBUParagraphStyle@23@V?$sk_sp@VFontCollection@textlayout@skia@@@@@Z"] pub fn skia_textlayout_ParagraphBuilder_make (style : * const skia_textlayout_ParagraphStyle , fontCollection : sk_sp < skia_textlayout_FontCollection >) -> u64 ; } impl skia_textlayout_ParagraphBuilder { # [inline] pub unsafe fn make (style : * const skia_textlayout_ParagraphStyle , fontCollection : sk_sp < skia_textlayout_FontCollection >) -> u64 { skia_textlayout_ParagraphBuilder_make (style , fontCollection) } } # [repr (C)] # [derive (Debug)] pub struct skia_textlayout_TypefaceFontStyleSet { pub _base : SkFontStyleSet , pub fStyles : [u64 ; 2usize] , pub fFamilyName : SkString , pub fAlias : SkString , } # [test] fn bindgen_test_layout_skia_textlayout_TypefaceFontStyleSet () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_TypefaceFontStyleSet > () , 48usize , concat ! ("Size of: " , stringify ! (skia_textlayout_TypefaceFontStyleSet))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_TypefaceFontStyleSet > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_TypefaceFontStyleSet))) ; fn test_field_fStyles () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TypefaceFontStyleSet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyles) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TypefaceFontStyleSet) , "::" , stringify ! (fStyles))) ; } test_field_fStyles () ; fn test_field_fFamilyName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TypefaceFontStyleSet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFamilyName) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TypefaceFontStyleSet) , "::" , stringify ! (fFamilyName))) ; } test_field_fFamilyName () ; fn test_field_fAlias () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TypefaceFontStyleSet > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fAlias) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TypefaceFontStyleSet) , "::" , stringify ! (fAlias))) ; } test_field_fAlias () ; } extern "C" { # [link_name = "\u{1}?appendTypeface@TypefaceFontStyleSet@textlayout@skia@@QEAAXV?$sk_sp@VSkTypeface@@@@@Z"] pub fn skia_textlayout_TypefaceFontStyleSet_appendTypeface (this : * mut skia_textlayout_TypefaceFontStyleSet , typeface : sk_sp < SkTypeface >) ; } extern "C" { # [link_name = "\u{1}??0TypefaceFontStyleSet@textlayout@skia@@QEAA@AEBVSkString@@@Z"] pub fn skia_textlayout_TypefaceFontStyleSet_TypefaceFontStyleSet (this : * mut skia_textlayout_TypefaceFontStyleSet , familyName : * const SkString) ; } impl skia_textlayout_TypefaceFontStyleSet { # [inline] pub unsafe fn appendTypeface (& mut self , typeface : sk_sp < SkTypeface >) { skia_textlayout_TypefaceFontStyleSet_appendTypeface (self , typeface) } # [inline] pub unsafe fn new (familyName : * const SkString) -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; skia_textlayout_TypefaceFontStyleSet_TypefaceFontStyleSet (__bindgen_tmp . as_mut_ptr () , familyName) ; __bindgen_tmp . assume_init () } } extern "C" { # [link_name = "\u{1}?count@TypefaceFontStyleSet@textlayout@skia@@UEAAHXZ"] pub fn skia_textlayout_TypefaceFontStyleSet_count (this : * mut :: core :: ffi :: c_void) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?getStyle@TypefaceFontStyleSet@textlayout@skia@@UEAAXHPEAVSkFontStyle@@PEAVSkString@@@Z"] pub fn skia_textlayout_TypefaceFontStyleSet_getStyle (this : * mut :: core :: ffi :: c_void , index : :: std :: os :: raw :: c_int , arg1 : * mut SkFontStyle , name : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?createTypeface@TypefaceFontStyleSet@textlayout@skia@@UEAAPEAVSkTypeface@@H@Z"] pub fn skia_textlayout_TypefaceFontStyleSet_createTypeface (this : * mut :: core :: ffi :: c_void , index : :: std :: os :: raw :: c_int) -> * mut SkTypeface ; } extern "C" { # [link_name = "\u{1}?matchStyle@TypefaceFontStyleSet@textlayout@skia@@UEAAPEAVSkTypeface@@AEBVSkFontStyle@@@Z"] pub fn skia_textlayout_TypefaceFontStyleSet_matchStyle (this : * mut :: core :: ffi :: c_void , pattern : * const SkFontStyle) -> * mut SkTypeface ; } # [repr (C)] # [derive (Debug)] pub struct skia_textlayout_TypefaceFontProvider { pub _base : SkFontMgr , pub fRegisteredFamilies : [u64 ; 2usize] , pub fFamilyNames : [u64 ; 2usize] , } # [test] fn bindgen_test_layout_skia_textlayout_TypefaceFontProvider () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_TypefaceFontProvider > () , 48usize , concat ! ("Size of: " , stringify ! (skia_textlayout_TypefaceFontProvider))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_TypefaceFontProvider > () , 8usize , concat ! ("Alignment of " , stringify ! (skia_textlayout_TypefaceFontProvider))) ; fn test_field_fRegisteredFamilies () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TypefaceFontProvider > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fRegisteredFamilies) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TypefaceFontProvider) , "::" , stringify ! (fRegisteredFamilies))) ; } test_field_fRegisteredFamilies () ; fn test_field_fFamilyNames () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < skia_textlayout_TypefaceFontProvider > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFamilyNames) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (skia_textlayout_TypefaceFontProvider) , "::" , stringify ! (fFamilyNames))) ; } test_field_fFamilyNames () ; } extern "C" { # [link_name = "\u{1}?registerTypeface@TypefaceFontProvider@textlayout@skia@@QEAA_KV?$sk_sp@VSkTypeface@@@@@Z"] pub fn skia_textlayout_TypefaceFontProvider_registerTypeface (this : * mut skia_textlayout_TypefaceFontProvider , typeface : sk_sp < SkTypeface >) -> usize ; } extern "C" { # [link_name = "\u{1}?registerTypeface@TypefaceFontProvider@textlayout@skia@@QEAA_KV?$sk_sp@VSkTypeface@@@@AEBVSkString@@@Z"] pub fn skia_textlayout_TypefaceFontProvider_registerTypeface1 (this : * mut skia_textlayout_TypefaceFontProvider , typeface : sk_sp < SkTypeface > , alias : * const SkString) -> usize ; } impl skia_textlayout_TypefaceFontProvider { # [inline] pub unsafe fn registerTypeface (& mut self , typeface : sk_sp < SkTypeface >) -> usize { skia_textlayout_TypefaceFontProvider_registerTypeface (self , typeface) } # [inline] pub unsafe fn registerTypeface1 (& mut self , typeface : sk_sp < SkTypeface > , alias : * const SkString) -> usize { skia_textlayout_TypefaceFontProvider_registerTypeface1 (self , typeface , alias) } } extern "C" { # [link_name = "\u{1}?onCountFamilies@TypefaceFontProvider@textlayout@skia@@UEBAHXZ"] pub fn skia_textlayout_TypefaceFontProvider_onCountFamilies (this : * mut :: core :: ffi :: c_void) -> :: std :: os :: raw :: c_int ; } extern "C" { # [link_name = "\u{1}?onGetFamilyName@TypefaceFontProvider@textlayout@skia@@UEBAXHPEAVSkString@@@Z"] pub fn skia_textlayout_TypefaceFontProvider_onGetFamilyName (this : * mut :: core :: ffi :: c_void , index : :: std :: os :: raw :: c_int , familyName : * mut SkString) ; } extern "C" { # [link_name = "\u{1}?onMatchFamily@TypefaceFontProvider@textlayout@skia@@UEBAPEAVSkFontStyleSet@@QEBD@Z"] pub fn skia_textlayout_TypefaceFontProvider_onMatchFamily (this : * mut :: core :: ffi :: c_void , familyName : * const :: std :: os :: raw :: c_char) -> * mut SkFontStyleSet ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkGoodHash { pub _address : u8 , } # [test] fn bindgen_test_layout_SkGoodHash () { assert_eq ! (:: core :: mem :: size_of :: < SkGoodHash > () , 1usize , concat ! ("Size of: " , stringify ! (SkGoodHash))) ; assert_eq ! (:: core :: mem :: align_of :: < SkGoodHash > () , 1usize , concat ! ("Alignment of " , stringify ! (SkGoodHash))) ; } # [repr (C)] pub struct SkTHashTable { pub fCount : :: std :: os :: raw :: c_int , pub fCapacity : :: std :: os :: raw :: c_int , pub fSlots : SkAutoTArray , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTHashTable_Iter { pub fTable : * const SkTHashTable_Iter_TTable , pub fSlot : :: std :: os :: raw :: c_int , } pub type SkTHashTable_Iter_TTable = SkTHashTable ; # [repr (C)] pub struct SkTHashTable_Slot < T > { pub hash : u32 , pub val : SkTHashTable_Slot_Storage < T > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (C)] # [repr (align (1))] pub struct SkTHashTable_Slot_Storage < T > { pub storage : __BindgenUnionField < T > , pub bindgen_union_field : [u8 ; 0usize] , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTHashMap { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTHashMap_Pair < K , V > { pub _base : std_pair < K , V > , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < K > > , pub _phantom_1 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < V > > , } pub type SkTHashMap_Iter = SkTHashTable ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTInternalLList < T > { pub fHead : * mut T , pub fTail : * mut T , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkTInternalLList_Iter < T > { pub fCurr : * mut T , pub _phantom_0 : :: core :: marker :: PhantomData < :: core :: cell :: UnsafeCell < T > > , } impl SkTInternalLList_Iter_IterStart { pub const kTail_IterStart : SkTInternalLList_Iter_IterStart = SkTInternalLList_Iter_IterStart :: kHead_IterStart ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum SkTInternalLList_Iter_IterStart { kHead_IterStart = 0 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SkLRUCache_Traits { pub _address : u8 , } # [repr (C)] # [derive (Debug)] pub struct SkFontDescriptor { pub fFamilyName : SkString , pub fFullName : SkString , pub fPostscriptName : SkString , pub fStyle : SkFontStyle , pub fStream : u64 , pub fCollectionIndex : :: std :: os :: raw :: c_int , pub fCoordinateCount : :: std :: os :: raw :: c_int , pub fVariation : SkFontDescriptor_Coordinates , pub fPaletteIndex : :: std :: os :: raw :: c_int , pub fPaletteEntryOverrideCount : :: std :: os :: raw :: c_int , pub fPaletteEntryOverrides : u64 , } pub type SkFontDescriptor_Coordinates = [u64 ; 5usize] ; # [test] fn bindgen_test_layout_SkFontDescriptor () { assert_eq ! (:: core :: mem :: size_of :: < SkFontDescriptor > () , 104usize , concat ! ("Size of: " , stringify ! (SkFontDescriptor))) ; assert_eq ! (:: core :: mem :: align_of :: < SkFontDescriptor > () , 8usize , concat ! ("Alignment of " , stringify ! (SkFontDescriptor))) ; fn test_field_fFamilyName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFamilyName) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fFamilyName))) ; } test_field_fFamilyName () ; fn test_field_fFullName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fFullName) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fFullName))) ; } test_field_fFullName () ; fn test_field_fPostscriptName () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPostscriptName) as usize - ptr as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fPostscriptName))) ; } test_field_fPostscriptName () ; fn test_field_fStyle () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStyle) as usize - ptr as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fStyle))) ; } test_field_fStyle () ; fn test_field_fStream () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fStream) as usize - ptr as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fStream))) ; } test_field_fStream () ; fn test_field_fCollectionIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCollectionIndex) as usize - ptr as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fCollectionIndex))) ; } test_field_fCollectionIndex () ; fn test_field_fCoordinateCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fCoordinateCount) as usize - ptr as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fCoordinateCount))) ; } test_field_fCoordinateCount () ; fn test_field_fVariation () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fVariation) as usize - ptr as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fVariation))) ; } test_field_fVariation () ; fn test_field_fPaletteIndex () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaletteIndex) as usize - ptr as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fPaletteIndex))) ; } test_field_fPaletteIndex () ; fn test_field_fPaletteEntryOverrideCount () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaletteEntryOverrideCount) as usize - ptr as usize } , 92usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fPaletteEntryOverrideCount))) ; } test_field_fPaletteEntryOverrideCount () ; fn test_field_fPaletteEntryOverrides () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < SkFontDescriptor > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . fPaletteEntryOverrides) as usize - ptr as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (SkFontDescriptor) , "::" , stringify ! (fPaletteEntryOverrides))) ; } test_field_fPaletteEntryOverrides () ; } extern "C" { # [link_name = "\u{1}?Deserialize@SkFontDescriptor@@SA_NPEAVSkStream@@PEAV1@@Z"] pub fn SkFontDescriptor_Deserialize (arg1 : * mut SkStream , result : * mut SkFontDescriptor) -> bool ; } extern "C" { # [link_name = "\u{1}?serialize@SkFontDescriptor@@QEBAXPEAVSkWStream@@@Z"] pub fn SkFontDescriptor_serialize (this : * const SkFontDescriptor , arg1 : * mut SkWStream) ; } extern "C" { # [link_name = "\u{1}?SkFontStyleWidthForWidthAxisValue@SkFontDescriptor@@SA?AW4Width@SkFontStyle@@M@Z"] pub fn SkFontDescriptor_SkFontStyleWidthForWidthAxisValue (width : SkScalar) -> SkFontStyle_Width ; } extern "C" { # [link_name = "\u{1}??0SkFontDescriptor@@QEAA@XZ"] pub fn SkFontDescriptor_SkFontDescriptor (this : * mut SkFontDescriptor) ; } impl SkFontDescriptor { # [inline] pub unsafe fn Deserialize (arg1 : * mut SkStream , result : * mut SkFontDescriptor) -> bool { SkFontDescriptor_Deserialize (arg1 , result) } # [inline] pub unsafe fn serialize (& self , arg1 : * mut SkWStream) { SkFontDescriptor_serialize (self , arg1) } # [inline] pub unsafe fn SkFontStyleWidthForWidthAxisValue (width : SkScalar) -> SkFontStyle_Width { SkFontDescriptor_SkFontStyleWidthForWidthAxisValue (width) } # [inline] pub unsafe fn new () -> Self { let mut __bindgen_tmp = :: core :: mem :: MaybeUninit :: uninit () ; SkFontDescriptor_SkFontDescriptor (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } } extern "C" { pub fn C_FontArguments_Construct (fontArguments : * const SkFontArguments , uninitialized : * mut skia_textlayout_FontArguments) ; } extern "C" { pub fn C_FontArguments_CopyConstruct (uninitialized : * mut skia_textlayout_FontArguments , self_ : * const skia_textlayout_FontArguments) ; } extern "C" { pub fn C_FontArguments_destruct (self_ : * mut skia_textlayout_FontArguments) ; } extern "C" { pub fn C_FontArguments_Equals (lhs : * const skia_textlayout_FontArguments , rhs : * const skia_textlayout_FontArguments) -> bool ; } extern "C" { pub fn C_FontArguments_hash (self_ : * const skia_textlayout_FontArguments) -> usize ; } extern "C" { pub fn C_FontArguments_cloneTypeface (self_ : * const skia_textlayout_FontArguments , tf : * mut SkTypeface) -> * mut SkTypeface ; } extern "C" { pub fn C_FontCollection_new () -> * mut skia_textlayout_FontCollection ; } extern "C" { pub fn C_FontCollection_setAssetFontManager (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr) ; } extern "C" { pub fn C_FontCollection_setDynamicFontManager (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr) ; } extern "C" { pub fn C_FontCollection_setTestFontManager (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr) ; } extern "C" { pub fn C_FontCollection_setDefaultFontManager (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr) ; } extern "C" { pub fn C_FontCollection_setDefaultFontManager2 (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr , defaultFamilyName : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn C_FontCollection_setDefaultFontManager3 (self_ : * mut skia_textlayout_FontCollection , fontManager : * const SkFontMgr , familyNames : * const SkStrings) ; } extern "C" { pub fn C_FontCollection_getFallbackManager (self_ : * const skia_textlayout_FontCollection) -> * mut SkFontMgr ; } extern "C" { pub fn C_FontCollection_findTypefaces (self_ : * mut skia_textlayout_FontCollection , familyNames : * const SkStrings , fontStyle : SkFontStyle , fontArguments : * const skia_textlayout_FontArguments , typefaces : * mut VecSink < sk_sp < SkTypeface > >) ; } extern "C" { pub fn C_FontCollection_defaultFallback (self_ : * mut skia_textlayout_FontCollection , unicode : SkUnichar , fontStyle : SkFontStyle , locale : * const SkString) -> * mut SkTypeface ; } extern "C" { pub fn C_FontCollection_defaultFallback2 (self_ : * mut skia_textlayout_FontCollection) -> * mut SkTypeface ; } extern "C" { pub fn C_FontCollection_fontFallbackEnabled (self_ : * const skia_textlayout_FontCollection) -> bool ; } extern "C" { pub fn C_FontCollection_paragraphCache (self_ : * mut skia_textlayout_FontCollection) -> * mut skia_textlayout_ParagraphCache ; } extern "C" { pub fn C_ParagraphCache_destruct (self_ : * mut skia_textlayout_ParagraphCache) ; } extern "C" { pub fn C_ParagraphCache_count (self_ : * mut skia_textlayout_ParagraphCache) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn C_StrutStyle_Construct (uninitialized : * mut skia_textlayout_StrutStyle) ; } extern "C" { pub fn C_StrutStyle_CopyConstruct (uninitialized : * mut skia_textlayout_StrutStyle , other : * const skia_textlayout_StrutStyle) ; } extern "C" { pub fn C_StrutStyle_destruct (self_ : * mut skia_textlayout_StrutStyle) ; } extern "C" { pub fn C_StrutStyle_getFontFamilies (self_ : * const skia_textlayout_StrutStyle , count : * mut usize) -> * const SkString ; } extern "C" { pub fn C_StrutStyle_setFontFamilies (self_ : * mut skia_textlayout_StrutStyle , data : * const SkString , count : usize) ; } extern "C" { pub fn C_StrutStyle_equals (self_ : * const skia_textlayout_StrutStyle , rhs : * const skia_textlayout_StrutStyle) -> bool ; } extern "C" { pub fn C_ParagraphStyle_New () -> * mut skia_textlayout_ParagraphStyle ; } extern "C" { pub fn C_ParagraphStyle_NewCopy (other : * const skia_textlayout_ParagraphStyle) -> * mut skia_textlayout_ParagraphStyle ; } extern "C" { pub fn C_ParagraphStyle_delete (self_ : * mut skia_textlayout_ParagraphStyle) ; } extern "C" { pub fn C_ParagraphStyle_Equals (left : * const skia_textlayout_ParagraphStyle , right : * const skia_textlayout_ParagraphStyle) -> bool ; } extern "C" { pub fn C_ParagraphStyle_ellipsized (self_ : * const skia_textlayout_ParagraphStyle) -> bool ; } extern "C" { pub fn C_TextShadow_Equals (self_ : * const skia_textlayout_TextShadow , other : * const skia_textlayout_TextShadow) -> bool ; } extern "C" { pub fn C_LineMetrics_styleMetricsCount (self_ : * const skia_textlayout_LineMetrics) -> usize ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct IndexedStyleMetrics { pub index : usize , pub metrics : skia_textlayout_StyleMetrics , } # [test] fn bindgen_test_layout_IndexedStyleMetrics () { assert_eq ! (:: core :: mem :: size_of :: < IndexedStyleMetrics > () , 80usize , concat ! ("Size of: " , stringify ! (IndexedStyleMetrics))) ; assert_eq ! (:: core :: mem :: align_of :: < IndexedStyleMetrics > () , 8usize , concat ! ("Alignment of " , stringify ! (IndexedStyleMetrics))) ; fn test_field_index () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < IndexedStyleMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . index) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (IndexedStyleMetrics) , "::" , stringify ! (index))) ; } test_field_index () ; fn test_field_metrics () { assert_eq ! (unsafe { let uninit = :: core :: mem :: MaybeUninit :: < IndexedStyleMetrics > :: uninit () ; let ptr = uninit . as_ptr () ; :: core :: ptr :: addr_of ! ((* ptr) . metrics) as usize - ptr as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (IndexedStyleMetrics) , "::" , stringify ! (metrics))) ; } test_field_metrics () ; } extern "C" { pub fn C_LineMetrics_getAllStyleMetrics (self_ : * const skia_textlayout_LineMetrics , result : * mut IndexedStyleMetrics) ; } extern "C" { pub fn C_Paragraph_delete (self_ : * mut skia_textlayout_Paragraph) ; } extern "C" { pub fn C_Paragraph_layout (self_ : * mut skia_textlayout_Paragraph , width : SkScalar) ; } extern "C" { pub fn C_Paragraph_paint (self_ : * mut skia_textlayout_Paragraph , canvas : * mut SkCanvas , x : SkScalar , y : SkScalar) ; } extern "C" { pub fn C_Paragraph_getRectsForRange (self_ : * mut skia_textlayout_Paragraph , start : :: std :: os :: raw :: c_uint , end : :: std :: os :: raw :: c_uint , rectHeightStyle : skia_textlayout_RectHeightStyle , rectWidthStyle : skia_textlayout_RectWidthStyle , textBoxes : * mut VecSink < skia_textlayout_TextBox >) ; } extern "C" { pub fn C_Paragraph_getRectsForPlaceholders (self_ : * mut skia_textlayout_Paragraph , result : * mut VecSink < skia_textlayout_TextBox >) ; } extern "C" { pub fn C_Paragraph_getGlyphPositionAtCoordinate (self_ : * mut skia_textlayout_Paragraph , x : SkScalar , y : SkScalar , position : * mut skia_textlayout_PositionWithAffinity) ; } extern "C" { pub fn C_Paragraph_getWordBoundary (self_ : * mut skia_textlayout_Paragraph , offset : :: std :: os :: raw :: c_uint , range : * mut usize) ; } extern "C" { pub fn C_Paragraph_getLineMetrics (self_ : * mut skia_textlayout_Paragraph , result : * mut VecSink < skia_textlayout_LineMetrics >) ; } extern "C" { pub fn C_Paragraph_lineNumber (self_ : * mut skia_textlayout_Paragraph) -> usize ; } extern "C" { pub fn C_Paragraph_markDirty (self_ : * mut skia_textlayout_Paragraph) ; } extern "C" { pub fn C_Paragraph_unresolvedGlyphs (self_ : * mut skia_textlayout_Paragraph) -> i32 ; } extern "C" { pub fn C_ParagraphBuilder_delete (self_ : * mut skia_textlayout_ParagraphBuilder) ; } extern "C" { pub fn C_ParagraphBuilder_pushStyle (self_ : * mut skia_textlayout_ParagraphBuilder , style : * const skia_textlayout_TextStyle) ; } extern "C" { pub fn C_ParagraphBuilder_pop (self_ : * mut skia_textlayout_ParagraphBuilder) ; } extern "C" { pub fn C_ParagraphBuilder_peekStyle (self_ : * mut skia_textlayout_ParagraphBuilder , style : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_ParagraphBuilder_addText (self_ : * mut skia_textlayout_ParagraphBuilder , text : * const :: std :: os :: raw :: c_char , len : usize) ; } extern "C" { pub fn C_ParagraphBuilder_addPlaceholder (self_ : * mut skia_textlayout_ParagraphBuilder , placeholderStyle : * const skia_textlayout_PlaceholderStyle) ; } extern "C" { pub fn C_ParagraphBuilder_Build (self_ : * mut skia_textlayout_ParagraphBuilder) -> * mut skia_textlayout_Paragraph ; } extern "C" { pub fn C_ParagraphBuilder_Reset (self_ : * mut skia_textlayout_ParagraphBuilder) ; } extern "C" { pub fn C_ParagraphBuilder_make (style : * const skia_textlayout_ParagraphStyle , fontCollection : * const skia_textlayout_FontCollection) -> * mut skia_textlayout_ParagraphBuilder ; } extern "C" { pub fn C_TextStyle_Types (arg1 : * const skia_textlayout_Block , arg2 : * const skia_textlayout_Placeholder) ; } extern "C" { pub fn C_FontFeature_CopyConstruct (uninitialized : * mut skia_textlayout_FontFeature , other : * const skia_textlayout_FontFeature) ; } extern "C" { pub fn C_FontFeature_destruct (self_ : * mut skia_textlayout_FontFeature) ; } extern "C" { pub fn C_TextStyle_Construct (uninitialized : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_CopyConstruct (uninitialized : * mut skia_textlayout_TextStyle , other : * const skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_cloneForPlaceholder (self_ : * const skia_textlayout_TextStyle , uninitialized : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_destruct (self_ : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_getShadows (self_ : * const [u64 ; 3usize] , len_ref : * mut usize) -> * const skia_textlayout_TextShadow ; } extern "C" { pub fn C_TextStyle_addShadow (self_ : * mut skia_textlayout_TextStyle , shadow : * const skia_textlayout_TextShadow) ; } extern "C" { pub fn C_TextStyle_resetShadows (self_ : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_getFontFeatures (self_ : * const [u64 ; 3usize] , len_ref : * mut usize) -> * const skia_textlayout_FontFeature ; } extern "C" { pub fn C_TextStyle_addFontFeature (self_ : * mut skia_textlayout_TextStyle , fontFeature : * const SkString , value : :: std :: os :: raw :: c_int) ; } extern "C" { pub fn C_TextStyle_resetFontFeatures (self_ : * mut skia_textlayout_TextStyle) ; } extern "C" { pub fn C_TextStyle_getFontArguments (self_ : * const skia_textlayout_TextStyle) -> * const skia_textlayout_FontArguments ; } extern "C" { pub fn C_TextStyle_setFontArguments (self_ : * mut skia_textlayout_TextStyle , arguments : * const SkFontArguments) ; } extern "C" { pub fn C_TextStyle_getFontFamilies (self_ : * const skia_textlayout_TextStyle , count : * mut usize) -> * const SkString ; } extern "C" { pub fn C_TextStyle_setFontFamilies (self_ : * mut skia_textlayout_TextStyle , data : * const SkString , count : usize) ; } extern "C" { pub fn C_TextStyle_setTypeface (self_ : * mut skia_textlayout_TextStyle , typeface : * mut SkTypeface) ; } extern "C" { pub fn C_TypefaceFontStyleSet_new (family_name : * const SkString) -> * mut skia_textlayout_TypefaceFontStyleSet ; } extern "C" { pub fn C_TypefaceFontStyleSet_appendTypeface (self_ : * mut skia_textlayout_TypefaceFontStyleSet , typeface : * mut SkTypeface) ; } extern "C" { pub fn C_TypefaceFontProvider_new () -> * mut skia_textlayout_TypefaceFontProvider ; } extern "C" { pub fn C_TypefaceFontProvider_registerTypeface (self_ : * mut skia_textlayout_TypefaceFontProvider , typeface : * mut SkTypeface , alias : * const SkString) -> usize ; } # [test] fn __bindgen_test_layout_std_basic_string_view_open0_char_std_char_traits_open1_char_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_basic_string_view < :: std :: os :: raw :: c_char > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (std_basic_string_view < :: std :: os :: raw :: c_char >))) ; assert_eq ! (:: core :: mem :: align_of :: < std_basic_string_view < :: std :: os :: raw :: c_char > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (std_basic_string_view < :: std :: os :: raw :: c_char >))) ; } # [test] fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_char_traits > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_char_traits))) ; assert_eq ! (:: core :: mem :: align_of :: < std_char_traits > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_char_traits))) ; } # [test] fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_char_traits > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_char_traits))) ; assert_eq ! (:: core :: mem :: align_of :: < std_char_traits > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_char_traits))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkString_Rec > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkString_Rec >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkString_Rec > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkString_Rec >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkString_Rec_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkString_Rec > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkString_Rec >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkString_Rec > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkString_Rec >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_SkNVRefCnt_open0_SkData_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkNVRefCnt > () , 4usize , concat ! ("Size of template specialization: " , stringify ! (SkNVRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNVRefCnt > () , 4usize , concat ! ("Alignment of template specialization: " , stringify ! (SkNVRefCnt))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkNVRefCnt_open0_SkColorSpace_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkNVRefCnt > () , 4usize , concat ! ("Size of template specialization: " , stringify ! (SkNVRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNVRefCnt > () , 4usize , concat ! ("Alignment of template specialization: " , stringify ! (SkNVRefCnt))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_16 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_17 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_18 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_19 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_20 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_16 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkEncodedInfo_ICCProfile_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_17 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCodec_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStream_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSpecialImage_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSpecialImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSpecialImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSpecialImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSpecialImage >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_Layer_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_BackImage_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBaseDevice_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBaseDevice > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBaseDevice >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkRasterHandleAllocator_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_sktext_GlyphRunBuilder_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_18 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_19 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathRef_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathRef > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathRef >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathRef > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathRef >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkContourMeasure > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkContourMeasure >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkContourMeasure > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkContourMeasure >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkContourMeasureIter_Impl_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDataTable_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDataTable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDataTable >))) ; } # [test] fn __bindgen_test_layout_std_chrono_duration_open0_long_long_std_milli_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (std_chrono_duration < :: std :: os :: raw :: c_longlong >))) ; assert_eq ! (:: core :: mem :: align_of :: < std_chrono_duration < :: std :: os :: raw :: c_longlong > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (std_chrono_duration < :: std :: os :: raw :: c_longlong >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_20 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_21 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_22 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_21 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_23 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_22 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_23 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_16 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_17 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_18 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_24 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_19 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_25 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_20 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_26 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_21 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_27 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_22 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_28 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_23 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_29 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_30 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_24 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_25 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_26 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_24 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_25 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_26 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_27 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_28 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_29 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_30 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_31 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_31 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_32 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_32 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_33 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_33 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrBackendSurfaceMutableStateImpl_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrBackendSurfaceMutableStateImpl > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrBackendSurfaceMutableStateImpl >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrBackendSurfaceMutableStateImpl > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrBackendSurfaceMutableStateImpl >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrBackendSurfaceMutableStateImpl_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrBackendSurfaceMutableStateImpl > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrBackendSurfaceMutableStateImpl >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrBackendSurfaceMutableStateImpl > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrBackendSurfaceMutableStateImpl >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_27 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkNVRefCnt_open0_GrContextThreadSafeProxy_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkNVRefCnt > () , 4usize , concat ! ("Size of template specialization: " , stringify ! (SkNVRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNVRefCnt > () , 4usize , concat ! ("Alignment of template specialization: " , stringify ! (SkNVRefCnt))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrCaps > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrCaps >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrCaps > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrCaps >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_sktext_gpu_TextBlobRedrawCoordinator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_GrThreadSafeCache_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrThreadSafePipelineBuilder_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrThreadSafePipelineBuilder > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrThreadSafePipelineBuilder >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrThreadSafePipelineBuilder > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrThreadSafePipelineBuilder >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_34 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrCaps_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrCaps > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrCaps >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrCaps > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrCaps >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkArenaAlloc_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_sktext_gpu_SubRunAllocator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_GrProgramDesc_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_GrProgramDesc_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDeferredDisplayList > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDeferredDisplayList > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_35 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_34 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_36 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_35 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrRecordingContext_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrRecordingContext > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrRecordingContext >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrRecordingContext > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrRecordingContext >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrRenderTargetProxy_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrRenderTargetProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrRenderTargetProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrRenderTargetProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrRenderTargetProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_LazyProxyData_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDeferredDisplayList_LazyProxyData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList_LazyProxyData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDeferredDisplayList_LazyProxyData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList_LazyProxyData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_28 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_29 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_30 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_31 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_32 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_16 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_17 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_33 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_18 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_19 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_20 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_21 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_22 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_34 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImageFilter_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImageFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImageFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_37 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPixelRef > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPixelRef >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPixelRef > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPixelRef >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_36 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPixelRef_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPixelRef > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPixelRef >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPixelRef > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPixelRef >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMipmap_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMipmap > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMipmap >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMipmap > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMipmap >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_35 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_38 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkImageGenerator_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkMaskFilter_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkMaskFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkMaskFilter >))) ; } # [test] fn __bindgen_test_layout_SkTDArray_open0_SkPoint_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkTDArray < SkPoint > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkTDArray < SkPoint >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTDArray < SkPoint > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkTDArray < SkPoint >))) ; } # [test] fn __bindgen_test_layout_SkTDArray_open0_uint8_t_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkTDArray < u8 > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkTDArray < u8 >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTDArray < u8 > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkTDArray < u8 >))) ; } # [test] fn __bindgen_test_layout_SkTDArray_open0_SkScalar_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkTDArray < SkScalar > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkTDArray < SkScalar >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTDArray < SkScalar > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkTDArray < SkScalar >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkContourMeasure_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkContourMeasure > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkContourMeasure >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkContourMeasure > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkContourMeasure >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_36 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBBoxHierarchy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBBoxHierarchy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBBoxHierarchy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBBoxHierarchy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPicture_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPicture > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPicture >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBBoxHierarchy_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBBoxHierarchy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBBoxHierarchy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBBoxHierarchy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBBoxHierarchy >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkRecorder_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkRecord_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkRecord > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkRecord >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkRecord > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkRecord >))) ; } # [test] fn __bindgen_test_layout_SkTDArray_open0_ptr_SkIDChangeListener_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkTDArray < * mut SkIDChangeListener > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkTDArray < * mut SkIDChangeListener >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTDArray < * mut SkIDChangeListener > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkTDArray < * mut SkIDChangeListener >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_37 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_38 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkMemoryStream_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_39 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_40 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_41 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_39 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_40 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSurface_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSurface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSurface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_37 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_38 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_41 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDeferredDisplayList_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDeferredDisplayList > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDeferredDisplayList > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDeferredDisplayList >))) ; } # [test] fn __bindgen_test_layout_SkNVRefCnt_open0_SkTextBlob_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkNVRefCnt > () , 4usize , concat ! ("Size of template specialization: " , stringify ! (SkNVRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNVRefCnt > () , 4usize , concat ! ("Alignment of template specialization: " , stringify ! (SkNVRefCnt))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_42 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_SkNVRefCnt_open0_SkVertices_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkNVRefCnt > () , 4usize , concat ! ("Size of template specialization: " , stringify ! (SkNVRefCnt))) ; assert_eq ! (:: core :: mem :: align_of :: < SkNVRefCnt > () , 4usize , concat ! ("Alignment of template specialization: " , stringify ! (SkNVRefCnt))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkVertices_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkVertices > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkVertices >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_float_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkPDFArray_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_SkPDF_StructureElementNode_std_default_delete_open2_SkPDF_StructureElementNode_close2_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkPDF_StructureElementNode_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_int_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkPathEffect_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkPathEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkPathEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_42 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_43 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_44 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_45 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_16 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_17 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_46 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_18 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_47 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_19 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_20 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_48 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_21 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_49 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_22 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorSpace_close0_instantiation_50 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorSpace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorSpace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_23 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkRuntimeEffect_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkRuntimeEffect > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkRuntimeEffect >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkRuntimeEffect > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkRuntimeEffect >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFlattenable_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFlattenable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFlattenable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_43 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_24 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_25 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_44 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_26 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_45 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkImage_close0_instantiation_39 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkImage >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkImage > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkImage >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_46 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_47 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_48 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkColorFilter_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkColorFilter > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkColorFilter >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_49 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_SkSpan_open0_SkRuntimeEffect_ChildPtr_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkSpan < SkRuntimeEffect_ChildPtr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkSpan < SkRuntimeEffect_ChildPtr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkBlender_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkBlender > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkBlender >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_27 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkSL_DebugTrace_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkSL_DebugTrace > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkSL_DebugTrace >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkSL_DebugTrace > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkSL_DebugTrace >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkShader_close0_instantiation_28 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkShader >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkShader > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkShader >))) ; } # [test] fn __bindgen_test_layout_SkTDArray_open0_SkPathOp_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < SkTDArray < SkPathOp > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (SkTDArray < SkPathOp >))) ; assert_eq ! (:: core :: mem :: align_of :: < SkTDArray < SkPathOp > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (SkTDArray < SkPathOp >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkCanvas_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_23 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkDrawable_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkDrawable > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkDrawable >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkCustomTypefaceBuilder_GlyphRec_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkData_close0_instantiation_50 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkData >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkData > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkData >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_24 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_25 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_26 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_27 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_28 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkFontMgr_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_VecSink_open0_SkScalar_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < VecSink < SkScalar > > () , 24usize , concat ! ("Size of template specialization: " , stringify ! (VecSink < SkScalar >))) ; assert_eq ! (:: core :: mem :: align_of :: < VecSink < SkScalar > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (VecSink < SkScalar >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrDirectContext_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrDirectContext > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrDirectContext >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrContextThreadSafeProxy_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrContextThreadSafeProxy > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrContextThreadSafeProxy >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_GrVkMemoryAllocator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < GrVkMemoryAllocator > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < GrVkMemoryAllocator >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < GrVkMemoryAllocator > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < GrVkMemoryAllocator >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_8 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_FontRunIterator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_9 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_FontRunIterator_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_BiDiRunIterator_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_ScriptRunIterator_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkShaper_LanguageRunIterator_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTextBlob_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTextBlob > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTextBlob >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_29 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_30 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkFontArguments_VariationPosition_Coordinate_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkFontArguments_Palette_Override_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextShadow_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_31 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_FontFeature_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_SkRange < usize > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_SkRange < usize > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; } # [test] fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_SkRange < usize > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_SkRange < usize > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_10 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_11 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_12 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_14 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkFontMgr_close0_instantiation_15 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkFontMgr > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkFontMgr >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_3 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_4 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_32 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_33 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_5 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_34 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_35 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_36 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_37 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_6 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_less_open0_unsigned_long_long_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_less > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_less))) ; assert_eq ! (:: core :: mem :: align_of :: < std_less > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_less))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_std_pair_open1_const_unsigned_long_long_skia_textlayout_StyleMetrics_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_pair_open0_const_unsigned_long_long_skia_textlayout_StyleMetrics_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_pair < :: std :: os :: raw :: c_ulonglong , skia_textlayout_StyleMetrics > > () , 80usize , concat ! ("Size of template specialization: " , stringify ! (std_pair < :: std :: os :: raw :: c_ulonglong , skia_textlayout_StyleMetrics >))) ; assert_eq ! (:: core :: mem :: align_of :: < std_pair < :: std :: os :: raw :: c_ulonglong , skia_textlayout_StyleMetrics > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (std_pair < :: std :: os :: raw :: c_ulonglong , skia_textlayout_StyleMetrics >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_SkString_close0_instantiation_7 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextBox_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextBox_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_skia_textlayout_SkRange_open0_size_t_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < skia_textlayout_SkRange < usize > > () , 16usize , concat ! ("Size of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; assert_eq ! (:: core :: mem :: align_of :: < skia_textlayout_SkRange < usize > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (skia_textlayout_SkRange < usize >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_LineMetrics_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_skia_textlayout_Paragraph_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_FontCollection_close0_instantiation_2 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < skia_textlayout_FontCollection > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < skia_textlayout_FontCollection >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_skia_textlayout_ParagraphBuilder_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_38 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_39 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_40 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_41 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_skia_textlayout_TypefaceFontStyleSet_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < skia_textlayout_TypefaceFontStyleSet > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < skia_textlayout_TypefaceFontStyleSet >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < skia_textlayout_TypefaceFontStyleSet > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < skia_textlayout_TypefaceFontStyleSet >))) ; } # [test] fn __bindgen_test_layout_std_default_delete_open0_SkStreamAsset_close0_instantiation_13 () { assert_eq ! (:: core :: mem :: size_of :: < std_default_delete > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_default_delete))) ; assert_eq ! (:: core :: mem :: align_of :: < std_default_delete > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_default_delete))) ; } # [test] fn __bindgen_test_layout_VecSink_open0_sk_sp_open1_SkTypeface_close1_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < VecSink < sk_sp < SkTypeface > > > () , 24usize , concat ! ("Size of template specialization: " , stringify ! (VecSink < sk_sp < SkTypeface > >))) ; assert_eq ! (:: core :: mem :: align_of :: < VecSink < sk_sp < SkTypeface > > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (VecSink < sk_sp < SkTypeface > >))) ; } # [test] fn __bindgen_test_layout_sk_sp_open0_SkTypeface_close0_instantiation_42 () { assert_eq ! (:: core :: mem :: size_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Size of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; assert_eq ! (:: core :: mem :: align_of :: < sk_sp < SkTypeface > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (sk_sp < SkTypeface >))) ; } # [test] fn __bindgen_test_layout_VecSink_open0_skia_textlayout_TextBox_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < VecSink < skia_textlayout_TextBox > > () , 24usize , concat ! ("Size of template specialization: " , stringify ! (VecSink < skia_textlayout_TextBox >))) ; assert_eq ! (:: core :: mem :: align_of :: < VecSink < skia_textlayout_TextBox > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (VecSink < skia_textlayout_TextBox >))) ; } # [test] fn __bindgen_test_layout_VecSink_open0_skia_textlayout_TextBox_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < VecSink < skia_textlayout_TextBox > > () , 24usize , concat ! ("Size of template specialization: " , stringify ! (VecSink < skia_textlayout_TextBox >))) ; assert_eq ! (:: core :: mem :: align_of :: < VecSink < skia_textlayout_TextBox > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (VecSink < skia_textlayout_TextBox >))) ; } # [test] fn __bindgen_test_layout_VecSink_open0_skia_textlayout_LineMetrics_close0_instantiation () { assert_eq ! (:: core :: mem :: size_of :: < VecSink < skia_textlayout_LineMetrics > > () , 24usize , concat ! ("Size of template specialization: " , stringify ! (VecSink < skia_textlayout_LineMetrics >))) ; assert_eq ! (:: core :: mem :: align_of :: < VecSink < skia_textlayout_LineMetrics > > () , 8usize , concat ! ("Alignment of template specialization: " , stringify ! (VecSink < skia_textlayout_LineMetrics >))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_TextShadow_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; } # [test] fn __bindgen_test_layout_std_allocator_open0_skia_textlayout_FontFeature_close0_instantiation_1 () { assert_eq ! (:: core :: mem :: size_of :: < std_allocator > () , 1usize , concat ! ("Size of template specialization: " , stringify ! (std_allocator))) ; assert_eq ! (:: core :: mem :: align_of :: < std_allocator > () , 1usize , concat ! ("Alignment of template specialization: " , stringify ! (std_allocator))) ; }